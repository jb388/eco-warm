---
title: "swaedie_test"
author: "J. Beem-Miller"
date: "2024-03-08"
output: html_document
---

```{r global_options, include = FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE,
                      fig.align = 'center', dev = c('cairo_pdf', 'png'))
options(scipen = 5)
# load read ess_dive fx
source("./utilities/read_ess-dive.fx.R")
```

```{r setup, include = FALSE}
library(ggplot2)
library(cowplot)
library(tidyr)
library(SoilR)
library(readxl)
library(ISRaD)
library(lme4)
library(lmerTest)
library(emmeans)
library(gt)
library(scales)
library(viridis)
library(mpspline2)
library(zoo)
library(dplyr)
library(lubridate)
library(terra)
library(tidyterra)
library(stringr)
library(purrr)
library(knitr)
# library(stringdist)
library(forcats)
library(xts)
```

```{r utils}
# add carriage return to .csv files (recursive by default)
crAdd <- function(file) {
  write.table(
    "", file = file, sep = ",", append = TRUE, quote = FALSE, col.names = FALSE, row.names = FALSE)
}

# wrapper for running on a directory
crAdd_dir <- function(dataDir, ..) {
  ls <- list.files(path = dataDir, pattern = ".csv$", recursive = TRUE, full.names = TRUE)
  sapply(ls, crAdd)
}

# print if (verbose)
vcat <- function(..., verbose = TRUE) if (verbose) cat(...)

# read core data
readCore <- function(coreDir, return = "template") {
  # get dir name as needed
  if (missing(coreDir)) {
    coreDir <- "../data/sweddie/metadata/core"
  }
  # create template list
  ls <- list.files(coreDir, full.names = TRUE)
  ix.dd <- grep("_dd", ls)
  ls.dd <- ls[ix.dd]
  ls.tm <- ls[-ix.dd]
  dd <- lapply(
    setNames(ls.dd, nm = sapply(strsplit(basename(ls.dd), "_"), "[[", 1)),
    read.csv)
  if (return == "template") {
    lapply(dd, function(x) {
        setNames(data.frame(matrix(ncol = nrow(x), nrow = 0)), x[ , 1])
      })
  } else {
    return(dd)
  }
}

# checks column names
checkColNms <- function(tableName, datIn, err, outfile = outfile) {
  
  vcat("\t", tableName, "\n", append = TRUE, file = outfile)
  
  # check for template
  metadata <- readCore(return = "dd")

  # check that required data files are present (experiment, site, plot)
  if (!any(grepl(tableName, names(datIn)))) {
    err <- err + 1
    vcat("\t", tableName, "is missing in metadata/siteData directory\n", append = TRUE, file = outfile)
  }
  
  # check that required columns are present
  req <- metadata[[tableName]][which(metadata[[tableName]][["req"]] == "yes"), 1]
  for (i in seq_along(req)) {
    if (!any(grepl(req[i], names(datIn[[tableName]])))) {
      err <- err + 1
      vcat("\t\t", "Required column", req[i], "is missing in", tableName, "table\n", append = TRUE, file = outfile)
    }
  }
  
  # check for missing cols in data
  miss <- setdiff(metadata[[tableName]][["col_name"]], colnames(datIn[[tableName]]))
  miss <- miss[!(miss %in% req)]

  # check for extra cols in data
  xtra <- setdiff(colnames(datIn[[tableName]]), metadata[[tableName]][["col_name"]])

  if (length(miss) > 0 ) {
    vcat("\t\t Non-required columns missing from data:", miss, "\n", append = TRUE, file = outfile)
  }
  if (length(xtra > 0)) {
    xtras <- sapply(seq_along(xtra), function(i) {
      ix <- which(colnames(datIn[[tableName]]) == xtra[i])
      paste0(xtra[i], " (", ix, ")")
    }) 
    vcat("\t\t Extra columns:", xtras, "\n", append = TRUE, file = outfile)
  }
  return(err)
}

siteMap <- function(database) {
  # stopifnot(is_israd_database(database))

  latlon <- database$site[, 3:4]
  world <- map_data("world")
  ggplot() +
    geom_polygon(data = world, aes(x = .data$long, y = .data$lat, group = .data$group), fill = NA, color = "Black") +
    geom_point(data = latlon, aes(x = .data$sit_long, y = .data$sit_lat), color = "red", size = 2, alpha = 0.5) +
    theme_bw(base_size = 16) +
    labs(title = "SWEDDIE: Site_Map", x = "Longitude", y = "Latitude")
}

# get csv names
getCSVnms <- function (path.csv) {
  names(read.csv(path.csv, nrows = 1, check.names = FALSE, strip.white = TRUE))
}
```

# Build core database

```{r sweddie-assemble}
coreData.fx <- function(DIR = "../data/sweddie", write_report = TRUE, verbose = TRUE) {
 
  # Constants
  DB_DIR <- "database"
  S_DIR <- "siteData"
  LIST_FILE <- "coreData.rda"
  TIMESTAMP <- format(Sys.time(), "%y%m%d-%H%M") 
    
  # Set output file
  outfile <- ""
  if (write_report) {
    outfile <- file.path(DIR, DB_DIR, paste0("logs/coreLog", "_", TIMESTAMP, ".txt"))
    invisible(file.create(outfile))
  }
  
  # Start writing in the output file
  vcat("SWEDDIE Compilation Log \n",
       "\n", as.character(Sys.time()),
       "\n", rep("-", 15), "\n", file = outfile, verbose = verbose)
  
  vcat("\n\nCompiling data files in", S_DIR, "\n", rep("-", 30), "\n", file = outfile, append = TRUE, verbose = verbose)
  
  data_dirs <- list.dirs(file.path(DIR, S_DIR), full.names = TRUE, recursive = FALSE)
  if (!length(data_dirs)) {
    vcat(warning("No data directories found!\n"), file = outfile, append = TRUE, verbose = verbose)
    return(NULL)
  }
  
  # ensure EOL carriage return present
  invisible(crAdd_dir(file.path(DIR, S_DIR)))
  
  vcat("Compiling and checking core data...\n\n", file = outfile, append = TRUE, verbose = verbose)
    #   pb <- txtProgressBar(min = 0, max = length(data_dirs), style = 3)
    # }
    # 
    # check if previous database object exists in database directory, and only update file if new data exisit
  if (file.exists(file.path(DIR, DB_DIR, LIST_FILE))) {
    
    # load existing database
    load(file.path(dataset_directory, DB_DIR, LIST_FILE)) # obj "coreDat"
    
    # convert to character and coerce to list of data frames
    coreDat_chr <- lapplydf(lapply(coreData, function(x) lapply(x, as.character)))
  
    # remove old version
    rm(coreDat)
  
    # Split each table by entry_name
    coreDat_old <- lapply(coreDat_chr, function(x) split(x, x$exp_name))
  } else {
    database <- setNames(vector(mode = "list", length = length(data_dirs)), nm = basename(data_dirs))
  }
  
  # compile new templates and check against existing data
  for (d in seq_along(database)) {
    cat(names(database[d]), "\n")
    # get expName
    expName <- names(database[d])
    
    vcat("\n", expName, "\n", file = outfile, append = TRUE, verbose = verbose)
    
    # get tables
    tbls <- list.files(data_dirs[d], full.names = TRUE)
    
    # read files
    datIn <- lapply(
      setNames(tbls, nm = sub("\\..*", "", basename(tbls))), 
      function(f) {
        df <- read.csv(f, stringsAsFactors = FALSE, strip.white = TRUE)
        
        # Trim leading/trailing spaces in all character columns
        df[] <- lapply(df, function(x) {
          if (is.character(x)) trimws(x) else x
        })
        
        # Remove rows where all values are NA or empty string
        df <- df[rowSums(is.na(df) | df == "") != ncol(df), ]
        
        df
      }
    )
    
    # check data fidelity against template
    err <- 0
    for (i in seq_along(datIn)) {
      
      # check column names
      err <- checkColNms(names(datIn)[i], datIn, err, outfile = outfile)
      
      # check data types
      
      # check data values
    }
    
    # bind to database
    if (err == 0) database[[d]] <- datIn
  }
  database
}
database <- coreData.fx()
```

# read_meta function
Reads data dictionary and file level metadata files

```{r read-dat}
read_meta <- function (expName, verbose = TRUE, write_out = FALSE, write_report = FALSE, append = FALSE, ...) {
  
  # get site dir paths and variable directory names
  exp.ls <- list.dirs("../data/experiments", recursive = FALSE)
  exp.dir <- exp.ls[match(expName, basename(exp.ls))]
  stopifnot(dir.exists(exp.dir))
  
  # report
  if (write_report) {
    vcat("\n\nCompiling metadata files in", exp.dir, "\n", rep("-", 30), "\n", file = outfile, append = append, verbose = verbose) 
  } else {
    outfile <- ""
  }

  if (length(list.files(exp.dir)) == 0) {
    if (write_report) {
      vcat("\n", expName, "\n\n", "No files found in ", exp.dir, file = outfile, append = append, verbose = verbose)
    }
    return (NULL)
  } else {
    dat.dir <- file.path(exp.dir, "input_data")
    stopifnot(dir.exists(dat.dir))
    dat.dir.ls <- list.files(dat.dir, full.names = TRUE)
    mta.dir <- file.path(exp.dir, "meta")
    stopifnot(dir.exists(mta.dir))
    mta.dir.ls <- list.files(mta.dir, full.names = TRUE)
    
    # check metadata directory
    flmd.ls <- mta.dir.ls[which(grepl("_flmd.csv", mta.dir.ls))]
    dd.ls <- mta.dir.ls[which(grepl("_dd.csv", mta.dir.ls))]
    
    # ensure EOL carriage return present
    invisible(crAdd_dir(mta.dir))
    
    if (length(flmd.ls) == 0 | length(dd.ls) == 0) {
      return (NULL)
    }
    
    # check for non-standard files
    if (sum(length(flmd.ls), length(dd.ls)) != length(mta.dir.ls)) {
      ix <- which(!(basename(mta.dir.ls) %in% c(basename(flmd.ls), basename(dd.ls))))
      vcat("\t meta directory contains the following non-standard files that will be ignored:\n", basename(mta.dir.ls)[ix], "\n", file = outfile, append = append, verbose = verbose)
    }
    
    # get valid input data names from dd.ls
    dat.ls <- dat.dir.ls[which(basename(dat.dir.ls) %in% basename(gsub("_dd", "", dd.ls)))]
    
    # exclude dd files without matching input data
    ix <- which(is.na(match(basename(gsub("_dd", "", dd.ls)), basename(dat.dir.ls))))
    if (length(ix) > 0) {
      vcat("\tThe following data dictionary files are missing input data and will not be ingested:\n", basename(dd.ls)[ix], "\n", file = outfile, append = append, verbose = verbose)
      dd.ls <- dd.ls[-ix]
    }
    
    # report input data missing dd file
    ix <- which(is.na(match(basename(dat.dir.ls), basename(gsub("_dd", "", dd.ls)))))
    if (length(ix) > 0) {
      vcat("\tThe following input data files are missing data dictionaries and will not be ingested:\n", basename(dat.dir.ls)[ix], "\n", file = outfile, append = append, verbose = verbose)
      dat.dir.ls <- dat.dir.ls[-ix] 
    }
    
    # read dd files
    dd <- lapply(dd.ls, read.csv, strip.white = TRUE)
    names(dd) <- gsub("\\.csv", "", basename(dd.ls))
  
    # read flmd files
    flmd <- lapply(flmd.ls, read.csv, strip.white = TRUE)
    names(flmd) <- gsub("\\.csv", "", basename(flmd.ls))
    
    # exclude input files without matching flmd
    if (length(dat.ls) > 0) {
     ix <- which(unlist(lapply(lapply(basename(dat.ls), function(x)
      unlist(lapply(flmd, function(y)
        lapply(y$fileName, function(z)
          grep(glob2rx(z), x))))), function(d) length(d) == 0)))
     if (length(ix) > 0) {
      vcat("\tThe following input data files are missing flmd and will not be ingested:\n", basename(dat.ls)[ix], "\n", file = outfile, append = append, verbose = verbose)
      dat.ls <- dat.ls[-ix]
     }
    }
    
    # exclude flmd files without matching input data
    flmd.na <- Filter(Negate(is.null), lapply(flmd, function(x)
      names(unlist(
        sapply(
          sapply(
            glob2rx(x$fileName), grep, basename(dat.ls)), 
          function(y) which(length(y) == 0))))))
    if (length(unlist(flmd.na)) > 0) {
      flmd.na.nms <- unlist(lapply(flmd, function(x) {
        ix <- unlist(sapply(unlist(flmd.na), grep, x$fileName))
        x$fileName[ix]
      }))
      flmd <- lapply(flmd, function(x) x[-ix, ])
      vcat(paste0("The following input files are listed in the flmd file '", names(flmd.na.nms), ".csv', but cannot be found:\n", flmd.na.nms, "\n"), file = outfile, append = append, verbose = verbose)
    }
    
    # check input data names against dd
    dat.ls.colNms <- lapply(
      setNames(dat.dir.ls, nm = basename(dat.dir.ls)), getCSVnms)
    
    for (i in seq_along(dat.ls.colNms)) {
      
      if (any(!(dat.ls.colNms[[i]] %in% dd[[i]][["colName"]]))) {
        miss <- dat.ls.colNms[[i]][which(!(dat.ls.colNms[[i]] %in% dd[[i]][["colName"]]))]
        vcat("Data dictionary file '", basename(dd.ls[i]), "' missing column/s: ", miss, "\n", file = outfile, append = append, verbose = verbose)
      }
    }
    return(list(flmd = flmd, dd = dd))
  }
}
```

# Helper functions

```{r helper-fxs}
# template for creating data dictionary files
dd_helper <- function(expName, dataName, DATA_DIR = NULL, write_out = TRUE) {
  if (is.null(DATA_DIR)) {
    DATA_DIR <- file.path("~/eco-warm/data/experiments", expName, "input_data") 
    META_DIR <- file.path("~/eco-warm/data/experiments", expName, "meta") 
  }
  template <- read.csv(
    "~/eco-warm/data/sweddie/metadata/datTemplate_dd.csv",
    stringsAsFactors = FALSE,
    check.names = FALSE)
  data <- read.csv(
    file.path(DATA_DIR, paste0(dataName, ".csv")),
    nrows = 1,
    check.names = FALSE) # this prevents replacement of characters to be R friendly
  template[1:ncol(data), 1] <- names(data)
  if (write_out) {
    write.csv(x = template, 
              file = file.path(META_DIR, paste0(dataName, "_dd.csv")),
              row.names = FALSE)
  } else {
    template
  }
}

# template for flmd
flmd_helper <- function(expName, dataFileName, dateColName = NULL, rename = FALSE, append = TRUE, write_out = TRUE, orders = NULL, ...) {
  
  # print dataFileName
  cat(paste(dataFileName, "\n"))
    
  # list optionals
  optArgs <- list(...)
  
  # set data directory path
  DATA_DIR <- file.path("~/eco-warm/data/experiments", expName, "input_data") 
  META_DIR <- file.path("~/eco-warm/data/experiments", expName, "meta")
  
  # check for flmd_dd.ls
  if (!exists("getFLMD_DD")) {
    source("~/eco-warm/src/utilities/utils.R")
  }
  if (!exists("flmd_dd.ls")) {
    flmd_dd.ls <- getFLMD_DD()
  }
  
  # get flmd template
  if (append) {
    files <- list.files(
        META_DIR,
        full.names = TRUE)
    flmd.s <- as.list(files[grepl("flmd", files)])
    if (length(flmd.s) == 0) {
      stop ("cannot append record: no flmd files found")
    }
    if (length(flmd.s) > 1) {
     i <- menu(
      basename(flmd.s), 
      title = "To which FLMD should new record be appended?") 
    } else {
      i <- 1
    }
    flmdName <- flmd.s[[i]]
    flmd <- read.csv(flmdName)
  } else {
    flmd <- read.csv("~/eco-warm/data/sweddie/metadata/flmd_SWEDDIE.csv")
    flmdName <- file.path(META_DIR, paste0(expName, "_", "flmd.csv"))
  }
  
  # get data
  data <- read.csv(file.path(DATA_DIR, paste0(dataFileName, ".csv")))
  
  # fill out flmd
  nm <- setNames(vector(length = ncol(flmd), mode = "list"), names(flmd))
  if (!is.null(optArgs[["Jeff"]])) {
    nm[["name"]] <- "Jeffrey Beem-Miller"
    nm[["email"]] <- "jbeemmiller@lbl.gov"
  }
  nm[["fileName"]] <- paste0(dataFileName, ".csv")
  if (!missing(orders)) {
    data[[dateColName]] <- parse_date_time(data[[dateColName]], orders = orders)
  } else {
    data[[dateColName]] <- ymd_hms(data[[dateColName]], truncated = 5)
  }
  nm[["startDate"]] <- as.character(min(data[[dateColName]], na.rm = TRUE))
  nm[["endDate"]] <- as.character(max(data[[dateColName]], na.rm = TRUE))
  
  # helper function for menus
  menu.fx <- function(opt = unique(flmd[[i]])) {
    if (is.null(nm[[i]])) {
      j <- menu(c("yes", "no"), title = paste0("Do you want to use a previously entered ", names(nm)[i], "?")) 
      if (j == 1) {
        sel <- menu(opt, "Please use one of the following options for your data (enter '0' if none are appropriate)")
        if (sel != 0) {
          opt[sel]
        } else {
          nm[[i]] <- readline(prompt = paste0(names(flmd)[i], "? ")) 
        } 
      } else {
        nm[[i]] <- readline(prompt = paste0(names(flmd)[i], "? ")) 
      } 
    }
  }
  
  for (i in seq_along(nm)) {
    if (is.null(nm[[i]])) {
      if (names(nm)[i] == "varName") {
          varName_opts <- unique(c(unlist(lapply(lapply(flmd_dd.ls, "[[", "flmd"), function(x) lapply(x, "[[", "varName"))),
            flmd$varName))
          nm[[i]] <- menu.fx(opt = varName_opts)
      } else {
        if (append) {
          nm[[i]] <- menu.fx() 
        } else {
          nm[[i]] <- readline(prompt = paste0(names(flmd)[i], "? ")) 
        }
      }
    }
  }
  
  
  # append new row
  new_row <- as.data.frame(as.list(nm), stringsAsFactors = FALSE)
    
  # check for mismatches
  if (!all(names(flmd) %in% names(new_row))) {
    stop("Some flmd columns are missing from nm: ",
         paste(setdiff(names(flmd), names(new_row)), collapse = ", "))
  }
  if (any(!names(new_row) %in% names(flmd))) {
    warning("Extra fields in nm not present in flmd: ",
            paste(setdiff(names(new_row), names(flmd)), collapse = ", "))
  }
  
  # only recognized cols in flmd, ordered
  new_row <- new_row[, names(flmd), drop = FALSE]

  # if flmd is empty, just use new_row; else bind it
  if (nrow(flmd) == 0) {
    flmd <- new_row
  } else {
    flmd <- rbind(flmd, new_row)
  }

  if (write_out) {
    if (rename) {
      write.csv(flmd,
                file = file.path(META_DIR, paste0(expName, "_flmd.csv")),
                row.names = FALSE)
    } else {
      write.csv(flmd, file = flmdName, row.names = FALSE)
    }
  } else {
    flmd
  }
}

# input function
inputDat.fx <- function(expName, path.dat.csv, path.dd.csv, append.flmd, ...) {
  
  # define allowable cols
  allowable_cols <- c("date", "depth", "depth_lower", "depth_upper", "variable", "variance", "replicates", "plt_name")
  
  # read raw data files
  dat <- read.csv(path.dat.csv, strip.white = TRUE, check.names = FALSE, as.is = TRUE)
  dd <- read.csv(path.dd.csv, strip.white = TRUE, check.names = FALSE, as.is = TRUE)
  
  # check data orientation
  hzn.vrt <- menu(
    c("horizontal", "vertical"), 
    title = paste0("How are data oriented? i.e., are data oriented in rows (horizontal), e.g., ID column/s with subsequent measurement columns, or in columns (vertical), e.g., each column represents data from a different sensor, different depths, or plot?"))
  # if (hzn.vrt == "vertical") {
  #   
  # }
    
  # function to get and validate indices
  get_valid_indices <- function(df, colType) {
    
    # print indices
    cat(paste0(1:length(names(df)), ": ", names(df)), sep = "\n")
    
    while (TRUE) {
     
       # Prompt the user to enter row indices or 'cancel'
      cat(paste0("Specify ", "'", colType, "'", " column/s by index # (comma separated) or enter '0' to cancel: "))
      input <- readline()
      
      # Check if the user wants to cancel
      if (input == '0') {
        return(NULL)
      }
      
      # Try to convert input to numeric
      ix.in <- unlist(strsplit(input, ","))
      ix.cln <- sapply(ix.in, grepl, pattern = ":")
      ix.csv <- as.numeric(ix.in[which(!ix.cln)])
      
      if(any(ix.cln)) {
          ix.rng <- unlist(lapply(sapply(
            ix.in[which(ix.cln)], strsplit, ":"), function(x) {
              seq(x[1], x[2])
            }), use.names = FALSE)
          ix <- c(ix.csv, ix.rng)
        } else {
          ix <- ix.csv
        }
      
      # Check if the indices are valid
      if (all(!is.na(ix)) && all(ix >= 1) && all(ix <= ncol(df))) {
        return(ix)
      } else {
        cat("Error: Invalid indices. Please ensure the indices are numeric and within the range (1 to ", ncol(df), ").\n")
      }
    }
  }
  
  # get flmd_dd.ls
  flmd_dd.ls <- getFLMD_DD()
  
  # print columns names & prompt for req. col indices
  ## data col/s
  ix.dat <- get_valid_indices(dat, "data")
  dat.nms.in <- names(dat)[ix.dat]
  dat.nms <- vector(mode = "list", length = length(dat.nms.in))
  for (i in seq_along(dat.nms)) {
    varName_opts <- unique(unlist(lapply(lapply(flmd_dd.ls, "[[", "flmd"), function(x) lapply(x, "[[", "varName"))))
    sel <- menu(varName_opts, title = paste0("Does the data in column '", dat.nms.in[i], "' match one of the following variable names? (Enter '0' if none are appropriate)"))
      if (sel != 0) {
        dat.nms[i] <- varName_opts[sel]
      } else {
        dat.nms[i] <- readline(prompt = paste0("Please describe the variable in data column ", dat.nms.in[i], "\n")) 
      } 
  }
  
  ## depth
  ix.dpt <- get_valid_indices(dat, "depth/height")
  if (!is.null(ix.dpt)) {
    dpt.nms <- names(dat)[ix.dpt] 
    
    ### check for values entered as ranges
    if (any(suppressWarnings(is.na(as.numeric(dat[[ix.dpt]]))))) {
      ix <- menu(c("yes", "no"), title = paste0("\nNon-numeric values detected in column/s '", dpt.nms, "'. Are values entered as ranges, e.g., '0-10' or '10-20 cm', etc.?"))
    if (ix == 1) {
      if (length(ix.dpt) > 1) {
        warning("\nRanges not allowed with more than one depth column\n")
      }
      # Keep only digits and decimal points
      cleaned_string <- gsub("[^0-9.-]", "", dat[[ix.dpt]]) 
      
      # Split the cleaned string by hyphen and convert to numeric
      numbers <- lapply(strsplit(cleaned_string, "-"), as.numeric)
      
      # bind upper & lower depths to dat
      dat <- cbind(dat, depth_upper = sapply(numbers, min), depth_lower = sapply(numbers, max))
      ix.dpt <- c(ncol(dat)-1, ncol(dat))
      dpt.nms <- names(dat)[ix.dpt]
      } else {
      warning(paste0("\nPlease fix non-numeric values in depth column/s ", dpt.nms, "\n"))
      }
    }
  }
  
  # check for summarized data (means/var)
  ix <- menu(
      c("yes", "no"), 
      title = paste0("Do any columns contain replicates or variance estimates (standard deviation, coefficient of variation, standard error, confidence interval)?"))
  if (ix == 1) {
    ix.rep <- get_valid_indices(dat, "replicates")
    if (length(ix.rep) > 1) {
      cat("\nOnly one replicate column is permitted\n")
    }
    ix.var <- get_valid_indices(dat, "variance")
    vcl.nms <- names(dat)[ix.var]
    vcl.dat.nms <- setNames(vector(mode = "list", length = length(ix.var)), nm = vcl.nms)
    dat.nms <- names(dat[ix.dat[which(!(ix.dat %in% ix.var))]])
    for (i in seq_along(vcl.nms)) {
      ix <- menu(
        dat.nms,
        title = cat("\nWhich data column corresponds to variance column '", vcl.nms[i], "'?"))
      vcl.dat.nms[[i]] <- dat.nms[ix]
    }
  }

  # get date/time col
  ix.tim <- which(dd$dataType == "date")
  if (length(ix.tim) > 1) {
    cat("Data dictionary (dd) file denotes more than one columns with dataType = 'date' \n but only one is allowed. Please update data and dd files\n")
  } else {
    ix <- menu(
      c("yes", "no"), 
      title = paste0("Is '", dd$colName[ix.tim], "' the primary date/time column?"))
    if (ix != 1) {
      cat("\nPlease check data and data dictionary files\n")
    }
  }
  
  # check for database object
  if (!exists("database")) {
    database <- tryCatch(coreData.fx(verbose = FALSE))
  }
  
   # get plt_name column
  ix.plt <- which(names(dat) == "plt_name")
  if (length(ix.plt) == 0) {
    cat("Required column 'plt_name' missing from data file\n")
     ix <- menu(
      c("plot", "site"), 
      title = paste0("Were these data collected at the site or plot level?"))
    if (ix == 1) {
      cat("\nColumn 'plt_name' not detected in input data. We can try to match the plot names entered in the 'plot' table with a unique combination of identifying columns in the input data.\n")
      iix <- menu(c("yes", "no"), title = "\nDo you want to try this?\n")
      if (iix == 1) {
        ix.plt <- get_valid_indices(dat, "unique plot identifier")
        plt.nms <- names(dat)[ix.plt]
        for (i in seq_along(plt.nms)) {
          j <- menu(names(database[[expName]]$plot), cat(paste0("\nWhich plot table column matches input data column '", plt.nms[i], "'?\n")))
          plt.vls <- database[[expName]]$plot[[j]]
          dat.vls <- unlist(dat[ix.plt[i]])
          mch <- unique(dat.vls) %in% unique(plt.vls)
          if (!all(mch)) {
            cat("\nPlease check input data column '", plt.nms[i], "'. Value/s '",  unique(dat.vls)[which(!mch)], "' do not match values entered in plot table column '", plt.nms[i], "'.\n")
          }
        }
      }
      cat("\nPlease ensure column 'plt_name' is present in data and data dictionary files\n")
      return(NULL)
    } else {
      ix.plt <- NULL
    }
  }
  
  # check plt_names against plot table
  plt.nms <- unlist(unique(dat[ix.plt])) %in% database[[expName]]$plot$plt_name
  if (any(!plt.nms)) {
    cat("\nThe following plt_name values do not match entries in the plot: ", unlist(unique(dat[ix.plt]), use.names = FALSE)[which(!plt.nms)], "\nAllowable values: ", database[[expName]]$plot$plt_name)
  }
  
  # define data and metadata directories
  DATA_DIR <- path.expand(file.path("~/eco-warm/data/experiments", expName, "input_data"))
  META_DIR <- path.expand(file.path("~/eco-warm/data/experiments", expName, "meta"))
  
  # create data files
  dat.ls <- setNames(lapply(seq_along(dat.nms), function(i) {
    dat.i <- match(dat.nms.in[i], names(dat))
    ix <- c(ix.tim, ix.plt, ix.dpt, dat.i)
    if (exists("vcl.dat.nms")) {
      var.i <- match(names(vcl.dat.nms)[match(dat.nms[i], unlist(vcl.dat.nms))], names(dat)) 
      ix <- c(ix, var.i)
    }
    dat[ , na.omit(ix)] 
  }), nm = dat.nms)
  for (i in seq_along(dat.ls)) {
    nm <- paste0(names(dat.ls[i]), ".csv")
    if (any(grepl(nm, list.files(file.path(DATA_DIR))))) {
      nm <- paste0(readline(prompt = paste0("Duplicate file name detected. Please supply an alternative name for the ", names(dat.ls[i]), " data file", "\n")), ".csv") 
    }
    write.csv(
      dat.ls[[i]],
      file = file.path(DATA_DIR, nm),
      row.names = FALSE
    )
  }

  # create dd files
  dd.ls <- setNames(lapply(seq_along(dat.ls), function(i) {
    dd[match(names(dat.ls[[i]]), dd$colName), ]
  }), nm = paste0(names(dat.ls), "_dd"))
  for (i in seq_along(dd.ls)) {
    nm <- paste0(names(dd.ls[i]), ".csv")
    if (any(grepl(nm, list.files(file.path(META_DIR))))) {
      nm <- paste0(readline(prompt = paste0("Duplicate file name detected. Please supply an alternative name for the ", names(dat.ls[i]), " dd file", "\n")), ".csv") 
    }
    write.csv(
      dd.ls[[i]],
      file = file.path(META_DIR, nm),
      row.names = FALSE
    )
  }
  
  # update flmd
  if (append.flmd) {
    lapply(seq_along(dat.ls), function(i) {
      flmd_helper(
        expName = expName,
        dataFileName = names(dat.ls[i]),
        dateColName = names(dat[ix.tim]),
        append = append.flmd, 
        write_out = TRUE, ...)
   })
  }
}
```

# Metadata

```{r read-meta-files}
exp_names <- list.files(path.expand("~/eco-warm/data/experiments")) 
TIMESTAMP <- format(Sys.time(), "%y%m%d-%H%M") 
outfile <- file.path(paste0("../data/sweddie/database/logs/metaLog_", TIMESTAMP, ".txt"))
invisible(file.create(outfile))

# Start writing in the output file
vcat("SWEDDIE Metadata Log \n",
     "\n", as.character(Sys.time()),
     "\n", rep("-", 15), "\n", file = outfile, append = TRUE)
flmd_dd.ls <- lapply(
  lapply(exp_names, read_meta, write_report = TRUE, append = TRUE,
         file = outfile), function(x) {
           if (length(x$flmd) == 0) {
             NULL
           } else {
             x
           }
         })
names(flmd_dd.ls) <- exp_names
flmd_dd.ls <- Filter(Negate(is.null), flmd_dd.ls)
```

```{r write-flmd, eval=FALSE}
# get flmd_dd.ls
flmd_dd.ls <- getFLMD_DD()

# flatten to a list of data frames
flmd.ls <- lapply(lapply(flmd_dd.ls, "[[", "flmd"), function(x) {
  if (!is.data.frame(x)) {
    bind_rows(x)
  }
})

# canonical names
col_names <- c("expName", "sitName", "fileName", "varName",	"description", "UTC_offset", "fileVersionNumber", "startDate", "endDate",	"missingValCodes", "notes")

# normalization function
nmNorm.fx <- function(x) {
  tolower(gsub("_", "", x))
}

# regularize dfs
dfs_aligned <- mapply(function(df, nm) {
  
  # build a name map: normalized input → canonical col name
  norm_target <- nmNorm.fx(col_names)
  names(norm_target) <- col_names
  
  norm_current <- nmNorm.fx(names(df))
  
  # match each desired col to the closest one in df
  matched <- vapply(norm_target, function(nt) {
    match(nt, norm_current)
  }, integer(1))
  
  # create aligned df
  out <- as.data.frame(matrix(NA, nrow = nrow(df), ncol = length(col_names)))
  names(out) <- col_names
  
  for (i in seq_along(col_names)) {
    j <- matched[i]
    if (!is.na(j)) {
      out[[i]] <- df[[j]]
    }
  }
  
  out$expName <- nm  # add list name
  out
}, flmd.ls, names(flmd.ls), SIMPLIFY = FALSE) 

flmd.df <- do.call(rbind, dfs_aligned)

write.csv(flmd.df, "./data/flmd.csv", row.names = FALSE)
```

```{r periodicity-fx, eval=FALSE}
# need to vet this, also, need to first filter by depth and treatment...I guess could filter to a single plot as a proxy?
# periodicity fx from CGPT
check_periodicity <- function(df_all, varName, 
                              data_root = "../data/experiments", 
                              dateCol = "date") {
  # filter to varName
  subset_df <- df_all[df_all$varName == varName, ]
  
  if (nrow(subset_df) == 0) {
    stop("No matching records found for varName = ", varName)
  }
  
  results <- lapply(seq_len(nrow(subset_df)), function(i) {
    expName  <- subset_df$expName[i]
    fileName <- subset_df$fileName[i]
    filePath <- file.path(data_root, expName, "input_data", paste0(fileName, ".csv"))
    
    if (!file.exists(filePath)) {
      stop("File not found: ", filePath)
    }
    
    dat <- tryCatch(read.csv(filePath, stringsAsFactors = FALSE),
                    error = function(e) stop("Error reading file: ", filePath))
    
    # Check for date column
    if (!(dateCol %in% names(dat))) {
      cat("\n--- Missing expected date column in file:", filePath, "\n")
      cat("Available columns:\n")
      print(names(dat))
      cat("First row of data:\n")
      print(dat[1, , drop = FALSE])
      
      # prompt user
      newCol <- readline(prompt = "Please enter the correct column name for the date/time: ")
      if (!(newCol %in% names(dat))) {
        stop("You entered '", newCol, "', which is not in the data. Aborting.")
      }
      dateCol <- newCol
    }
    
    # Convert to POSIXct and order
    dat[[dateCol]] <- as.POSIXct(dat[[dateCol]], tz = "UTC")
    dat <- dat[order(dat[[dateCol]]), ]
    
    # Remove duplicate timestamps
    dat <- dat[!duplicated(dat[[dateCol]]), ]
    
    # Run periodicity
    idx <- dat[[dateCol]]
    freq <- tryCatch({
      ts::periodicity(idx)
    }, error = function(e) e$message)
    
    data.frame(
      expName = expName,
      fileName = fileName,
      varName = varName,
      periodicity = if (is.list(freq)) freq$scale else NA,
      frequency = if (is.list(freq)) freq$frequency else NA,
      diff_mean = mean(diff(as.numeric(idx)), na.rm = TRUE),
      stringsAsFactors = FALSE
    )
  })
  
  do.call(rbind, results)
}

test <- check_periodicity(flmd.df, "soil CO2")
```

# Sites
## 185ExperimentStation

```{r 185ExpSt-data-cleaning}
# fix date issue and separate soil temp & moisture data
tempMoist185 <- read.csv("../data/experiments/185ExperimentStation/raw/rererereresoilwarmingsynthesisfollowup/datafile.CSV", as.is = TRUE, strip.white = TRUE, check.names = FALSE)
tempMoist185$Date <- ymd_hm(tempMoist185$date)

# find bad dates
which(temp185$Date > "2024-07-04 18:00:00 UTC")

# remove, and simplify files
temp185 <- tempMoist185[c(1:261236, 261254:nrow(tempMoist185)), names(tempMoist185)[c(1:2, 5, 8:9)]]
smoist185 <- tempMoist185[c(1:261236, 261254:nrow(tempMoist185)), names(tempMoist185)[c(1:2, 5, 7, 9)]]
write.csv(temp185, "../data/experiments/185ExperimentStation/input_data/datafile_soilT.csv")
write.csv(smoist185, "../data/experiments/185ExperimentStation/input_data/datafile_soilW.csv")

dat.dir <- "../data/experiments/185ExperimentStation/input_data"
dat.dir.ls <- list.files(dat.dir)
lapply(dat.dir.ls, function(i)
  flmd_helper(
    expName = "185ExperimentStation",
    dataFileName = sub(".csv", "", dat.dir.ls[i]),
    dateColName = "Date",
    orders = c("%m/%d%y %H:%M", "%m/%d/%y", "Y"),
    append = TRUE,
    Jeff = TRUE))
```

## ACBB

```{r pivot-ACBB}
temp_C <- read.csv("../data/experiments/ACBB/input_data/soil_temp_cropland.csv")
temp_C$T1_Temp5 <- as.numeric(temp_C$T1_Temp5)
temp_G <- read.csv("../data/experiments/ACBB/input_data/soil_temp_grassland.csv")
moist_C <- read.csv("../data/experiments/ACBB/input_data/soil_water_cropland.csv")
moist_G <- read.csv("../data/experiments/ACBB/input_data/soil_water_grassland.csv")

moist_C <- read_excel("../data/experiments/ACBB/raw/Temp_moisture/Water/soil_water_cropland.xlsx")

ACBB_dat.ls <- list(temp_C = temp_C, temp_G = temp_G, moist_C = moist_C, moist_G = moist_G)
ACBB_dat_rnm.ls <- setNames(lapply(seq_along(ACBB_dat.ls), function(i) {
    dat <- ACBB_dat.ls[[i]]
    v.nms <- names(dat)[2:ncol(dat)]
    dpt <- ifelse(
      grepl("Temp", v.nms), 
      gsub("Temp", "", sapply(strsplit(v.nms, "_"), "[[", 2)), 
      sapply(strsplit(v.nms, "_"), "[[", 3))
    trt <- substr(v.nms, 1, 1)
    plt <- substr(v.nms, 2, 2)
    names(dat)[2:ncol(dat)] <- paste(trt, plt, dpt, sep = "_")
    dat
}), nm = names(ACBB_dat.ls))

pl.ACBB.fx <- function(ACBB_dat, type) {
  pivot_longer(
    ACBB_dat,
    cols = 2:ncol(ACBB_dat),
    names_to = c("treat", "plot", "depth"),
    names_sep = "_",
    values_to = "data")
}
ACBB_dat.hz.ls <- lapply(ACBB_dat_rnm.ls, pl.ACBB.fx)
lapply(seq_along(ACBB_dat.hz.ls), function(i) write.csv(ACBB_dat.hz.ls[[i]], file = paste0("../data/experiments/ACBB/input_data/", names(ACBB_dat.hz.ls[i]), ".csv"), row.names = FALSE))

# create dd files for temp & moist data
for (i in seq_along(ACBB_dat.hz.ls)) {
  dd_helper(expName = "ACBB", dataName = names(ACBB_dat.hz.ls)[i])
}

dat.dir <- "../data/experiments/ACBB/input_data"
dat.dir.ls <- setNames(sub(".csv", "", list.files(dat.dir)), nm = sub(".csv", "", list.files(dat.dir)))

inputDat.fx("ACBB", "../data/experiments/ACBB/derived/initialBulkSoilProperties.csv", "../data/experiments/ACBB/derived/initialBulkSoilProperties_dd.csv", append.flmd = TRUE, Jeff = TRUE)

lapply(seq_along(dat.dir.ls[c(14:15, 21:22)]), function(i)
  flmd_helper(
      expName = "ACBB",
      dataFileName = names(dat.dir.ls[c(14:15, 21:22)])[i],
      dateColName = "TIMESTAMP",
      orders = "%m/%d/%y H:M",
      append = TRUE, 
      write_out = TRUE, Jeff = TRUE)
  )
flmd_helper(
      expName = "ACBB",
      dataFileName = "SOC_2022",
      dateColName = "Year",
      orders = "y",
      append = TRUE, 
      write_out = TRUE, Jeff = TRUE)
```

## Achenkirch

```{r ach-processing}
# read raw data
raw <- read.csv("../data/experiments/Achenkirch/raw/Data_Achenkirch_Deepsoil_2100_1.csv")

# fix spelling of exp_name 
raw$exp_name <- "Achenkirch"

# create list for splitting data by variable
raw.ls <- setNames(vector(mode = "list", length = 9), nm = names(raw)[c(5, 7:14)])
raw.dat.ls <- setNames(lapply(seq_along(raw.ls), function(i) {
  raw.ls[[i]] <- raw[ , c("exp_name", "sit_name", "plt_name", "plt_block", "date", names(raw.ls[i]))]
}), nm = names(raw)[c(5, 7:14)])

# add depth for soil moisture
raw.dat.ls$soil_moist_manual..Vol..$depth <- 7.5

raw.dat.ls$soilTemp <- merge(
  raw.dat.ls$soil.temp.logger.5cm...C., 
  raw.dat.ls$soil.temp.logger.15cm...C.) %>%
  pivot_longer(
    cols = c("soil.temp.logger.5cm...C.", "soil.temp.logger.15cm...C."),
    names_to = "depth",
    names_pattern = "([0-9]+).*$",
    values_to = "soilTemp")
raw.dat.ls$soil.temp.logger.5cm...C. <- NULL
raw.dat.ls$soil.temp.logger.15cm...C. <- NULL

nm.ls <- lapply(seq_along(raw.dat.ls), function(i) paste0(names(raw.dat.ls[i]), ".csv"))
lapply(seq_along(nm.ls), function(i) {
  pth <- "../data/experiments/Achenkirch/input_data/"
  write.csv(x = raw.dat.ls[[i]], file = paste0(pth, nm.ls[[i]]), row.names = FALSE)
})

# write dd files
ach.inDat.pth.ls <- list.files("../data/experiments/Achenkirch/input_data", full.names = TRUE)
lapply(seq_along(ach.inDat.pth.ls), function(i) {
  nm <- sapply(strsplit(basename(ach.inDat.pth.ls[i]), ".csv"), "[[", 1)
  dd_helper("Achenkirch", nm)
})
names(raw.dat.ls) <- lapply(seq_along(ach.inDat.pth.ls), function(i) {
  sapply(strsplit(basename(ach.inDat.pth.ls[i]), ".csv"), "[[", 1)
})

flmd_helper(
  expName = "Achenkirch",
  dataFileName = "air_temp...C.",
  dateColName = "date",
  append = FALSE, 
  write_out = TRUE,
  Jeff = TRUE)

lapply(seq_along(ach.inDat.pth.ls[2:length(ach.inDat.pth.ls)]), function(i) {
  nm <- sapply(strsplit(basename(ach.inDat.pth.ls[2:length(ach.inDat.pth.ls)][i]), ".csv"), "[[", 1)
  cat(paste0("\n", nm, "\n"))
  flmd_helper(
    expName = "Achenkirch", 
    dataFileName = nm, 
    dateColName = "date",
    append = TRUE, write_out = TRUE,
    Jeff = TRUE)
})
```

## B4WarmED
```{r B4W}
# heating schedule
heatON.b4w <- read.csv("../data/experiments/B4WarmED/raw/heatON.csv")
heatON.b4w <- rbind(
  heatON.b4w,
  data.frame(
    year = rep(c(2008:2012, 2023), ea = 2),
    sit_name = rep(c("Cloquet", "Ely"), 6), 
    date_on = c(
      "2008-04-30", "2008-05-02",
      "2009-04-30", "2009-05-02",
      "2010-04-30", "2010-05-02",
      "2011-04-30", "2011-05-02", 
      "2012-04-29", "2012-05-01", 
      "2023-04-30", "2012-05-02"),
    jDay_on = rep(c(119, 121), 6),
    date_off = c(
      "2008-04-30", "2008-05-02",
      "2009-10-22", "2009-10-22",
      "2010-10-22", "2010-10-22",
      "2011-10-22", "2011-10-22",
      "2012-10-21", "2012-10-21", 
      "2023-10-22", "2023-10-22"),
    jDay_off = rep(c(294, 294), 6))
)

heatON.fx <- function(heat_schd, data) {
  heat.ls <- lapply(split(heat_schd, heat_schd$sit_name), function(x) split(x, x$year))
  dat.ls <- lapply(split(data, data$sit_name), function(x) {
    x$year <- year(x$date)
    split(x, x$year)
  })
  setNames(lapply(seq_along(dat.ls), function(i) {
    bind_rows(lapply(seq_along(dat.ls[[i]]), function(j) {
      ht <- heat.ls[[i]][names(heat.ls[[i]]) %in% names(dat.ls[[i]])]
      on.df <- ht[[j]]
      df <- dat.ls[[i]][[j]] 
      df %>%
        filter(date > as.Date(on.df$date_on, format = "%Y-%m-%d") & date < as.Date(on.df$date_off, format = "%Y-%m-%d"))
    }))
  }), nm = names(heat.ls))
}


# soil moisture
B4W.sm.raw <- read.csv("../data/experiments/B4WarmED/raw/B4WarmED_2009-2023_SoilMoisture.csv")
B4W.sm <- B4W.sm.raw %>%
  filter(!is.na(soil_moisture__cm.3H2Oxcm..3soil)) %>%
  mutate(
    site = ifelse(site == "cfc", "Cloquet", "Ely"),
    date = ymd_hms(timeStamp_AmericaRegina),
    plt_name = paste(
      site, plot, ifelse(water_treatment == "excluded", 2, 1), ifelse(warming_treatment == "disturbed_ambient" | warming_treatment == "ambient", 0, warming_treatment), sep = "_"),
    depth = 20) %>%
  rename(sit_name = site, vwc = soil_moisture__cm.3H2Oxcm..3soil)

# print unique plot names
B4W.sm %>% 
  distinct(plt_name, .keep_all = TRUE) %>%
  select(sit_name, plt_name, block, canopy, warming_treatment, water_treatment) %>%
  write.csv(., file = "/Users/jbeemmil@umich.edu/eco-warm/data/experiments/B4WarmED/derived/plt_name.csv", row.names = FALSE)

# filter to heating period
B4W.sm.on <- heatON.fx(heatON.b4w, B4W.sm)

write.csv(
  B4W.sm.on$Cloquet, 
  file = "../data/experiments/B4WarmED/input_data/clq_soilMoisture_2012.2023.csv",
  row.names = FALSE)
write.csv(
  B4W.sm.on$Ely, 
  file = "../data/experiments/B4WarmED/input_data/ely_soilMoisture_2012.2023.csv",
  row.names = FALSE)

# soil temp
## deep
B4W.st.deep60.raw <- read.csv("../data/experiments/B4WarmED/raw/dat_B4W_2013-2022_60min_DeepSoilTemp_WarmingIsONupdated.csv")
B4W.st.2008.2010.15m <- read.csv("../data/experiments/B4WarmED/input_data/dat_B4W_2008-2010_15min_DeepSoilTemp.csv")
B4W.st.2011.2012.30m <- read.csv("../data/experiments/B4WarmED/input_data/dat_B4W_2011_2012_30min_DeepSoilTemp.csv")
# not using for now
B4W.st.2012.15m <- read.csv("../data/experiments/B4WarmED/input_data/dat_B4W_2012_15min_DeepSoilTemp.csv")
B4W.st.2008.2022 <- rbind(
    B4W.st.2008.2010.15m,
    B4W.st.2011.2012.30m) %>%
    mutate(rain_trt = "AmbRain") %>%
    rbind(., B4W.st.deep60.raw) %>%
    mutate(date = ymd_hms(TIMESTAMP))


## 10cm
B4W.st.10cm.raw <- read.csv("../data/experiments/B4WarmED/raw/regularTop10cmSoilTempForJeffFor_2009-2023.csv")
B4W.st.10cm.cln <- B4W.st.10cm.raw %>%
  filter(!is.na(warmingIsON)) %>%
  filter(warmingIsON == 1)

# get plot names
b4w.plt <- database$B4WarmED$plot
b4w.plt$pname <- regmatches(
  b4w.plt$plt_name,
  regexpr("(?<=_)[A-Za-z0-9]{2}", b4w.plt$plt_name, perl = TRUE)
)
B4W.st.10cm.cln$plt_name <- b4w.plt[match(B4W.st.10cm.cln$plot, b4w.plt$pname), "plt_name"]

# # filter out warming OFF dates from soil moisture data
# B4W.sm.ht <- left_join(
#   B4W.sm %>%
#     mutate(day = as.Date(date, format = "%Y-%m-%d")),
#   B4W.st.2008.2012 %>%
#     filter(warmingIsON == 1) %>%
#     mutate(day = as.Date(date, format = "%Y-%m-%d"),
#            plot = tolower(plot),
#            sit_name = ifelse(site == "CFC", "Cloquet", "Ely")) %>%
#     group_by(sit_name, plot, day) %>%
#     summarize(warmingIsON = mean(warmingIsON), .groups = "drop") %>%
#     select(sit_name, plot, day, warmingIsON),
#   by = c("sit_name", "plot", "day")) %>%
#   filter(warmingIsON == 1) %>%
#   select(date, sit_name, plt_name, depth, vwc)
#   


B4W.st <- B4W.st.2008.2022 %>%
  filter(!is.na(soilTempC)) %>%
  mutate(
    site = ifelse(site == "CFC", "Cloquet", "Ely"),
    date = ymd_hms(TIMESTAMP),
    plot = tolower(plot)) %>%
  rename(sit_name = site, depth = depthTemp.cm) %>%
  select(sit_name, date, plot, depth, soilTempC)
B4W.st$plt_name <- b4w.plt[match(B4W.st$plot, b4w.plt$pname), "plt_name"]
B4W.st$plot <- NULL

B4W.st <- rbind(
    B4W.st, 
    B4W.st.10cm.cln %>% 
      mutate(date = ymd_hms(TIMESTAMP),
             depth = 10,
             sit_name = ifelse(grepl("Cloquet", plt_name), "Cloquet", "Ely")) %>%
      rename(soilTempC = Below_temp_C) %>%
      select(sit_name, date, plt_name, depth, soilTempC))

# filter to heating period
B4W.st.on <- heatON.fx(heatON.b4w, B4W.st)

write.csv(
  B4W.st.on$Cloquet, 
  file = "../data/experiments/B4WarmED/input_data/clq_soilTemp_2013.2022.csv",
  row.names = FALSE)
write.csv(
  B4W.st.on$Ely, 
  file = "../data/experiments/B4WarmED/input_data/ely_soilTemp_2013.2022.csv",
  row.names = FALSE)

rm(heatON.b4w, B4W.sm.raw, B4W.sm, B4W.sm.on, B4W.st.deep60.raw, B4W.st.2008.2010.15m, B4W.st.2011.2012.30m, B4W.st.10cm.raw, B4W.st.2012.15m, B4W.st.2008.2022, B4W.st, B4W.st.on, B4W.st.10cm.cln)
```

## Blodgett
### ESS-DIVE data

```{r Blodgett-dat}
# read file
b_test <- read_ess.dive.fx("Blodgett")
```

### temp & moist data

```{r Blodgett-dat}
# read data files, save as uncompressed RDS for fast loading
moistBlg <- read.csv("../data/raw/Blodgett/tempMoist/20240125_processed Blodgett soil moisture.csv", na.strings = "NAN")
saveRDS(moistBlg, "../data/raw/Blodgett/tempMoist/rds/20240125_processed Blodgett soil moisture.rds", compress = FALSE)
tempBlg <- read.csv("../data/experiments/Blodgett/input_data/20240125_processed Blodgett soil temperature.csv", na.strings = "NAN")
saveRDS(tempBlg, "../data/raw/Blodgett/tempMoist/rds/20240125_processed Blodgett soil temperature.rds", compress = FALSE)

# read in RDS
tempBlg <- readRDS("../data/raw/Blodgett/tempMoist/rds/20240125_processed Blodgett soil temperature.rds")
moistBlg <- readRDS("../data/raw/Blodgett/tempMoist/rds/20240125_processed Blodgett soil moisture.rds")
```

Notes on temp & moisture data
- soil temp & moisture measured at different depths
  - temp: 5, 15, 20, 30, 50, 70, 75, 100, 120, 140
  - moist: 10, 30, 50 90
- only 30, 50 in common
- aggregate to moisture depths for consistency

```{r T-M-blg-ter}
# aggregate data by date
tempBlg2 <- tempBlg
moistBlg2 <- moistBlg
tempBlg2$timestamp <- parse_date_time(tempBlg$TIMESTAMP, orders = "%Y-%m-%d %H-%M-%S")
moistBlg2$timestamp <- parse_date_time(moistBlg$TIMESTAMP, orders = "%Y-%m-%d %H-%M-%S")

# average by day
tempBlg2.d <- tempBlg2 %>% 
  mutate(date = date(timestamp),
         temp = as.numeric(temp)) %>%
  group_by(date, PP, depth, trt) %>% 
  summarize(mean.temp = mean(temp, na.rm = T), .groups = "drop") %>% 
  data.frame()

# spline to moisture depths
tempBlg2.d.sp <- bind_rows(lapply(split(tempBlg2.d, tempBlg2.d$date), function(x) {
  bind_rows(lapply(split(x, x$PP), function(y) {
    bind_rows(lapply(split(y, y$trt), function(z) {
      z <- z[order(z$depth), ]
      if (nrow(z) - length(which(is.na(z$mean.temp))) > 4) {
        sp <- spline(z$depth, z$mean.temp, method = "natural")
        ss <- smooth.spline(sp, lambda = .1, tol = 1e-4)
        sp.std <- predict(ss, c(10, 30, 50, 90))
        data.frame(depth = sp.std$x, mean.temp = sp.std$y)
      } else {
        NULL
      }
    }), .id = "trt")
  }), .id = "PP")
}), .id = "date")
tempBlg2.d.sp$date <- parse_date_time(tempBlg2.d.sp$date, orders = "%Y/%m/%d")

# average by day
moistBlg2.d <- moistBlg2 %>% 
  mutate(date = date(timestamp),
         moisture = as.numeric(moisture)) %>%
  group_by(date, PP, depth, trt) %>% 
  summarize(mean.moisture = mean(moisture, na.rm = T), .groups = "drop") %>% 
  data.frame()

# compare temp and moisture w/ depth
blg.t.m.d <- merge(
  tempBlg2.d.sp, 
  moistBlg2.d, 
  by = c("PP", "depth", "trt", "date"))
blg.t.m.d$dryWet <- ifelse(month(blg.t.m.d$date) > 10 | month(blg.t.m.d$date) < 4, "wet", "dry")
tm.blg.lm <- lm(mean.temp ~ mean.moisture, blg.t.m.d)
tmd.blg.lm <- lm(mean.temp ~ mean.moisture + depth, blg.t.m.d)
tmd2.blg.lm <- lm(mean.temp ~ mean.moisture * depth, blg.t.m.d)
tmdT.blg.lm <- lm(mean.temp ~ mean.moisture + depth + trt, blg.t.m.d)
tmdT2.blg.lm <- lm(mean.temp ~ mean.moisture * depth * trt, blg.t.m.d)
tmdT3.blg.lm <- lm(mean.temp ~ depth * trt * dryWet, blg.t.m.d)

# mixed model
m.m1 <- lmer(mean.moisture ~ depth * trt + (1 | PP), blg.t.m.d)

ggplot(blg.t.m.d, aes(mean.moisture, mean.temp, color = depth)) +
  geom_point() +
  facet_grid(cols = vars(trt)) +
  theme_bw() +
  theme(panel.grid = element_blank())

ggplot(blg.t.m.d, aes(mean.moisture, depth, color = trt)) +
  geom_jitter() +
  scale_color_manual(name = "", values = c("C" = "blue", "H" = "red")) +
  scale_y_reverse() +
  facet_grid(cols = vars(dryWet)) +
  theme_bw() +
  theme(panel.grid = element_blank())

blg.t.m.d %>% 
  group_by(trt, depth, dryWet) %>% 
  summarize(moist = mean(mean.moisture, na.rm = T), sd = sd(mean.moisture, na.rm = T), n = n()) %>%
  mutate(sem2 = 2 * (sd / sqrt(n))) %>%
  ggplot(., aes(depth, moist, fill = trt)) + 
  geom_col(position = "dodge") + 
  geom_errorbar(aes(ymin = moist - sem2, ymax = moist + sem2, color = trt), position = "dodge") +
  scale_fill_manual(values = c("H" = "#F8766D", "C" = "#00A9FF")) +
  scale_color_manual(values = c("H" = "#F8766D", "C" = "#00A9FF")) +
  facet_grid(cols = vars(dryWet)) + 
  theme_bw() + 
  theme(panel.grid = element_blank())

blg.t.m.d %>% 
  pivot_wider(id_cols = c(PP, depth, date, dryWet), names_from = trt, values_from = mean.moisture) %>%
  mutate(mDif = C - H) %>%
  group_by(depth, dryWet) %>% 
  summarize(mean.mDif = mean(mDif, na.rm = T), sd = sd(mDif, na.rm = T), n = n()) %>%
  mutate(sem2 = 2 * (sd / sqrt(n))) %>%
  ggplot(., aes(depth, mean.mDif, fill = dryWet)) + 
  geom_col(position = "dodge") + 
  geom_errorbar(
    aes(ymin = mean.mDif - sem2, ymax = mean.mDif + sem2, color = dryWet), position = "dodge") + 
  scale_fill_manual(values = c("dry" = "#CD9600", "wet" = "#00BE67")) +
  scale_color_manual(values = c("dry" = "#CD9600", "wet" = "#00BE67")) +
  theme_bw() + 
  theme(panel.grid = element_blank())
```

## CiPEHR
### temp & moist
```{r CiPEHR-dat}
# read data file
tmp_mstCpr2 <- read.csv("../data/experiments/CiPEHR/input_data/flux_hh.csv")
tmp_mstCpr2_nms <- names(read.csv("../data/experiments/CiPEHR/input_data/flux_hh.csv", nrows = 1))
```

```{r soil-dat}
dd_helper("CiPEHR", "EML_AK_CiPEHR_SoilProperties_2009-2017_Data_reform")
flmd_helper("CiPEHR", "EML_AK_CiPEHR_SoilProperties_2009-2017_Data_reform","year")
```

```{r convert-to-ts}
# explore ts
temp2 <- tmp_mstCpr2
temp2$ts <- parse_date_time(temp2$ts, orders = "%Y-%m-%d %H-%M-%S")

# add winter/summer distinction
## cf. Natali et al., 2011 DOY 288—105
temp2$sW <- ifelse(temp2$doy > 105 & temp2$doy < 288, "s", "w")

# aggregate
temp2.ls <- lapply(split(temp2, temp2$year), function(x) {
  x %>%
    select("ts", "doy", "year", "sW", "treatment", "t5f", "t10f", "t20f", "t40f") %>%
    pivot_longer(
      cols = c("t5f", "t10f", "t20f", "t40f"),
      names_to = "depth",
      names_pattern = "t(\\d+)f", 
      values_to = "soilT") %>%
    group_by(depth, treatment, sW, doy) %>%
    summarize(soilT = mean(soilT, na.rm = TRUE), .groups = "drop")
})

# plot
temp2.agg.df <- bind_rows(temp2.ls, .id = "year") %>% ungroup() %>% mutate(depth = as.numeric(depth))
temp2.agg.df %>%
  # filter(year == "2009") %>%
  ggplot(., aes(doy, soilT, color = treatment)) +
  geom_line() +
  facet_grid(rows = vars(depth), cols = vars(sW)) +
  theme_bw() +
  theme(panel.grid = element_blank())

## soil warming primarily effective during winter (as intended); used dates from 2009 season for all years; confirmed that air warming treatment not significant.

# note that day light savings time causes conversion issue! e.g., 3/10/2019 2:00 through 3/10/2019 2:45 should not exist
ix <- which(is.na(temp2$TIMESTAMP))

# plot
dmean.temp.long <- pivot_longer(temp2, cols = 7:26, names_to = "sensor_ID", values_to = "temp")
dmean.temp.long <- left_join(
  dmean.temp.long,
  metadata[ , c("sensor_ID", "sensor_type", "sensor_depth")], 
  by = c("sensor_ID"))
dmean.temp.long %>%
  filter()
  ggplot(., aes())

temp2 <- temp2[-ix, ]
temp.ts <- xts(temp2, temp2$TIMESTAMP)

# calculate daily mean for different sensors
dmean.temp <- apply.daily(temp.ts[ , 7:26], mean, na.rm = TRUE)


# duplicates?
ix <- which(!duplicated(temp2$TIMESTAMP))
plot(temp2$TIMESTAMP[ix], temp2$Temp_T_Avg.1.[ix])

iix <- which(duplicated(temp2$TIMESTAMP)) # all NA...
t1 <- which(duplicated(temp2$Temp_T_Avg.1.[iix]))
```


## DFWP

## FutureClim
```{r ftrClm-dat-processing}
# read in raw data
raw <- read.csv("../data/experiments/FutureClim/raw/2024.11.29_All_Blocks_Hourly_Averages.csv")

# fix timestamp issue w/ 00:00 (midnight) dropped 
raw$Timestamp <- ifelse(nchar(raw$Timestamp) < 11, paste(raw$Timestamp, "00:00"), raw$Timestamp)

# read in plot table
plt <- read.csv("../data/sweddie/siteData/FutureClim/plot.csv")

fc.vwc <- raw %>%
  select(Timestamp, Block, contains("VWC"))
fc.elc <- raw %>%
  select(Timestamp, Block, contains("EC"))
fc.tmp <- raw %>%
  select(Timestamp, Block, contains("Temp"))

raw.dat.ls <- list(
  VWC = fc.vwc,
  EC = fc.elc,
  Temp = fc.tmp)
raw.dat.p.ls <- setNames(lapply(seq_along(raw.dat.ls), function(i) {
  v <- names(raw.dat.ls[i])
  raw.dat.ls[[i]] %>%
    rename(plt_block = Block) %>%
    pivot_longer(
      cols = contains(v),
      names_to = "code",
      names_pattern = "([0-9]+).*$",
      values_to = v) %>%
      mutate(code = as.numeric(code),
             depth = ifelse(code %% 2 == 1, 10, 45),
             plt_heat_level = ifelse(code %in% c(1:2, 5:6), 0, 4),
             plt_treat_add_name = ifelse(code > 4, "drought", "")) %>%
    left_join(., plt, by = c("plt_block", "plt_heat_level", "plt_treat_add_name")) %>%
    select(exp_name, sit_name, plt_name, Timestamp, depth, v)
}), nm = names(raw.dat.ls))

nm.ls <- lapply(seq_along(raw.dat.p.ls), function(i) paste0(names(raw.dat.p.ls[i]), ".csv"))
lapply(seq_along(nm.ls), function(i) {
  pth <- "../data/experiments/FutureClim/input_data/"
  write.csv(x = raw.dat.p.ls[[i]], file = paste0(pth, nm.ls[[i]]), row.names = FALSE)
})
```

```{r ftcl-dd-flmd, eval = FALSE}
# write dd files
fcl.inDat.pth.ls <- list.files("../data/experiments/FutureClim/input_data", full.names = TRUE)
lapply(seq_along(fcl.inDat.pth.ls), function(i) {
  nm <- sapply(strsplit(basename(fcl.inDat.pth.ls[i]), ".csv"), "[[", 1)
  dd_helper("FutureClim", nm)
})

flmd_helper(
  expName = "FutureClim",
  dataFileName = "EC",
  dateColName = "Timestamp",
  append = FALSE, 
  write_out = TRUE,
  Jeff = TRUE)

lapply(seq_along(fcl.inDat.pth.ls[2:length(fcl.inDat.pth.ls)]), function(i) {
  nm <- sapply(strsplit(basename(fcl.inDat.pth.ls[2:length(fcl.inDat.pth.ls)][i]), ".csv"), "[[", 1)
  cat(paste0("\n", nm, "\n"))
  flmd_helper(
    expName = "FutureClim", 
    dataFileName = nm, 
    dateColName = "Timestamp",
    append = TRUE, write_out = TRUE,
    Jeff = TRUE)
})
```

## FORHOT

## GENX
Only soil temp data here, as it is a salt marsh

```{r}
inputDat.fx("GENX", "../data/experiments/GENX/raw/genx/2022_genx.csv", "../data/experiments/GENX/raw/genx/genx_dd.csv", append.flmd = FALSE, Jeff = TRUE)
flmd_helper("GENX", "soil temperature_22", "timestamp", append = FALSE, Jeff = TRUE)
inputDat.fx("GENX", "../data/experiments/GENX/raw/genx/2023_genx.csv", "../data/experiments/GENX/raw/genx/genx_dd.csv", append.flmd = TRUE, Jeff = TRUE)
```

## Harvard Forest
- NB: no deep soil data!!


## KAEFS
```{r KAEFS-reshape}
kaefs.t <- read.csv("../data/experiments/KAEFS/derived/temperature_200908_201802_daily_v.csv")
kaefs.t.l <- pivot_longer(
  kaefs.t, 
  cols = 5:ncol(kaefs.t), 
  names_to = c("plotID", "blockID", "warmingTreatment", "precipTreatment", "clippingTreatment", "depth_cm"),
  names_sep = "_", 
  values_to = "T")
write.csv(kaefs.t.l, file = "../data/experiments/KAEFS/data/temperature_200908_201802_daily_reshaped.csv", row.names = FALSE)

test <- read.csv("/Users/jbeemmil@umich.edu/eco-warm/data/experiments/KAEFS/input_data/SoilTemperature2Depth_2018-2023_reshape_long.csv")
kaefs.t2 <- read.csv("../data/experiments/KAEFS/derived/SoilTemperature2Depth_2008-2023_reshape.csv")
kaefs.t2.l <- kaefs.t2 %>%
  pivot_longer(
    cols = 2:ncol(kaefs.t2), 
    names_to = c("plotID", "depth_cm"),
    names_sep = "_", 
    values_to = "soilT") %>%
  mutate(plt_name = paste0("p", substr(plotID, 2, nchar(plotID))),
         depth = str_extract(depth_cm, "(\\d+)"),
         date = ymd(Timestamp)) %>%
  select(date, plt_name, depth, soilT) %>%
  na.exclude
write.csv(
  kaefs.t2.l, 
  file = "../data/experiments/KAEFS/input_data/SoilTemperature2Depth_2018-2023_reshape_long.csv",
  row.names = FALSE)
dd_helper("KAEFS", "SoilTemperature2Depth_2018-2023_reshape_long")
flmd_helper(
  expName = "KAEFS", 
  dataFileName = "SoilTemperature2Depth_2018-2023_reshape_long", 
  dateColName = "date",
  rename = TRUE, append = TRUE, write_out = TRUE,
  Jeff = TRUE,
  orders = "ymd")

# ANPP
kaefs.anpp <- read.csv("../data/experiments/KAEFS/derived/ANPP_2009_2023_reshaped.csv")
kaefs.anpp.l <- pivot_longer(
  kaefs.anpp,
  cols = 5:ncol(kaefs.anpp),
  names_to = c("vegType", "year"),
  names_sep = "_",
  values_to = "g_m2_y"
)
write.csv(kaefs.anpp.l, file = "../data/experiments/KAEFS/data/ANPP_2009_2023_reshapedLong.csv", row.names = FALSE)
dd_helper("KAEFS", "ANPP_2009_2023_reshapedLong")

# ANPP
kaefs.anpp <- read.csv("../data/experiments/KAEFS/derived/ANPP_2009_2023_reshaped.csv")
kaefs.anpp.l <- pivot_longer(
  kaefs.anpp,
  cols = 5:ncol(kaefs.anpp),
  names_to = c("vegType", "year"),
  names_sep = "_",
  values_to = "g_m2_y"
)
write.csv(kaefs.anpp.l, file = "../data/experiments/KAEFS/data/ANPP_2009_2023_reshapedLong.csv", row.names = FALSE)
dd_helper("KAEFS", "ANPP_2009_2023_reshapedLong")

# BNPP
kaefs.bnpp <- read.csv("../data/experiments/KAEFS/derived/BNPP10-13forJeff.csv")
kaefs.bnpp.l <- pivot_longer(
  kaefs.bnpp,
  cols = 5:ncol(kaefs.bnpp),
  names_to = c("year"),
  values_to = "g_m2_y"
) %>%
  mutate(year = as.numeric(sub("X", "", year)),
         subplotID = plotID,
         plotID = ifelse(grepl("S", plotID), sub("S", "", plotID), sub("N", "", plotID)))
write.csv(kaefs.bnpp.l, file = "../data/experiments/KAEFS/data/BNPP10-13_reshapedLong.csv", row.names = FALSE)
dd_helper("KAEFS", "BNPP10-13_reshapedLong")
flmd_helper(
  expName = "KAEFS", 
  dataFileName = "BNPP10-13_reshapedLong", 
  dateColName = "year",
  append = TRUE, write_out = TRUE,
  Jeff = TRUE)

# soil moisture
kaefs.moist <- read.csv("../data/experiments/KAEFS/derived/SoilMoisture2018-2023_reshape.csv")
kaefs.moist.l <- pivot_longer(
  kaefs.moist,
  cols = 2:ncol(kaefs.moist),
  names_to = c("plotID", "depth"),
  names_sep = "_",
  values_to = "vwc_pct"
)
write.csv(kaefs.moist.l, file = "../data/experiments/KAEFS/data/SoilMoisture2018-2023_reshapeLong.csv", row.names = FALSE)

flmd_helper(
  expName = "KAEFS", 
  dataFileName = "SoilMoisture2018-2023_reshapeLong", 
  dateColName = "Timestamp",
  rename = TRUE, append = TRUE, write_out = TRUE,
  Jeff = TRUE,
  orders = "%m-%d-%y")

dd_helper("KAEFS", "SoilMoisture2018-2023_reshapeLong")

dd_helper("KAEFS", "local_climate_data")
flmd_helper(
  expName = "KAEFS", 
  dataFileName = "local_climate_data", 
  dateColName = "TIME",
  rename = TRUE, append = TRUE, write_out = TRUE,
  Jeff = TRUE,
  orders = "%Y-%m-%d %H:%M")


```

## Lyon, HI


## MERIT

```{r merit-soilT}
st.20 <- read.csv("../data/experiments/MERIT/raw/merit/2020_merit.csv")
st.21 <- read.csv("../data/experiments/MERIT/raw/merit/2021_merit.csv")
st.22 <- read.csv("../data/experiments/MERIT/raw/merit/2022_merit.csv")
merit_soilT <- rbind(st.20, st.21, st.22)
merit_soilT$pin_temperature <- ifelse(is.na(merit_soilT$pin_temperature), merit_soilT$lag_temperature, merit_soilT$pin_temperature)
merit_soilT$lag_temperature <- ifelse(is.na(merit_soilT$lag_temperature), merit_soilT$pin_temperature, merit_soilT$lag_temperature)
merit_soilT$meanSoilT <- rowMeans(merit_soilT[ , c("pin_temperature", "lag_temperature")])
merit_soilT.l <- merit_soilT %>%
  select(timestamp, plt_name, waterlevel, meanSoilT, surface_temperature, air_temperature) %>%
  pivot_longer(cols = c(meanSoilT, surface_temperature), names_to = "depth", values_to = "soilT") %>%
  mutate(depth = ifelse(depth == "surface_temperature", .03, .25))
write.csv(merit_soilT.l[ , c("timestamp", "plt_name", "air_temperature")], "../data/experiments/MERIT/input_data/merit_airT.csv", row.names = FALSE)
write.csv(merit_soilT.l[ , c("timestamp", "plt_name", "waterlevel")], "../data/experiments/MERIT/input_data/merit_H2O_level.csv", row.names = FALSE)
write.csv(merit_soilT.l[ , c("timestamp", "plt_name", "depth", "soilT")], "../data/experiments/MERIT/input_data/merit_soilT.csv", row.names = FALSE)

# write dd files
mrt.inDat.pth.ls <- list.files("../data/experiments/MERIT/input_data", full.names = TRUE)
lapply(seq_along(mrt.inDat.pth.ls), function(i) {
  nm <- sapply(strsplit(basename(mrt.inDat.pth.ls[i]), ".csv"), "[[", 1)
  dd_helper("MERIT", nm)
})

flmd_helper(
  expName = "MERIT",
  dataFileName = "merit_airT",
  dateColName = "timestamp",
  append = FALSE, 
  write_out = TRUE,
  Jeff = TRUE)

lapply(seq_along(mrt.inDat.pth.ls[2:length(mrt.inDat.pth.ls)]), function(i) {
  nm <- sapply(strsplit(basename(mrt.inDat.pth.ls[2:length(mrt.inDat.pth.ls)][i]), ".csv"), "[[", 1)
  cat(paste0("\n", nm, "\n"))
  flmd_helper(
    expName = "MERIT", 
    dataFileName = nm, 
    dateColName = "timestamp",
    append = TRUE, write_out = TRUE,
    Jeff = TRUE)
})
```

## Sanming
```{r sanming-datIn}
sanm.st <- read.csv("../data/experiments/Sanming/raw/TRL_TEMP_2024.csv")
sanm.sm <- read.csv("../data/experiments/Sanming/raw/TRL_MOIS_2024.csv")

sanm.st %>%
  rename(plt_name = plot_id, depth = depth_cm) %>%
  write.csv(., file = "../data/experiments/Sanming/input_data/TRL_TEMP_2024.csv", row.names = FALSE)

sanm.sm %>%
  rename(plt_name = plot_id, depth = depth_cm) %>%
  write.csv(., file = "../data/experiments/Sanming/input_data/TRL_MOIS_2024.csv", row.names = FALSE)
```

## SMARTX
```{r smartx-soilT}
# get paths
smx.inDat.pth.ls <- list.files("../data/experiments/SMARTX/raw/datFiles", full.names = TRUE)
smartx.ls <- bind_rows(setNames(lapply(smx.inDat.pth.ls, read.csv), nm = sapply(strsplit(basename(smx.inDat.pth.ls), ".csv"), "[[", 1)))
smartx.df <- bind_rows(smartx.ls) %>% 
  rename(sit_name = site)
smartx.df$pintemp_avg <- ifelse(is.na(smartx.df$pintemp_avg), smartx.df$lagtemp_avg, smartx.df$pintemp_avg)
smartx.df$lagtemp_avg <- ifelse(is.na(smartx.df$lagtemp_avg), smartx.df$pintemp_avg, smartx.df$lagtemp_avg)
smartx.df$meanSoilT <- rowMeans(smartx.df[ , c("pintemp_avg", "lagtemp_avg")])
smartx.df.l <- smartx.df %>%
  pivot_longer(cols = c(meanSoilT, deeptemp_avg), names_to = "depth", values_to = "soilT") %>%
  mutate(depth = ifelse(depth == "deeptemp_avg", .9, .2)) %>%
  select(timestamp, sit_name, plt_name, depth, soilT, airtemp_avg, rh_avg, wind_speed_avg, wind_direction_avg, water_level)
write.csv(smartx.df.l[ , c("timestamp", "sit_name", "plt_name", "airtemp_avg")], "../data/experiments/SMARTX/input_data/airT.csv", row.names = FALSE)
write.csv(smartx.df.l[ , c("timestamp", "sit_name", "plt_name", "water_level")], "../data/experiments/SMARTX/input_data/H2O_level.csv", row.names = FALSE)
write.csv(smartx.df.l[ , c("timestamp", "sit_name", "plt_name", "depth", "soilT")], "../data/experiments/SMARTX/input_data/soilT.csv", row.names = FALSE)
write.csv(smartx.df.l[ , c("timestamp", "sit_name", "plt_name", "rh_avg", "wind_speed_avg", "wind_direction_avg")], "../data/experiments/SMARTX/input_data/climDat.csv", row.names = FALSE)

# write dd files
smx.inDat.pth.ls <- list.files("../data/experiments/SMARTX/input_data", full.names = TRUE)
lapply(seq_along(smx.inDat.pth.ls), function(i) {
  nm <- sapply(strsplit(basename(smx.inDat.pth.ls[i]), ".csv"), "[[", 1)
  dd_helper("SMARTX", nm)
})

flmd_helper(
  expName = "SMARTX",
  dataFileName = "airT",
  dateColName = "timestamp",
  append = FALSE, 
  write_out = TRUE,
  Jeff = TRUE)

lapply(seq_along(smx.inDat.pth.ls[2:length(smx.inDat.pth.ls)]), function(i) {
  nm <- sapply(strsplit(basename(smx.inDat.pth.ls[2:length(smx.inDat.pth.ls)][i]), ".csv"), "[[", 1)
  cat(paste0("\n", nm, "\n"))
  flmd_helper(
    expName = "SMARTX", 
    dataFileName = nm, 
    dateColName = "timestamp",
    append = TRUE, write_out = TRUE,
    Jeff = TRUE)
})
```

## SPRUCE


## SWAMP
```{r SWAMP-data-process}
# read in raw data from xlxs
raw.soil <- read_xlsx("../data/experiments/SWAMP/raw/SWAMP data.xlsx", sheet = "soildata", range = "A1:E133")
raw.clim <- read_xlsx("../data/experiments/SWAMP/raw/SWAMP data.xlsx", sheet = "precipitation and airtemperatur", range = "A1:C52609")
raw.smst <- read_xlsx("../data/experiments/SWAMP/raw/SWAMP data.xlsx", sheet = "volumetric soil moisture", range = "A1:J2191")
raw.stmp <- read_xlsx("../data/experiments/SWAMP/raw/SWAMP data.xlsx", sheet = "temperature", range = "A1:T2191")

# split depth col into upper & lower
raw.soil$depth_upper <- as.numeric(sapply(strsplit(raw.soil$depth, "-"), "[[", 1))
raw.soil$depth_lower <- as.numeric(gsub("cm", "", sapply(strsplit(raw.soil$depth, "-"), "[[", 2)))
raw.soil <- raw.soil %>%
  mutate(plt_name = ifelse(warming == "warming", paste0("heated", "_", substr(block, 2, 2)), paste0("control", "_", substr(block, 2, 2)))) %>%
  select(plt_name, depth_upper, depth_lower, `soil organic carbon`, `soil total nitrogen`)

# pivot soil T & M by depth & trt
smst.l <- raw.smst %>%
  pivot_longer(
    cols = contains("_"),
    names_to = c("depth", "treat"),
    names_pattern = "d?(.*)_(.*)",
    values_to = c("vwc")
  ) %>%
  mutate(plt_name = ifelse(treat == "warm", paste0("heated", "_", substr(block, 2, 2)), paste0("control", "_", substr(block, 2, 2)))) %>%
  select(date, depth, plt_name, vwc)
stmp.l <- raw.stmp[ , c(1:2, 5:ncol(raw.stmp))] %>%
  pivot_longer(
    cols = contains("_"),
    names_to = c("depth", "treat"),
    names_pattern = "d?(.*)_(.*)",
    values_to = c("soilT")
  ) %>%
  mutate(plt_name = ifelse(treat == "warm", paste0("heated", "_", substr(block, 2, 2)), paste0("control", "_", substr(block, 2, 2)))) %>%
  select(date, depth, plt_name, soilT)

# pivot airT by treatment
airT_plt <- raw.stmp[ , 1:4] %>%
  pivot_longer(
    cols = contains("_"),
    names_to = "treat",
    names_pattern = "_(.*)",
    values_to = c("airT")
  ) %>%
  mutate(plt_name = ifelse(treat == "warm", paste0("heated", "_", substr(block, 2, 2)), paste0("control", "_", substr(block, 2, 2)))) %>%
  select(date, plt_name, airT)

# write csv files to input_data
raw.dat.ls <- list(
  soilC = raw.soil[ , 1:4],
  soilN = raw.soil[ , c(1:3, 5)],
  airT = raw.clim[ ,  c(1, 3)],
  airT_plt = airT_plt,
  prcp = raw.clim[ ,  1:2],
  soilMoist = smst.l,
  soilT = stmp.l
)
nm.ls <- lapply(seq_along(raw.dat.ls), function(i) paste0(names(raw.dat.ls[i]), ".csv"))
lapply(seq_along(nm.ls), function(i) {
  pth <- "../data/experiments/SWAMP/input_data/"
  write.csv(x = raw.dat.ls[[i]], file = paste0(pth, nm.ls[[i]]), row.names = FALSE)
})

# write dd files
swmp.inDat.pth.ls <- list.files("../data/experiments/SWAMP/input_data", full.names = TRUE)
lapply(seq_along(swmp.inDat.pth.ls), function(i) {
  nm <- sapply(strsplit(basename(swmp.inDat.pth.ls[i]), ".csv"), "[[", 1)
  dd_helper("SWAMP", nm)
})

flmd_helper(
  expName = "SWAMP",
  dataFileName = "airT",
  dateColName = "date",
  append = FALSE, 
  write_out = TRUE,
  Jeff = TRUE)

flmd_helper(
  expName = "SWAMP",
  dataFileName = "airT_plt",
  dateColName = "date",
  append = TRUE, 
  write_out = TRUE,
  Jeff = TRUE)

lapply(seq_along(swmp.inDat.pth.ls[c(4, 6)]), function(i) {
  nm <- sapply(strsplit(basename(swmp.inDat.pth.ls[c(4, 6)][i]), ".csv"), "[[", 1)
  cat(paste0("\n", nm, "\n"))
  flmd_helper(
    expName = "SWAMP", 
    dataFileName = nm, 
    dateColName = "date",
    append = TRUE, write_out = TRUE,
    Jeff = TRUE)
})
```

## SWELTR


## TEAM

TEAM data provided as a sheet for each depth within an excel workbook. Code below reads data from there and outputs properly formatted .csv files. Note that original temperature excel workbook has summary data in rows below row number 1900; these are excluded during read in.

```{r TEAM-data-process}
dat.dir <- "../data/experiments/TEAM/data"
TEAM.temp.path <- "../data/experiments/TEAM/raw/soil temperature-TEAM 2018-2023.xlsx"
ix <- excel_sheets(TEAM.temp.path)[1:8]
TEAM.temp.ls <- lapply(seq_along(ix), function(i) {
  read_excel(TEAM.temp.path, sheet = i, n_max = 1900)
})
names(TEAM.temp.ls) <- ix
TEAM.temp.df <- bind_rows(TEAM.temp.ls, .id = "depth")
TEAM.temp.df.long <- pivot_longer(TEAM.temp.df, cols = starts_with("plot"), names_to = "plot", values_to = "temp") %>%
  mutate(plot = sub("plot", "", plot),
         depth = as.numeric(sub("cm", "", depth)))
write.csv(
  TEAM.temp.df.long, 
  file = file.path(dat.dir, "temp.csv"),
  row.names = FALSE)

TEAM.moist.path <- "../data/experiments/TEAM/raw/soil mositure-TEAM 2018-2023.xlsx"
ix <- excel_sheets(TEAM.moist.path)[1:6]
TEAM.moist.ls <- lapply(seq_along(ix), function(i) {
  read_excel(TEAM.moist.path, sheet = i)
})
names(TEAM.moist.ls) <- ix
TEAM.moist.df <- bind_rows(TEAM.moist.ls, .id = "depth")
TEAM.moist.df.long <- pivot_longer(TEAM.moist.df, cols = starts_with("plot"), names_to = "plot", values_to = "moist") %>%
  mutate(plot = sub("plot", "", plot),
         depth = as.numeric(sub("cm", "", depth)))
write.csv(
  TEAM.moist.df.long, 
  file = file.path(dat.dir, "moist.csv"),
  row.names = FALSE)
```

## TeRaCON
- four data streams
  1) "sentek": VWC, salinity, and temperature at 15 min intervals for roughly 5 years
  2) "temp": temp 
  3) "tdr": soil moisture from TDR sensors
  4) "Biocon_hourly_2012-2018vprimary1.csv" & ""

```{r TeRaCON-dat}
# read data files
## TDR
tdr <- read.csv(
  file = "../data/experiments/TeRaCON/raw/TDR 2019-2023 data for distribution.csv", 
  na.strings = "NAN", 
  skip = 2, # units in second row, so skipping and adding colnames separately
  header = FALSE,
  col.names = colnames(read.csv(file = "../data/experiments/TeRaCON/raw/TDR 2019-2023 data for distribution.csv", nrows = 1, header = TRUE)))
### get plot IDs from TDR & ring IDs
tdr.plt <- read_xlsx("../data/experiments/TeRaCON/raw/Plot table.xlsx", sheet = "TDRs") 
### add plot names and pivot longer
tdr.cln <- tdr %>%
  mutate(Ring = as.numeric(substr(Ring, 5, 5))) %>%
  pivot_longer(
    cols = contains("VWC"),
    names_to = "TDR #",
    names_pattern = "([0-9]+).*$",
    values_to = "vwc") %>%
  mutate(`TDR #` = as.numeric(`TDR #`),
         depth = 20,
         date = parse_date_time(TIMESTAMP, orders = "mdy HM")) %>%
  left_join(tdr.plt, by = c("Ring", "TDR #")) %>%
  rename(plt_name = Plot) %>%
  select(plt_name, date, depth, vwc)

## sentek
# read data and plot name key
sentek_key <- read.csv("../data/experiments/TeRaCON/raw/sentek_key.csv")
sentek_key$ringProbe <- paste0(sentek_key$Ring, sentek_key$Probe.Letter)
sentek.raw <- read.csv("../data/experiments/TeRaCON/raw/sentek2019_2023 data for distribution.csv", na.strings = "NAN")

# ST
##
## add plot name and reshape data
sentek.st <- sentek.raw %>% select(TIMESTAMP, STATNAME, starts_with("TEMP"))
names(sentek.st)[3:ncol(sentek.st)] <- substr(gsub("TEMP_", "", names(sentek.st)[3:ncol(sentek.st)]), 1, 3)
sentek.st %>%
  filter(!if_all(3:ncol(sentek.st), is.na)) %>%
  pivot_longer(cols = 3:ncol(sentek.st), names_to = c("Probe", "depth"), names_sep = "\\.", values_to = "soilT") %>%
  filter(!is.na(soilT)) %>%
  mutate(ring = substr(STATNAME, 6, 6),
         plt_name = sentek_key$Plot[match(paste0(ring, Probe), sentek_key$ringProbe)],
         date = parse_date_time(TIMESTAMP, orders = "mdy HM")) %>%
  select(date, plt_name, depth, soilT) %>%
  write.csv(., "../data/experiments/TeRaCON/input_data/sentek_st_2019-2023.csv", row.names = FALSE)
dd_helper("TeRaCON", "sentek_st_2019-2023")
read.csv("../data/experiments/TeRaCON/input_data/sentek_st_2019-2023.csv", nrow = 1)

# VWC
## add plot name and reshape data
sentek.vwc <- sentek.raw %>% select(TIMESTAMP, STATNAME, starts_with("VWC"))
names(sentek.vwc)[3:ncol(sentek.vwc)] <- substr(gsub("VWC_", "", names(sentek.vwc)[3:ncol(sentek.vwc)]), 1, 3)
sentek.vwc %>%
  filter(!if_all(3:ncol(sentek.vwc), is.na)) %>%
  pivot_longer(cols = 3:ncol(sentek.vwc), names_to = c("Probe", "depth"), names_sep = "\\.", values_to = "vwc") %>%
  filter(!is.na(vwc)) %>%
  mutate(ring = substr(STATNAME, 6, 6),
         plt_name = sentek_key$Plot[match(paste0(ring, Probe), sentek_key$ringProbe)],
         date = parse_date_time(TIMESTAMP, orders = "mdy HM")) %>%
  select(date, plt_name, depth, vwc) %>%
  write.csv(., "../data/experiments/TeRaCON/input_data/sentek_vwc_2019-2023.csv", row.names = FALSE)
dd_helper("TeRaCON", "sentek_vwc_2019-2023")
read.csv("../data/experiments/TeRaCON/input_data/sentek_vwc_2019-2023.csv", nrow = 1)

# soil temp
sensors <- read_xlsx('../data/experiments/TeRaCON/raw/Plot table.xlsx', sheet = "Sensors", range = "A1:E121")
temp.2019.2023 <- read.csv('../data/experiments/TeRaCON/raw/Temperature 2019-2023 data for distribution.csv', na.strings = "NAN") %>%
 mutate(Ring = as.numeric(substr(STATNAME.1., 5, 5))) %>%
  pivot_longer(
    cols = contains("Temp"),
    names_to = "Sensor number",
    names_pattern = "([0-9]+).*$",
    values_to = "temp") %>%
  mutate(`Sensor number` = as.numeric(`Sensor number`),
         date = parse_date_time(TIMESTAMP, orders = "mdy HM")) %>%
  left_join(sensors, by = c("Ring", "Sensor number")) %>%
  rename(plt_name = Plot)

# filter to dates w/ warming ON
airT <- temp.2019.2023 %>%
  filter(`Sensor type` == "aboveground") %>%
  filter(Flag.2. == -1) %>%
  select(date, plt_name, temp)
soilT <- temp.2019.2023 %>%
  filter(`Sensor type` != "aboveground") %>%
  filter(Flag.3. == -1) %>%
  # average values by plot (warmed plots have two sensors, one next to heating rod and a "lag" pin 25 cm away)
  group_by(date, plt_name) %>%
  summarize(temp = mean(temp, na.rm = TRUE), .groups = "drop") %>%
  select(date, plt_name, temp) %>%
  rename(soilT = temp)


## biocon
biocon.temp.wmsn <- read.csv("../data/experiments/TeRaCON/raw/Biocon_hourly_warmingseason_2012-2018vprimary1.csv") %>%
  mutate(date = parse_date_time(time4, orders = "ymd HMS")) %>%
  rename(plt_name = plot)

# separate data by variables
## soil moist
biocon.temp.wmsn %>% 
  mutate(depth = 20) %>%
  select(plt_name, date, depth, vwc) %>%
  rbind(tdr.cln) %>% 
  write.csv(
    ., 
    file = "../data/experiments/TeRaCON/input_data/vwc_tdr_2012-2023.csv",
    row.names = FALSE)
dd_helper("TeRaCON", "vwc_tdr_2012-2023")
read.csv("../data/experiments/TeRaCON/input_data/vwc_tdr_2012-2023.csv", nrow = 1)

## soil T
biocon.temp.wmsn %>%
  rowwise() %>%
  mutate(soilT = ifelse(is.na(soil_lag_temp), soil_pin_temp, mean(c(soil_lag_temp, soil_pin_temp), na.rm = TRUE))) %>%
  ungroup() %>%
  select(date, plt_name, soilT) %>%
  rbind(soilT) %>%
  mutate(depth = 17) %>%
  write.csv(
    ., 
    file = "../data/experiments/TeRaCON/input_data/soilT_2012-2023.csv",
    row.names = FALSE)
dd_helper("TeRaCON", "soilT_2012-2023")
read.csv("../data/experiments/TeRaCON/input_data/soilT_2012-2023.csv", nrow = 1)

trcn.inDat.pth.ls <- list.files("../data/experiments/TeRaCON/input_data", full.names = TRUE)
lapply(seq_along(trcn.inDat.pth.ls), function(i) {
  nm <- sapply(strsplit(basename(trcn.inDat.pth.ls[i]), ".csv"), "[[", 1)
  cat(paste0("\n", nm, "\n"))
  flmd_helper(
    expName = "TeRaCON", 
    dataFileName = nm, 
    dateColName = "date",
    append = TRUE, write_out = TRUE,
    Jeff = TRUE)
})

rm(airT, soilT, biocon.temp.wmsn, temp.2019.2023, sensors)
```

```{r ter-temp-moist-dat}
biocon.temp <- read.csv("../data/experiments/TeRaCON/input_data/Biocon_hourly_2012-2018vprimary1.csv")

# test input fx
inputDat.fx(
  "TeRaCON", 
  "../data/experiments/TeRaCON/input_data/Biocon_hourly_2012-2018vprimary1.csv", 
  "../data/experiments/TeRaCON/meta/Biocon_hourly_2012-2018vprimary1_dd.csv",
  append.flmd = TRUE)


flmd_helper(
  expName = "TeRaCON",
  dataFileName = "Biocon_hourly_2012-2018vprimary1",
  dateColName = "time4",
  append = TRUE, 
  write_out = TRUE,
  Jeff = TRUE)
```

```{r T-M-blg-ter}
# rename raw data
moistTempTer <- sentek

# Remove trailing period from col names
names(moistTempTer) <- sub('\\.$', '', names(moistTempTer))

# change names sep to be "_" instead of "."
names(moistTempTer) <- gsub(x = names(moistTempTer), pattern = "\\.", replacement = "_")

# drop salinity data and pivot longer
moistTempTer.long <- moistTempTer %>%
  select(c(TIMESTAMP, STATNAME, contains("VWC"), contains("TEMP"))) %>%
  mutate(across(-c(TIMESTAMP, STATNAME), as.numeric)) %>%
  pivot_longer(
    cols = !c(TIMESTAMP, STATNAME),
    names_to = c("var", "sensor", "depth"),
    names_sep = "_",
    values_to = "value") %>%
  mutate(date = parse_date_time(TIMESTAMP, orders = "mdy HM")) %>%
  select(-TIMESTAMP)

# add plot ID for the heat/control plots, and filter drought & eCO2 plots
moistTempTer.long$ring <- sub("Soil_", "", moistTempTer.long$STATNAME)
# add plot based on ring & sensor IDs, vis "Senteks" tab of 'Plot table.xlsx'
pltT.ter <- read_xlsx("../data/experiments/TeRaCON/raw/Plot table.xlsx", sheet = "Senteks", range = "A1:C81") %>% mutate_all(as.character)
moistTempTer.ch <- left_join(
  moistTempTer.long,
  pltT.ter,
  by = join_by(ring == Ring, sensor == `Probe Letter`)) %>%
  rename(plot = Plot) %>%
  na.omit

moistTer <- moistTempTer.ch %>%
  filter(var == "VWC") %>%
  select(var, date, plot, depth, value) %>%
  data.frame()
tempTer <- moistTempTer.ch %>%
  filter(var == "TEMP") %>%
  select(var, date, plot, depth, value) %>%
  data.frame()
moistTempTer.clean <- merge(
  moistTer,
  tempTer,
  by = c("plot", "depth", "date"))
moistTempTer.clean$trt <- ifelse(
  moistTempTer.clean$plot == 106 | moistTempTer.clean$plot == 233 | moistTempTer.clean$plot == 361, "C", "H")
    
# add seasonal info
moistTempTer.clean$season <- ifelse(
  month(moistTempTer.clean$date) < 4, "Q1", 
  ifelse(month(moistTempTer.clean$date) > 3 & month(moistTempTer.clean$date) < 7, "Q2",
         ifelse(month(moistTempTer.clean$date) > 6 & month(moistTempTer.clean$date) < 10, "Q3", "Q4")))
moistTempTer.clean$DEPTH <- as.numeric(moistTempTer.clean$depth) * 10

# models
ter.lm <- lm(mean.moisture ~ DEPTH * trt, moistTempTer.clean)

# plots
moistTempTer.clean %>%
  mutate(datePlot = paste0(date, plot)) %>%
  ggplot(., aes(mean.moisture, DEPTH, color = trt)) +
  geom_path(aes(group = datePlot)) +
  scale_color_manual(values = c("H" = "#F8766D", "C" = "#00A9FF")) +
  scale_y_reverse() +
  facet_grid(cols = vars(season)) +
  theme_bw() +
  theme(panel.grid = element_blank())

moistTempTer.clean %>% 
  group_by(trt, depth, season) %>% 
  summarize(moist = mean(mean.moisture, na.rm = T), sd = sd(mean.moisture, na.rm = T), n = n()) %>%
  mutate(sem2 = 2 * (sd / sqrt(n))) %>%
  ggplot(., aes(depth, moist, fill = trt)) + 
  geom_col(position = "dodge") + 
  geom_errorbar(aes(ymin = moist - sem2, ymax = moist + sem2, color = trt), position = "dodge") +
  scale_fill_manual(values = c("H" = "#F8766D", "C" = "#00A9FF")) +
  scale_color_manual(values = c("H" = "#F8766D", "C" = "#00A9FF")) +
  facet_grid(cols = vars(season)) + 
  theme_bw() + 
  theme(panel.grid = element_blank())

moistTempTer.clean %>% 
  mutate(PP = ifelse(plot < 200, 2, ifelse(plot > 200 & plot < 300, 4, 6))) %>%
  pivot_wider(id_cols = c(PP, DEPTH, date, season), names_from = trt, values_from = mean.moisture) %>%
  mutate(mDif = C - H) %>%
  group_by(DEPTH, season) %>% 
  summarize(mean.mDif = mean(mDif, na.rm = T), sd = sd(mDif, na.rm = T), n = n()) %>%
  mutate(sem2 = 2 * (sd / sqrt(n))) %>%
  ggplot(., aes(DEPTH, mean.mDif, fill = season)) + 
  geom_col(position = "dodge") + 
  geom_errorbar(
    aes(ymin = mean.mDif - sem2, ymax = mean.mDif + sem2, color = season), position = "dodge") + 
  theme_bw() + 
  theme(panel.grid = element_blank())
```

```{r tcn-check-sm}
ts_sum <- dat %>% 
      mutate(dateDay = date(date)) %>%
      group_by(dateDay, pick(all_of(dpt_col_nms))) %>%
      summarize(
        across(
          .cols = names(dat)[ix.dif],
          .fns = list(mean = ~ mean(.x, na.rm = TRUE), 
                      sd = ~ sd(.x, na.rm = TRUE), 
                      n = ~ n()), 
          .names = "{.col}_{.fn}"), .groups = "drop") %>%
      rowwise() %>%
      mutate(
        across(
          ends_with("_sd"),
          ~ . / sqrt(get(sub("_sd$", "_n", cur_column()))),
          .names = "{sub('_sd$', '', .col)}_se"),
        across(
          ends_with("_mean"),
          ~ . - qt(1 - (0.05 / 2), df = get(sub("_mean$", "_n", cur_column()))) * get(sub("_mean$", "_se", cur_column())),
          .names = "{sub('_mean$', '', .col)}_ci.05"),
        across(
          ends_with("_mean"),
          ~ . + qt(1 - (0.05 / 2), df = get(sub("_mean$", "_n", cur_column()))) * get(sub("_mean$", "_se", cur_column())),
          .names = "{sub('_mean$', '', .col)}_ci.95")) %>%
      ungroup() %>%
      select(dateDay, contains("depth"), contains("_mean"), contains("_ci.")) %>%
      pivot_longer(
        cols = contains("- control"),
        names_to = c("dif", ".value"),
        names_pattern = "^(.*)_(.*)$")

p <- sum.ls$subDaily %>%
  filter(date > as.Date('2020-12-31') & date < as.Date('2022-01-01')) %>%
  rename(mean = `treatment2.5 - control`) %>%
      mutate(col = ifelse(mean > 0, "#1db565", "#b5651d")) %>%
      ggplot(., aes(date, mean)) +
      geom_hline(aes(yintercept = 0), linetype = "dotted") +
      geom_point(aes(color = col), size = .1) +
      scale_color_manual(
        name = "",
        values = c("#1db565", "#b5651d"),
        labels = c("#1db565" = "> 0", "#b5651d" = "< 0")) +
      # scale_x_date(breaks = "day") +
      labs(
        y = paste0("VWC", " (trt - ctl)"),
        title = paste0(expName, ": ", datType)) +
      facet_grid(rows = vars(depth)) +
      theme_bw() +
      theme(panel.grid = element_blank(),
            axis.title.x = element_blank(),
            text = element_text(size = 18))
p
```

```{r TeRaCON-soilCO2}
terCO2 <- read.csv('../data/experiments/TeRaCON/raw/W2CON 2012-2023 SCF for Jeff_250828.csv')
```

## TRACE

```{r dd-flmd-TRACE}
xlsx.TRACE.metPth2 <- list.files("../data/experiments/TRACE/input_data", full.names = TRUE)
lapply(seq_along(xlsx.TRACE.metPth2), function(i) {
  nm <- sapply(strsplit(basename(xlsx.TRACE.metPth2[i]), ".csv"), "[[", 1)
  dd_helper("TRACE", nm)
})
TRACE.dat.ls <- lapply(xlsx.TRACE.metPth2, read.csv)
names(TRACE.dat.ls) <- lapply(seq_along(xlsx.TRACE.metPth2), function(i) {
  sapply(strsplit(basename(xlsx.TRACE.metPth2[i]), ".csv"), "[[", 1)
})
date.nms <- c(rep("Date", 3), rep("Date.Time..GMT..0400", 6), rep("TIMESTAMP", 5))
orders.ls <- c(rep("%d-%b-%y", 3), rep("%Y-%m-%d H:M:S", 6), rep("%m/%d/%y %H:%M", 5))
Bisley_MET_2015 <- read.csv("../data/experiments/TRACE/input_data/Bisley_MET_2015.csv")

# read surface data
TRACE.s <- read.csv(
  "../data/experiments/TRACE/input_data/TRACE_SurfaceSoil_2015-2018.csv") %>%
  mutate(date = as.POSIXct(
    as.Date(DateTime.9. + DateTime.4./24,
            origin = lubridate::ymd_hms(DateTime.1., truncated = 5))) - 86400)
TRACE.stm.s <- TRACE.s %>% 
  select(date, contains("Tsoil"))
TRACE.vwc.s <- TRACE.s %>% 
  select(date, contains("WWC"))
cnms <- sapply(str_split(names(TRACE.vwc.s)[2:19], "_"), "[[", 2) 
plt_name <- substr(cnms, 1, 2)
pos <- substr(cnms, 3, 5)
names(TRACE.vwc.s)[2:19] <- paste(plt_name, pos, sep = "_")
names(TRACE.stm.s)[2:19] <- paste(plt_name, pos, sep = "_")

# remove duplicate row (timestamp = 2/29/2016 17:00:00, but for some reason need to advance an hour to select it)
ix <- which(TRACE.vwc.s$date == as.POSIXct("2/29/2016 18:00:00", format = '%m/%d/%Y %H:%M:%S'))
TRACE.vwc.s <- TRACE.vwc.s[-ix[1], ] 
TRACE.stm.s <- TRACE.stm.s[-ix[1], ] 

# find values > 1 and replace w/ NA
TRACE.vwc.s[ , 2:ncol(TRACE.vwc.s)] <- replace(
  TRACE.vwc.s[, 2:ncol(TRACE.vwc.s)], 
  TRACE.vwc.s[, 2:ncol(TRACE.vwc.s)] > 1,
  NA)

# pivot longer
TRACE.vwc.s.l <- TRACE.vwc.s %>%
  pivot_longer(
    cols = contains("_"),
    names_to = c("plt_name", "position"), 
    names_sep = "_",
    values_to = "VWC") %>%
  pivot_wider(
    id_cols = c("date", "plt_name"),
    names_from = "position",
    values_from = "VWC") %>% 
  mutate(depth = 10) %>%
  rowwise() %>%
  mutate(vwc = mean(c(cen, mid, edg), na.rm = TRUE)) %>%
  ungroup() %>%
  select(date, plt_name, depth, vwc)

TRACE.stm.s.l <- TRACE.stm.s %>%
  pivot_longer(
    cols = contains("_"),
    names_to = c("plt_name", "position"), 
    names_sep = "_",
    values_to = "soilT") %>%
  pivot_wider(
    id_cols = c("date", "plt_name"),
    names_from = "position",
    values_from = "soilT") %>% 
  mutate(depth = 10) %>%
  rowwise() %>%
  mutate(soilT = mean(c(cen, mid, edg), na.rm = TRUE)) %>%
  ungroup() %>%
  select(date, plt_name, depth, soilT)

# deep soil VWC
TRACE.d <- read.csv(
  "../data/experiments/TRACE/input_data/TRACE_DeepSoil_2016-2018.csv") %>%
  mutate(date = as.POSIXct(
    as.Date(DateTime.9. + DateTime.4./24,
            origin = lubridate::ymd_hms(DateTime.1., truncated = 5))) - 86400) 
TRACE.vwc.d <- TRACE.d %>%
  select(date, contains("WWC"))
cnms <- sapply(str_split(names(TRACE.vwc.d)[2:ncol(TRACE.vwc.d)], "_"), "[[", 2) 
plt_name <- substr(cnms, 1, 2)
dpt <- substr(cnms, 5, 6)
names(TRACE.vwc.d)[2:ncol(TRACE.vwc.d)] <- paste(plt_name, dpt, sep = "_")

TRACE.stm.d <- TRACE.d %>%
  select(date, contains("Tsoil"))
names(TRACE.stm.d)[2:ncol(TRACE.stm.d)] <- paste(plt_name, dpt, sep = "_")

# pivot, combine, and write to csv
write.csv(
  rbind(
    TRACE.vwc.s.l,
    TRACE.vwc.d %>%
      pivot_longer(
        cols = contains("_"),
        names_to = c("plt_name", "depth"), 
        names_sep = "_",
        values_to = "vwc")),
  file = "../data/experiments/TRACE/input_data/TRACE_VWC_2016-2018.csv",
  row.names = FALSE) 

flmd_helper(
  expName = "TRACE", 
  dataFileName = "TRACE_VWC_2016-2018", 
  dateColName = "date",
  append = TRUE, write_out = TRUE,
  Jeff = TRUE,
  orders = "ymd HMS")

write.csv(
  rbind(
    TRACE.stm.s.l,
    TRACE.stm.d %>%
      pivot_longer(
        cols = contains("_"),
        names_to = c("plt_name", "depth"), 
        names_sep = "_",
        values_to = "soilT")),
  file = "../data/experiments/TRACE/input_data/TRACE_soilT_2016-2018.csv",
  row.names = FALSE) 

flmd_helper(
  expName = "TRACE", 
  dataFileName = "TRACE_soilT_2016-2018", 
  dateColName = "date",
  append = TRUE, write_out = TRUE,
  Jeff = TRUE,
  orders = "ymd HMS")

# initialize flmd
flmd_helper(
  expName = "TRACE", 
  dataFileName = "Bisley_MET_2015", 
  dateColName = "Date",
  append = FALSE, write_out = TRUE,
  Jeff = TRUE,
  orders = "%d-%b-%y")

# additional flmd
flmd_helper(
  expName = "TRACE", 
  dataFileName = "Bisley_MET_2017", 
  dateColName = "Date",
  append = TRUE, write_out = TRUE,
  Jeff = TRUE,
  orders = "%d-%b-%y")

lapply(seq_along(xlsx.TRACE.metPth2[10:14]), function(i) {
  nm <- sapply(strsplit(basename(xlsx.TRACE.metPth2[10:14][i]), ".csv"), "[[", 1)
  cat(paste0("\n", nm, "\n"))
  flmd_helper(
    expName = "TRACE", 
    dataFileName = nm, 
    dateColName = date.nms[10:14][i],
    orders = orders.ls[10:14][i],
    append = TRUE, write_out = TRUE,
    Jeff = TRUE)
})
```

# General Workflow

How to assemble data files in an efficient manner? 
Do we need metadata from the files for efficient querying, which can then be used to retrieve the data?
How to do this?

For example, time intervals, depth intervals, data types. 

How do we organize/categorize sensor data?

Needs:
- standardized date/time format
- time series frequency detection tool? gap ID tool, etc.
- report time series

Need *annotation* tables
- these tables that are used for keyed translation
- header row consists of:
  1) "table_id"
  - describes contents of input data, e.g., "TeRaCON_temp_ts" (do we want naming conventions here?)
  2) "column_id"
  - names of columns in input data, e.g., `r names(temp)`
  3) "of_variable"
  - names of target variables in database, e.g., "temperature"
  4) "is_type"
  - decription of the type of data contained in column named by "column_id", e.g., `r names(temp)[1]` = "timestamp", `r names(temp)[2]` = "sensorID", `r names(temp)[7]` = "value"
  5) "with_entry"
  - flag for whether "column_id" values correspond to names in database, i.e., 
  - if("column_id" == "of_variable") do nothing else replace "column_id" with "of_variable" and "is_type"
  
Need to convert raw data into *shoestring* tuples
- these are an intermediate format for the data that is in "long" format to facilitate joins with the annotation table
- table names include: "table_id", "row_number", "column_id", "with_entry"
- workflow is as follows:
1) use `plyr::ldply` function to transform original data tables, giving each row a unique index
3) pivot the data longer, preserving row indices to allow grouping the data on the original rows
4) set the "table_id" column to the appropriate table name
5) join long data with annotation table by variables "table_id" and "column_id"

Update 2 Aug 2024
- adopted a variation on the ESS-DIVE approach to data dictionary and file level metadata to provide annotation/metadata info
- need to figure out directory structure
  - will quickly run out of space to work with large arrays...
- should store flmd & dd files in SWEDDIE directory; but also should keep these files with the data
- perhaps the data directory is stored in an external drive, and a copy of the metadata is written into the SWEDDIE directory each time data are compiled?
- I envision this compilation function creating a "meta" version of the database by compiling flmd & dd files
- the "meta" database is then queried to generate reports by reading in the actual data from the external source

# Analysis

Start with overall trends, i.e., simplify data to assess data on daily time step. Calculate mean, min, max, and sd for soil moisture and temperature. Treat plots as reps.

## Research Questions

1. Does heating influence soil moisture?
- use ANOVA type approach to compare heated/control plots
- could also look at regression of soil moisture and temperature, e.g., mixed modeling approach looking at treatment, site, etc., as potential variables affecting relationship
- OR, perhaps more simply, look at the difference between treatment and control soil moisture, and assess how different factors affect that difference

2. Does heating influence the depth profile of soil moisture?
- could use regression approach on control-heated soil moisture
- OR, ANOVA of different depths?
- Probably useful to treat depth as a continuous variable, but one potentially interacting with soil texture, vegetation (roots?), climate
- Might be useful to conduct the analysis within aridity/wetness index bins

3. How does site infrastructure/heating regime affect soil moisture trends?
- again, probably easiest to do in a regression context

5. Does aboveground vs. belowground heating affect soil moisture depth profiles?

6. Is there a heating level for which a given site exceeds a critical soil moisture deficit, e.g., wilting points/etc. [need to think about this more]

7. Does soil moisture affect the variability in heating in XYZ coordinates? For example, saturated soils could be expected to have more even heating; or, for sites with surficial heating, saturated soils may be slower to heat, e.g., at TRACE, KAEFS, etc.


## Hypotheses

1. Warmed plots will have lower soil moisture due to increased evaporation (and evapotranspiration?)
2. Differences between control and heated plot soil moisture will only be apparent in low moisture environments; is there a aridity/wetness index cut-off for this? 
3. Control-heated soil moisture differences will vary seasonally, greater during periods of increased soil moisture loss, i.e., summer


## Data
- soil temperature and moisture data
- depths
  - need to spline so that temperature and moisture are at same depths w/in sites
- climate:
  - *MAT*, *MAP*, *PET* (global), PET local (if available), ET, PAR (for calculating PET?)
- root biomass by depth?
- *soil texture*
- *soil organic matter*
- hydraulic conductivity (?)
- matric potential (?)

# Visualize core data

```{r plots}
database <- coreData.fx()
database <- Filter(Negate(is.null), database)
exp.ls <- lapply(database, "[[", "experiment")
sit.ls <- lapply(database, "[[", "site")
plt.ls <- lapply(database, "[[", "plot")

exp.sit.df <- merge(
  bind_rows(lapply(database, function(x) lapply(x$experiment, as.character))),
  bind_rows(lapply(database, function(x) lapply(x$site, as.character))),
  by = "exp_name") %>% type.convert(as.is = TRUE)

# filter non-unique sites
exp.sit.df <- exp.sit.df[-c(10, 11, 18, 19, 23), ]

# MAT & MAP
exp.sit.df <- exp.sit.df %>%
  mutate(
    biome = ifelse(biome == "alpine tundra", "tundra", ifelse(biome == "ombrotrophic peatland", "peatland", ifelse(biome == "temperate grassland", "grassland", biome))),
    MAT = ifelse(exp_name == "GENX" | exp_name == "SMARTX", 13, MAT),
    MAP = ifelse(exp_name == "GENX" | exp_name == "SMARTX", 1130, MAP)) 

# get soil order & PET
pet <- rast("/Users/jbeemmil@umich.edu/geospatial/PET/PET_x_x_x_mmyr_mean.tif")
soilOrder <- rast("/Users/jbeemmil@umich.edu/geospatial/soilOrder/soilOrder_x_x_x_x_USDA.tif")
ext <- terra::extract(pet, exp.sit.df[ , c("sit_long", "sit_lat")])
exp.sit.df$PET <- ext$pet_pm_sr_yr
ext <- terra::extract(soilOrder, exp.sit.df[ , c("sit_long", "sit_lat")])
key.df <- data.frame(
  utils::read.csv("/Users/jbeemmil@umich.edu/geospatial/soilOrder/soilOrder_x_x_x_x_USDA.csv",
                  stringsAsFactors = FALSE))
exp.sit.df$USDA_globe <- key.df[match(ext[ , 2], key.df$ID), 2]

# fill soil data
exp.sit.df[exp.sit.df$exp_name == "Hawaii", "USDA_globe"] <- "Andisols"
exp.sit.df[exp.sit.df$exp_name == "MERIT", "USDA_globe"] <- "Entisols"
exp.sit.df[exp.sit.df$exp_name == "PtReyes", "USDA_globe"] <- "Alfisols"
exp.sit.df[exp.sit.df$exp_name == "TRACE", "USDA_globe"] <- "Ultisols"

# plot various attributes

# heat levels
htlvl.ls <- lapply(
    lapply(
      database, function(x) separate_longer_delim(x$experiment, "heat_levels", ";")), "[[", "heat_levels")
hlvls <- data.frame(
  name  = rep(names(htlvl.ls), lengths(htlvl.ls)),
  htlvl = unlist(htlvl.ls, use.names = FALSE),
  stringsAsFactors = FALSE
)
hlvls <- hlvls[-c(hlvls$hlvl == "0"), ]

plot_hlvls <- data.frame(htlvls = hlvls[hlvls != 0 & !is.na(hlvls)])
p <- plot_hlvls %>% filter(htlvls < 10) %>% ggplot(., aes(htlvls)) +
  geom_histogram(binwidth = 1) +
  scale_x_continuous(breaks = 1:9) +
  labs(
    x = "Heated - Control (°C)",
    y = "count") +
  theme_bw() +
  theme(panel.grid = element_blank(),
        text = element_text(size = 24))

ggsave(
    filename = "../docs/AGU24/hlvls.png",
    plot = p,
    height = 12.49, 
    width = 21.48, 
    dpi = 300,
    units = "cm")

# heat mtd BG
exp_hmtdB <- separate_longer_delim(data.frame(hm = unlist(sapply(exp.ls, "[[", "heat_mtd_belowGround"))), "hm",";")

# heat mtd AG
exp_hmtdA <- separate_longer_delim(data.frame(hm = unlist(sapply(exp.ls, "[[", "heat_mtd_aboveGround"))), "hm",";")

# plot MAT & MAP
exp.sit.df %>%
  ggplot(., aes(MAT, MAP, color = biome)) +
  geom_point(size = 4) +
  theme_bw() +
  theme(panel.grid = element_blank())

# MAT v. MAP w/ PM
ggplot(sit.df, aes(MAT, MAP, color = parent_material)) +
  geom_point(size = 4) +
  theme_bw() +
  theme(panel.grid = element_blank()) 

# stand along legend for PM
pm.legend <- cowplot::get_legend(
 ggplot(exp.site, aes(MAT, MAP, color = parent_material)) +
  geom_point(size = 4) +
  theme_bw() +
  theme(panel.grid = element_blank()) 
)
grid::grid.newpage()
grid::grid.draw(pm.legend)

# plot land use
exp.sit.df[match(unique(exp.sit.df$sit_name), exp.sit.df$sit_name), ] %>%
  mutate(biome = ifelse(grepl("tundra", biome), "tundra", 
                        ifelse(grepl("peat", biome), "peatland",
                               ifelse(grepl("grassland", biome), "grassland", biome))),
         biome = reorder(biome, biome, function(x) -length(x))) %>%
  ggplot(., aes(biome, fill = biome)) +
  geom_bar() +
  scale_fill_manual(
    values = c("temperate forest" = "#97B669",
               "grassland" = "#FCD57A",
               "tundra" = "#C1E1DD",
               "tropical forest" = "#317A22",
               "boreal forest" = "#A5C790",
               "peatland" = "#D16E3F",
               "salt marsh" = "#db8d68",
               "subtropical forest" = "#75A95E",
               "cropland" = "#FFD700")) +
  theme_bw() +
  theme(panel.grid = element_blank(),
        axis.text.x = element_text(angle = 45, hjust = 1)) 

# Map
latlon <- exp.sit.df[ , c("exp_name", "sit_lat", "sit_long")]
world <- map_data("world")

ggplot() +
  geom_polygon(data = world, aes(x = .data$long, y = .data$lat, group = .data$group), fill = NA, color = "Black") +
  geom_point(data = latlon, aes(x = .data$sit_long, y = .data$sit_lat), color = "black", size = 2, shape = 21, stroke = .8, fill = "#ff6767") +
  geom_text(data = latlon, aes(x = sit_long, y = sit_lat, label = exp_name), hjust = 1, vjust = .2) +
  theme_bw(base_size = 16) +
  labs(title = "SWEDDIE: Site_Map", x = "Longitude", y = "Latitude")

# plot raster data
## KG
latlon.v <- vect(latlon, geom = c("sit_long", "sit_lat"), crs = "+proj=longlat +datum=WGS84")
plot(tifRaster, plg = list(loc = "right")); plot(latlon.v, add = T, pch = 21, col = "white", bg = "black")


# parse dates
BG_i <- parse_date_time(exp.sit.df$heat_BG_date_i, orders = c("%Y", "%m/%d/%y", "%m/%d/%Y", "%b-%y", "%d-%b"))
AG_i <- parse_date_time(exp.sit.df$heat_AG_date_i, orders = c("%Y", "%m/%d/%y", "%m/%d/%Y", "%b-%y", "%d-%b"))
dur.BG <- time_length(interval(BG_i, today()), "year")
dur.AG <- time_length(interval(AG_i, today()), "year")

exp.sit.df$belowground <- dur.BG
exp.sit.df$aboveground <- dur.AG

p <- exp.sit.df %>%
  filter(exp_name != "PtReyes") %>%
  pivot_longer(cols = c(belowground, aboveground), 
               names_to = "heating", 
               values_to = "duration") %>%
  arrange(desc(duration)) %>%
  mutate(exp_name = ordered(exp_name, levels = unique(exp_name))) %>%
  ggplot(., aes(duration, exp_name)) +
  geom_point(aes(shape = heating), size = 4) +
  scale_shape_manual(values = c("belowground" = 6, "aboveground" = 2)) +
  theme_bw() +
  theme(panel.grid = element_blank(),
        axis.text.x = element_text(size = 24),
        axis.text.y = element_text(size = 20),
        axis.title.y = element_blank(),
        axis.title.x = element_text(size = 24),
        legend.text = element_text(size = 24),
        legend.title = element_text(size = 24),
        legend.position = c(.7, .8)) 

ggsave(
    filename = "../docs/AGU24/dur.png",
    plot = p,
    height = 12.49, 
    width = 21.48, 
    dpi = 300,
    units = "cm")
```

```{r map-soc-exp}
## SOC
# soc10 <- terra::rast("/Users/jbeemmil@umich.edu/geospatial/SOC_SoilGrids2.0/corgStock_0_10_x_cm_SG.tif")
# soc30 <- terra::rast("/Users/jbeemmil@umich.edu/geospatial/SOC_SoilGrids2.0/corgStock_10_30_x_cm_SG.tif")
# soc60 <- terra::rast("/Users/jbeemmil@umich.edu/geospatial/SOC_SoilGrids2.0/corgStock_30_60_x_cm_SG.tif")
# soc100 <- terra::rast("/Users/jbeemmil@umich.edu/geospatial/SOC_SoilGrids2.0/corgStock_60_100_x_cm_SG.tif")
# soc200 <- terra::rast("/Users/jbeemmil@umich.edu/geospatial/SOC_SoilGrids2.0/corgStock_100_200_x_cm_SG.tif")
# terra::crs(soc10) <- "+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0"
# terra::crs(soc30) <- "+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0"
# terra::crs(soc60) <- "+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0"
# terra::crs(soc100) <- "+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0"
# terra::crs(soc200) <- "+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0"
# # stack into a SpatRaster with 5 layers
# soc_stack <- c(soc10, soc30, soc60, soc100, soc200)
# 
# # sum across layers, ignoring NA
# soc0_200 <- sum(soc_stack, na.rm = TRUE)

# # save
# writeRaster(
#   soc0_200,
#   "/Users/jbeemmil@umich.edu/geospatial/SOC_SoilGrids2.0/corgStock_0_200_x_cm_SG.tif",
#   overwrite = TRUE)

soc0_200 <- rast("/Users/jbeemmil@umich.edu/geospatial/SOC_SoilGrids2.0/corgStock_0_200_x_cm_SG.tif")

# plot
library(viridis)
library(fields) 

# add lab_nm
exp.sit.df$lab_nm <- seq(1, nrow(exp.sit.df))

# Define the number of color breaks
n_colors <- 100

# Create breaks that are spaced log-wise (but still match original data values)
log_breaks <- exp(seq(log(1), log(200), length.out = n_colors + 1)) - 1

# The actual color palette
col_ramp <- viridis(n_colors)

# create png file
png("/Users/jbeemmil@umich.edu/eco-warm/docs/EGU25/SWEDDIE_map_0_200.png", width = 6, height = 3.7, units = "in", res = 300)

# plot raster
imagePlot(
  soc0_200,
  breaks = log_breaks,
  col = col_ramp,
  legend.lab = "",
  axis.args = list(
    at = c(0, 10, 20, 30, 80, 100, 150),
    labels = c(0, 10, 20, 30, 80, 100, 150),
    cex.axis = .8
  ),
  cex.axis = .8,
  legend.mar = 5,
  useRaster = TRUE
); points(exp.sit.df$sit_long, exp.sit.df$sit_lat, pch = 21, col = "white", bg = "red", cex = .7)

dev.off()

## ggplot approach
# get xy
sit.xy.df <- exp.sit.df %>%
  select(exp_name, sit_name, sit_lat, sit_long) %>%
  mutate(lab_nm = seq(1, nrow(exp.sit.df)))

# aggregate raster
soc0_200.ag <- aggregate(soc0_200, fact = 20)  # increase 'fact' to reduce size more


soc0_200.ag.df <- terra::as.data.frame(soc0_200.ag, xy = TRUE)
soc0_200.ag.df$sum <- ifelse(soc0_200.ag.df$sum == 0, NA, soc0_200.ag.df$sum)

ggplot() +
  geom_raster(data = soc0_200.ag.df, aes(x = x, y = y, fill = sum)) +
  scale_fill_gradientn(
    colours = viridis(n_colors),
    trans   = "log",                          # log scale
    breaks  = c(1, 5, 10, 20, 50, 100, 200), # nice ticks
    labels  = c("1", "5", "10", "20", "50", "100", "200"),
    name    = "SOC"
  ) +
  geom_point(data = sit.xy.df, aes(x = sit_long, y = sit_lat),
             shape = 21, fill = "red", size = 3, color = "white") +
  geom_text_repel(data = sit.xy.df, aes(x = sit_long, y = sit_lat, label = lab_nm),
                  size = 5, color = "black") +
  coord_equal() +
  theme_bw() +
  theme(
    panel.background = element_blank(),
    plot.background  = element_blank())
```

```{r map-KG}
# get KG data
tifRaster <- terra::rast("/Users/jbeemmil@umich.edu/Downloads/KG_x_x_x_x_present.tif")
terra::crs(tifRaster) <- "+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0"
ext <- terra::extract(tifRaster, exp.sit.df[ , c("sit_long", "sit_lat")])
key.df <- data.frame(
  utils::read.csv("/Users/jbeemmil@umich.edu/Downloads/KG_x_x_x_x_present.csv",
                  stringsAsFactors = FALSE))
exp.sit.df <- cbind(exp.sit.df, key.df[match(ext[ , 2], key.df$ID), c(2,3)])

newcols <- coltab(tifRaster)
newcols[[1]][["alpha"]] <- 100
lg <- newcols[[1]][2:31, ]
lg <- cbind(lg, key.df[, 2:3])

kg <- tifRaster
coltab(kg) <- newcols
lvls <- rbind(key.df[ , c(1, 2)], data.frame("ID" = seq(31, 255, 1), "pro_KG_present_short" = 0))
lg.ch <- rgb(lg[,2:4], maxColorValue = 255)
names(lg.ch) <- lg$pro_KG_present_short
levels(kg) <- lvls

# get stand along legend for KG
lg.ch.long <- lg.ch
names(lg.ch.long) <- lg$pro_KG_present_long
kg.legend <- cowplot::get_legend(
  exp.sit.df %>%
    mutate(pro_KG_present_long = factor(pro_KG_present_long, levels = names(lg.ch.long))) %>%
    ggplot(., aes(MAT, MAP, color = pro_KG_present_long)) +
    geom_point(size = 4) +
    scale_color_manual(name = "Köppen-Geiger Zone",
                       breaks = names(lg.ch.long),
                       values = lg.ch.long,
                       drop = FALSE) +
    guides(color = guide_legend(ncol = 3)) +
    theme_bw() +
    theme(panel.grid = element_blank())
)
grid::grid.newpage()
grid::grid.draw(kg.legend)
```

## Harmonization
- how to harmonize data?
  - need to make sure common variables have the same name
  - search the description columns? E.g., of the _dd files
    - choose key words
    - may need to control variable types from flmd...e.g., as a ";" separated list
  - need some way to know the date column as well
    - can use "type" from _dd file

```{r test-hmz}
# search for temperature data
# need temp + date + IDs
test_temp <- lapply(seq_along(flmd_dd.ls), function(i) {
  expName <- names(flmd_dd.ls[i])
  basePath <- "../data/experiments/"
  
  # get file names for files containing target varName
  nms <- lapply(flmd_dd.ls[[i]][["flmd"]], function(x) {
    sub(".csv", "", x[which(x$varNames == "soil temperature"), "fileName"])
  })
  
  # get corresponding _dd files
  dds <- flmd_dd.ls[[i]][["dd"]][unlist(lapply(unlist(nms), function(y) grep(y, names(flmd_dd.ls[[i]][["dd"]]))))]
  
  # search for required columns & var units: 
  # 'date', variable, units, 'depth_upper', 'depth_lower', 'plt_ind'
  datVarName <- stringdist()
  ix <- lapply()
  
  dat.ls <- lapply(unlist(nms), function(z) read.csv(paste0(basePath, "/", expName, "/input_data/", z)))
  ix <- lapply(flmd_dd.ls[[i]][["dd"]], function(x) {
    list(which(x$dataType == "date"), which(grepl("temp", x$description)))
  })
  })  
  }))
})
names(test_temp) <- names(flmd_dd.ls)
```

### stringdist

Use 'varNames' values to search for best match among 'description' columns of _dd files

```{r harmony-test}
result <- bind_cols(df_1, map_df(df_1$str_1, function(x) {
  vals <- stringdist(x, df_2$str_2,  method = 'jw')
  data.frame(Nearest_matching =  df_2$str_2[which.min(vals)],
             Nearest_matching_score = max(vals))
}))

apply(flmd_dd.ls$ACBB$flmd$ACBB_flmd, 1, )

```


### moist dat

Helper functions

```{r moist-sum-plt-fx}
## parse date, add treatment col
filPltTbl.fx <- function(ls, expName, heat_only = TRUE, orders = NULL, plt_cols = NULL, dateName = "date", time_zone = "UTC", ...) {
  
  # check for database object
  if (!exists("database")) {
    database <- tryCatch(coreData.fx(verbose = FALSE))
  }
  
  # get plot table and remove empty cols
  pltTbl <- database[[expName]]$plot %>%
    select_if(~!(all(is.na(.))))
  
  # check for orders and parse date/time
  if (is.null(orders)) {
    cat("\nDate/time orders missing...\n\n")
    orders <- vector(mode = "list", length = length(ls[[expName]]))
    for (i in seq_along(orders)) {
      cat("The first 3 entries of", expName, "file '", names(ls[[expName]][i]), "' are:\n\n") 
      print(ls[[expName]][[i]]$date[1:3])
      if (i > 1) {
        ix <- menu(c("yes", "no"), title = "\nDo date/time orders differ from previous entries?\n")
      } else {
        ix <- 1
      }
      if (ix == 1) {
        cat("Please provide the date-time format/s in the proper order, e.g., 'ymd', 'dmy', 'mdy HM', etc. (see lubridate::parse_date_time() for list of accepted formatting characters as needed)\n")
        orders[[i]] <- readline("orders: ")
      } else {
        orders[[i]] <- orders[[i-1]]
      }
    }
  } else if (length(orders) == 1) {
    orders <- rep(list(orders), length(ls[[expName]]))
  } else if (length(orders) != length(ls[[expName]])) {
  warning("Length of supplied 'orders' not equal to number of datafiles\n")
  }

  lapply(seq_along(ls[[expName]]), function(i) {
  
    # rename object
    x <- ls[[expName]][[i]]
    
    # get plot table indices and fill plot table cols
    ix <- match(x$plt_name, pltTbl$plt_name)
    
    # check plt_cols
    if (is.null(plt_cols)) {
      plt_cols <- c("plt_name")
    }
    
    if (any(!plt_cols %in% names(pltTbl))) {
      warning(paste0("plt_col names not found in ", expName, " plot table. Missing cols: ", plt_cols[which(!plt_cols %in% names(pltTbl))], "\n"))
    }
    
    # add heating level to 'plt_treat_heat'
    pltTbl$plt_treat_heat <- ifelse(pltTbl$plt_heat_level == 0, "control", paste0("treatment", pltTbl$plt_heat_level))
    
    # check for additional treatments
    if (any(grepl("plt_treat_add_name", names(pltTbl)))) {
      
      # fill blank 'plt_treat_add_name' w/ NA
      pltTbl$plt_treat_add_name <- ifelse(pltTbl$plt_treat_add_name == "", NA, pltTbl$plt_treat_add_name)
      
      # Split any semicolon-separated values
      split_values <- strsplit(
        as.character(pltTbl$plt_treat_add_name), 
        ";", 
        fixed = TRUE)
      split_values_lvl <- strsplit(
        as.character(pltTbl$plt_treat_add_level), 
        ";", 
        fixed = TRUE)
  
      # Determine the maximum number of values
      max_splits <- max(sapply(split_values, length))
      
      # get indices of base treatment/control pairs (heat_only)
      ix.base <- vector(mode = "list", length = max_splits)
        
      # Create additional columns for each split value
      for (j in seq_len(max_splits)) {
        pltTbl[[paste0("plt_treat_add_name_", j)]] <- sapply(split_values, function(v) ifelse(length(v) >= j, v[j], NA))
        pltTbl[[paste0("plt_treat_add_level_", j)]] <- sapply(split_values_lvl, function(v) ifelse(length(v) >= j, v[j], NA))
        pltTbl[[paste0("plt_treat_add_name_", j)]] <- ifelse(
          is.na(pltTbl[[paste0("plt_treat_add_name_", j)]]), NA, 
          paste0(pltTbl[[paste0("plt_treat_add_name_", j)]], "_", pltTbl[[paste0("plt_treat_add_level_", j)]]))
        ix.base[[j]] <- which(pltTbl[[paste0("plt_treat_add_level_", j)]] == 0 | is.na(pltTbl[[paste0("plt_treat_add_level_", j)]]))
        pltTbl$plt_treat_add_name <- NULL
      }
      
      # simplify data if only heat treatment of interest
      if (heat_only) {
        pltTbl<- pltTbl[Reduce(intersect, ix.base), ]
        x <- x[x$plt_name %in% pltTbl$plt_name, ]
        ix <- match(x$plt_name, pltTbl$plt_name)
        pltTbl$plt_treat <- pltTbl$plt_treat_heat
      } else {
      interaction_cols <- c("plt_treat_heat", names(pltTbl)[grep("plt_treat_add_name", names(pltTbl))])
      pltTbl$plt_treat <- apply(
        pltTbl[, interaction_cols, drop = TRUE], 1, function(row) paste(na.omit(row), collapse = "_"))
      }
    } else {
      names(pltTbl)[which(names(pltTbl) == "plt_treat_heat")] <- "plt_treat"
    }
        
    # filling
    plt_cols <- c(plt_cols, "plt_treat")
    for (j in seq_along(plt_cols)) {
      x[[plt_cols[j]]] <- pltTbl[[plt_cols[j]]][ix]
    }
    
    # parse date/time
    if (!any(is.POSIXct(x[[dateName]]) | is.Date(x[[dateName]]))) {
      x[[dateName]] <- parse_date_time(x[[dateName]], orders = orders[[i]], tz = time_zone, truncated = 6) 
    }
    
    if (dateName != "date") {
      names(x)[match(dateName, names(x))] <- "date"
    }
    
    x
    })
}

## summarize fx
difSum.ts.fx <- function(dat_in, id_col_nms = "plt_name", dat_col_nm, paired = FALSE) {
  
  dpt_col_nms <- names(dat_in)[grep("depth", names(dat_in))]
  
  # function for calculating differences
  ctl.dif.fx <- function(df) {
    ix.ctl <- grep("control", names(df))
    ix.trt <- grep("treatment", names(df))
    # code for dealing with differences among additional treatments
    if (length(ix.ctl) > 1) {
      grps <- unique(sapply(names(df)[c(ix.ctl, ix.trt)], function(x) sub("^[^_]+_", "", x)))
      ls <- lapply(seq_along(grps), function(g) {
        base_df <- df[, -c(ix.ctl, ix.trt)]
        grp <- cbind(base_df, df[ , grepl(grps[g], names(df))])
        iix.ctl <- grep("control", names(grp))
        iix.trt <- grep("treatment", names(grp))
        dif <- lapply(iix.trt, function(ix) grp[, ix] - grp[, iix.ctl])
        dif.df <- cbind(grp, as.data.frame(dif))
        names(dif.df)[(ncol(grp) + 1):ncol(dif.df)] <- paste0(names(dif.df)[iix.trt], " - control")
        dif.df
      })
      Reduce(function(x, y) merge(x, y, all = TRUE), ls)
    } else {
     nc <- ncol(df)
     dif <- lapply(ix.trt, function(ix) df[, ix] - df[, ix.ctl])
     for (i in seq_along(dif)) {
      df <- cbind(df, dif[i])
     }
     names(df)[(nc + 1):ncol(df)] <- paste0(names(df)[ix.trt], " - control") 
     df
    }
  }

  # est. trt-ctl difs by plot pairs & summarize
  if (paired) {
   dat <- dat_in %>%
    select(date, plt_treat, matches(id_col_nms), contains("depth"), matches(dat_col_nm)) %>%
    filter(!is.na(!! sym(dat_col_nm)))%>%
    pivot_wider(
      id_cols = c(date, names(dat_in)[match(id_col_nms, names(dat_in))], names(dat_in)[grep("depth", names(dat_in))]), 
      names_from = plt_treat,
      names_sort = TRUE,
      values_from = dat_col_nm,
      values_fn = mean) %>%
    ctl.dif.fx()
   
   # index dif. cols
   ix.dif <- grep("- control", names(dat))
   
   # summarize trt-ctl dif. by paired plot, depth, day
   plt_sum <- dat %>%
     mutate(dateDay = date(date)) %>%
     group_by(dateDay, pick(dpt_col_nms), pick(id_col_nms)) %>%
     summarize(
       across(.cols = names(dat)[ix.dif], .fns = list(mean = ~ mean(.x, na.rm = T), sd = ~ sd(.x, na.rm = T))), .groups = "drop") %>%
     pivot_longer(
        cols = matches("_mean") | matches("_sd"), 
        names_to = "dif", 
        values_to = "data") %>%
      mutate(
        stat = case_when(
          str_detect(dif, "_mean$") ~ "mean",
          str_detect(dif, "_sd$") ~ "sd",
          TRUE ~ NA_character_)) %>%
      mutate(dif = str_remove(dif, "_mean$"),
             dif = str_remove(dif, "_sd$")) 
   
   # summarize trt-ctl dif. by day, depth 
   sit_sum <- dat %>%
    mutate(dateDay = date(date)) %>%
    group_by(dateDay, pick(all_of(dpt_col_nms))) %>%
    summarize(
      across(.cols = names(dat)[ix.dif], .fns = list(mean = ~ mean(.x, na.rm = T), sd = ~ sd(.x, na.rm = T))), .groups = "drop") %>%
    pivot_longer(
      cols = matches("_mean") | matches("_sd"), 
      names_to = "dif", 
      values_to = "data") %>%
      mutate(
        stat = case_when(
          str_detect(dif, "_mean$") ~ "mean",
          str_detect(dif, "_sd$") ~ "sd",
          TRUE ~ NA_character_)) %>%
      mutate(dif = str_remove(dif, "_mean$"),
             dif = str_remove(dif, "_sd$"))
   
  } else {
    
    # est. trt-ctl difs by site & summarize
    dat <- dat_in %>%
      group_by(date, pick(all_of(dpt_col_nms)), plt_treat) %>%
      summarize(
        across(
          .cols = names(dat_in)[grep(dat_col_nm, names(dat_in))],
          .fns = ~ mean(.x, na.rm = TRUE)), .groups = "drop") %>%
      pivot_wider(
        names_from = plt_treat,
        values_from = dat_col_nm) %>%
      ctl.dif.fx
    
    # index dif. cols
    ix.dif <- grep("- control", names(dat))
    
    # summarize site mean trt-ctl dif. by day 
    sit_sum <- dat %>% 
      mutate(dateDay = date(date)) %>%
      group_by(dateDay, pick(all_of(dpt_col_nms))) %>%
      summarize(
        across(
          .cols = names(dat)[ix.dif],
          .fns = list(mean = ~ mean(.x, na.rm = TRUE), 
                      sd = ~ sd(.x, na.rm = TRUE), 
                      n = ~ n()), 
          .names = "{.col}_{.fn}"), .groups = "drop") %>%
      rowwise() %>%
      mutate(
        across(
          ends_with("_sd"),
          ~ . / sqrt(get(sub("_sd$", "_n", cur_column()))),
          .names = "{sub('_sd$', '', .col)}_se"),
        across(
          ends_with("_mean"),
          ~ . - qt(1 - (0.05 / 2), df = get(sub("_mean$", "_n", cur_column()))) * get(sub("_mean$", "_se", cur_column())),
          .names = "{sub('_mean$', '', .col)}_ci.05"),
        across(
          ends_with("_mean"),
          ~ . + qt(1 - (0.05 / 2), df = get(sub("_mean$", "_n", cur_column()))) * get(sub("_mean$", "_se", cur_column())),
          .names = "{sub('_mean$', '', .col)}_ci.95")) %>%
      ungroup() %>%
      select(dateDay, contains("depth"), contains("_mean"), contains("_sd"), contains("_ci.")) %>%
      pivot_longer(
        cols = contains("- control"),
        names_to = c("dif", ".value"),
        names_pattern = "^(.*)_(.*)$")
    plt_sum <- NULL
  }
  
  list(subDaily = dat, dailyPlt = plt_sum, dailySit = sit_sum)
}

plt.fx <- function(expName, sum.ls, dat_bks, dat_lbs, DIF = "all", subtitle = NULL, facet_col = "dif", units = "pct", VAR = "VWC", datType = "soil moisture", ...) {
  
  arg.fx <- function(x, ...) {
    if (DIF != "all") {
      x <- x %>% slice(grep(DIF, x$dif))
    }
    if (length(grep("depth", names(x))) == 2) {
      x <- x %>% mutate(depth = mean(c(depth_upper, depth_lower)))
    }
    if (units != "pct") {
      x <- x %>%
        filter(x$mean < 1) %>%
        mutate(across(c(mean, contains("ci.")), .fns = ~ .x * 100))
    } else {
      x <- x %>%
        filter(x$mean < 100)
    }
  }
  
  dayMean <- arg.fx(sum.ls$dailySit) %>%
    filter(!is.na(mean))

  if (is.null(sum.ls$dailyPlt)) {
      min.mean <- min(dayMean$mean, na.rm = T)
      max.mean <- max(dayMean$mean, na.rm = T)
      p <- dayMean %>%
        mutate(col = ifelse(mean > 0, "#1db565", "#b5651d")) %>%
        ggplot(., aes(dateDay, mean)) +
        geom_hline(aes(yintercept = 0), linetype = "dotted") +
        geom_ribbon(aes(ymin = ci.05, ymax = ci.95), alpha = .2) +
        geom_point(aes(color = col), size = .1) +
        scale_color_manual(
          name = "",
          values = c("#1db565", "#b5651d"),
          labels = c("#1db565" = "> 0", "#b5651d" = "< 0")) +
        scale_x_date(breaks = dat_bks, date_labels = dat_lbs) +
        coord_cartesian(ylim = c(min.mean + .1 * min.mean, max.mean + .1 * max.mean)) +
        labs(
          y = paste0(VAR, " (trt - ctl)"),
          title = paste0(expName, ": ", datType)) +
        theme_bw() +
        theme(panel.grid = element_blank(),
              axis.title.x = element_blank(),
              text = element_text(size = 18))
      if (any("depth" %in% names(dayMean))) {
        p <- p + facet_grid(rows = vars(depth), cols = vars(!! sym(facet_col)))
      } else {
        p <- p + facet_grid(cols = vars(!! sym(facet_col)))
      }
      if (!is.null(subtitle)) {
        p + labs(subtitle = subtitle)
      } 
      p
    } else {
      p <- arg.fx(sum.ls$dailyPlt) %>%
        filter(stat == "mean") %>%
        filter(!is.na(data)) %>%
        mutate(col = ifelse(data < 0, "#b5651d", "#1db565")) %>%
        ggplot(., aes(dateDay, data)) +
        geom_path(aes(group = plt_rep, color = col), alpha = .2) +
        geom_point(
          data = dayMean,
          aes(dateDay, data), size = .1) +
        scale_color_manual(
          name = "",
          values = c("#1db565", "#b5651d"),
          labels = c("#1db565" = "> 0", "#b5651d" = "< 0")) +
        scale_x_date(breaks = dat_bks, date_labels = dat_lbs) +
        labs(
          y = paste0(VAR, " (trt - ctl)"),
          title = paste0(expName, ": ", datType)) +
        facet_grid(rows = vars(depth), cols = vars(!! sym(facet_col))) +
        theme_bw() +
        theme(panel.grid = element_blank(),
              axis.title.x = element_blank(),
              text = element_text(size = 18))
      if (!is.null(subtitle)) {
        p + labs(subtitle = subtitle)
      } else {
        p
      }
    }
}

plt_treat.fx <- function(expName, subDaily, subtitle = NULL, units = "pct", VAR = "VWC", datType = "soil moisture", window_size = NULL, by_site = FALSE, dat_bks, dat_lbs, avg = "daily", err = "ci",...) {
  
  # drop dif col/s
  x <- subDaily[ , which(!grepl("-", names(subDaily)))]
  
  if (length(grep("depth", names(subDaily))) == 2) {
    x <- x %>% mutate(depth = mean(c(depth_upper, depth_lower)))
  }
  if (units != "pct") {
    x <- x %>%
      mutate(
        across(c(contains("control"), contains("treatment")), .fns = ~ .x * 100))
  }
  
  # Dynamically capture all variable columns
  value_columns <- select(x, c(starts_with("con"), starts_with("tre"))) %>% colnames()
  
  # check periodicity
  if (length(which(is.na(x$date))) > 0) {
    x <- x[-which(is.na(x$date)), ]
  }
  pdcty <- x %>%
    filter(depth == unique(depth)[1]) %>%
    select(date) %>%
    periodicity()
  
  # list wrapper
  ls.wrap <- function(x, fx, ...) {
    if (inherits(x, "list")) {
      bind_rows(lapply(x, fx, ...), .id = "sit_name")
    } else {
      fx(x, ...)
    }
  }
  
  # daily summary fx
  dy_avg.fx <- function(data, err = err) {
    data <- data %>% 
      mutate(dateDay = date(date)) %>%
      group_by(dateDay, depth) %>%
      summarize(
        across(
          .cols = all_of(value_columns),
          .fns = list(mean = ~ mean(.x, na.rm = TRUE), 
                      sd = ~ sd(.x, na.rm = TRUE), 
                      n = ~ n()), 
          .names = "{.col}_{.fn}"), .groups = "drop") 
    if (err == "ci") { 
      data <- data %>%
        rowwise() %>%
        mutate(
          across(
            ends_with("_sd"),
            ~ . / sqrt(get(sub("_sd$", "_n", cur_column()))),
            .names = "{sub('_sd$', '', .col)}_se"),
          across(
            ends_with("_mean"),
            ~ . - qt(1 - (0.05 / 2), df = get(sub("_mean$", "_n", cur_column()))) * get(sub("_mean$", "_se", cur_column())),
            .names = "{sub('_mean$', '', .col)}_ci.05"),
          across(
            ends_with("_mean"),
            ~ . + qt(1 - (0.05 / 2), df = get(sub("_mean$", "_n", cur_column()))) * get(sub("_mean$", "_se", cur_column())),
            .names = "{sub('_mean$', '', .col)}_ci.95")) %>%
        ungroup() %>%
        select(dateDay, contains("depth"), contains("_mean"), contains("_ci.")) 
    } else {
      data <- data %>%
        select(dateDay, contains("depth"), contains("_mean"), contains("_sd"))
    }
    
    data %>%
      pivot_longer(
        cols = contains("_"),
        names_to = c("plot", ".value"),
        names_pattern = "^(.*)_(.*)$") %>%
      rename(date = dateDay) %>%
      mutate(date = as.Date(date, format = "%Y-%m-%d"))
  }
  
  # moving average function; window_size is relative to time series frequency
  mv_avg.fx <- function(data, window_size, err = err) {
    data <- data %>%
      group_by(depth) %>%
      mutate(
        # Calculate moving averages for each data column dynamically
        across(all_of(value_columns), 
               ~ rollapply(., width = window_size, FUN = mean, na.rm = TRUE, partial = TRUE, fill = NA, align = "center"), 
               .names = "{.col}_moving_avg"),
        
        # Calculate moving standard deviations for each data column dynamically
        across(all_of(value_columns), 
               ~ rollapply(., width = window_size, FUN = sd, fill = NA, align = "center"), 
               .names = "{.col}_moving_sd")) %>%
      ungroup() 
    if (err == "ci") {
      # Calculate 95% confidence intervals (CI)
      data %>%
        mutate(
          across(
            ends_with("_moving_avg"), 
            list(
              ci.05 = ~ . - 1.96 * get(gsub("_moving_avg", "_moving_sd", cur_column())),
              ci.95 = ~ . + 1.96 * get(gsub("_moving_avg", "_moving_sd", cur_column()))))) %>%
        # Drop original observation columns and their moving averages
        select(-all_of(value_columns), -contains("sd")) %>%
        # Pivot to long format (only keeping moving averages and CI)
        pivot_longer(cols = contains("moving_avg"),
                     names_to = c("plot", ".value"),
                     names_sep = "_moving_") %>%
        rename(mean = avg, ci.05 = avg_ci.05, ci.95 = avg_ci.95)
    } else {
      data %>%
        select(-all_of(value_columns)) %>%
        # Pivot to long format (only keeping moving averages and CI)
        pivot_longer(cols = contains("moving"),
                     names_to = c("plot", ".value"),
                     names_sep = "_moving_") %>%
        rename(mean = avg)
    }
  }
  
  if (by_site) {
    facet_col <- sym("sit_name")
    x <- lapply(split(x, x$sit_name), function(y) {y$sit_name <- NULL; y})
  } else {
    facet_col <- NULL
  }
  
  if (avg == "moving") {
    if (is.null(window_size)) stop("\nwindow_size must be specified if avg = 'moving'\n")
    data <- ls.wrap(x, mv_avg.fx, window_size = window_size, err = err)
  } else {
      
    if (pdcty$label == "second" | pdcty$label == "minute" | pdcty$label == "hour") {
      data <- ls.wrap(x, dy_avg.fx, err = err)
    } else {
      data <- x %>%
        drop_na(all_of(value_columns)) %>% 
        pivot_longer(cols = all_of(value_columns),
                     names_to = c("plot"),
                     values_to = "mean") %>%
        mutate(ci.05 = as.numeric(NA), ci.95 = as.numeric(NA), date = as.Date(date, format = "%Y-%m-%d"))
    }
  }
  
  # create plotting df
  p.df <- data %>%
    mutate(
      deg_heat = round(ifelse(plot == "control", 0, as.numeric(str_extract(plot, "(\\d+)"))), 0),
      group = paste0(plot, depth)
    )
  
  # get color ramp
  htvl <- seq(0, 9)
  cols <- c("#0000ff", heat.colors(9))
  
  # check ylim
  if (err == "ci") {
    ymax <- max(p.df$ci.95, na.rm = TRUE)
    ymin <- min(p.df$ci.05, na.rm = TRUE) 
  } else {
    ymax <- max(p.df$mean + p.df$sd, na.rm = TRUE)
    ymin <- min(p.df$mean - p.df$sd, na.rm = TRUE) 
  }
  if (ymax == -Inf) {
    ymax <- max(p.df$mean, na.rm = TRUE)
  } else if (ymax > 100) {
    ymax = 100
  }
  if (ymin == Inf) {
    ymin <- min(p.df$mean, na.rm = TRUE)
  } else if (ymin < 0) {
    ymin <- 0
  }
  
  # plot
  p <- ggplot(p.df, aes(x = date, y = mean, group = group)) +
    geom_line(aes(color = deg_heat), size = .8) +
    scale_color_gradientn(colors = cols, values = scales::rescale(htvl, from = c(0, 9)), limits = c(0, 9)) +
    scale_fill_gradientn(colors = cols, values = scales::rescale(htvl, from = c(0, 9)), limits = c(0, 9)) +
    facet_grid(rows = vars(depth), cols = vars(!! facet_col)) +
    guides(fill = "none") +
    scale_y_continuous(limits = c(ymin, ymax)) +
    labs(
      y = VAR,
      title = paste0(expName, ": ", datType)) +
    theme_bw() +
    theme(panel.grid = element_blank(),
          axis.title.x = element_blank(),
          text = element_text(size = 18))
  if (err == "ci") {
    p <- p +
      geom_ribbon(
        aes(ymin = ci.05, ymax = ci.95, fill = deg_heat),
        alpha = 0.2)
  } else {
    p <- p +
      geom_ribbon(
        aes(ymin = mean - sd, ymax = mean + sd, fill = deg_heat),
        alpha = 0.2)
  }
  if (any(grepl("POSIXct", class(p.df$date))))  {
    p + scale_x_datetime(date_breaks = dat_bks, date_labels = dat_lbs)
  } else {
    p + scale_x_date(date_breaks = dat_bks, date_labels = dat_lbs)
  }
}
```

#### load SM

```{r read-moist-data, eval=FALSE}
expName.ls <- list.files("../data/experiments")

moist.ls <- setNames(vector(mode = "list", length = length(expName.ls)), nm = expName.ls)

chkNms <- function(expName, ls) {
  lapply(ls[[expName]], function(x) unique(x$plt_name) %in% database[[expName]]$plot$plt_name)
}

# 185Exp
moist.ls$`185ExperimentStation` <- list(read.csv( "../data/experiments/185ExperimentStation/input_data/datafile_soilW.csv"))


# Achenkirch
## read soil moisture data
moist.ls$Achenkirch <- list(
  read.csv( "../data/experiments/Achenkirch/input_data/soil_moist_manual..Vol...csv"))
## strip out non-heating period & NA vals
ACHN.heat <- read.csv("../data/experiments/Achenkirch/input_data/heating.on.off.csv")
moist.ls$Achenkirch[[1]] <- merge(
  moist.ls$Achenkirch[[1]],
  ACHN.heat) %>%
  filter(heating.on.off == "on") %>%
  filter(!is.na(soil_moist_manual..Vol..))


# ACBB
moist.ls$ACBB <- list(
  cropland = read.csv("../data/experiments/ACBB/input_data/moist_C.csv"),
  grassland = read.csv("../data/experiments/ACBB/input_data/moist_G.csv"))


# B4W
moist.ls$B4WarmED <- list(
  cloquet = read.csv("../data/experiments/B4WarmED/input_data/clq_soilMoisture_2012.2023.csv"),
  ely = read.csv("../data/experiments/B4WarmED/input_data/ely_soilMoisture_2012.2023.csv")
)


# Blodgett
moist.ls$Blodgett <- list(read.csv("../data/experiments/Blodgett/input_data/20240125_processed Blodgett soil moisture.csv"))

# fix mislabeling of plot 7 "trt
moist.ls$Blodgett[[1]][moist.ls$Blodgett[[1]][["PP"]] == 7, "trt"] <- "C" 

# add plt_name to link to plot table
moist.ls$Blodgett[[1]][["plt_name"]] <- paste0(ifelse(moist.ls$Blodgett[[1]][["trt"]] == "H", "treatment", "control"), "_",  moist.ls$Blodgett[[1]][["PP"]])

# remove data from plot 'ambient' and select relevant columns
moist.ls$Blodgett[[1]] <- moist.ls$Blodgett[[1]][-which(moist.ls$Blodgett[[1]][["PP"]] == "ambient"), c("TIMESTAMP", "plt_name", "moisture", "depth")] %>%
  rename(date = TIMESTAMP)

# check for matches w/ plt_name and plt_name
chkNms("Blodgett", moist.ls)

# convert dates and select allowable cols
moist.ls$Blodgett[[1]][["date"]] <- parse_date_time(moist.ls$Blodgett[[1]][["date"]], orders = "%y-%m-%d %H:%M:%S", tz = "America/Los_Angeles")


# CiPEHR
moist.ls$CiPEHR <- list(
  read.csv("../data/experiments/CiPEHR/input_data/flux_hh.csv"))
moist.ls$CiPEHR[[1]] <- moist.ls$CiPEHR[[1]] %>%
  filter(!is.na(vwc)) %>%
  mutate(
    depth_upper = 0,
    depth_lower = 15,
    plt_name = paste0(
      ifelse(treatment == "Air Warming", "control_summerWarm",
             ifelse(treatment == "Control", "control_",
                    ifelse(treatment == "Soil Warming", "treatment_", "treatment_summerWarm"))), "_", block, "_", fence, "_", plot)) %>%
  select(ts, plt_name, depth_upper, depth_lower, vwc) %>%
  rename(date = ts)



# FutureClim
moist.ls$FutureClim <- list(
  read.csv("../data/experiments/FutureClim/input_data/VWC.csv"))


# Harvard Forest
moist.ls$HarvardForest <- list(read.csv("../data/experiments/HarvardForest/input_data/hf005-07-soil-moisture_PH.csv"))

# pivot longer, add depths, and select cols
moist.ls$HarvardForest[[1]] <- moist.ls$HarvardForest[[1]] %>%
  pivot_longer(cols = 2:19, names_to = "plot", values_to = "vwc") %>%
  mutate(
    depth_upper = 0, 
    depth_lower = 30, 
    plt_name = sapply(strsplit(plot, "_"), "[[", 1)) %>%
  select("date", "plt_name", "depth_upper", "depth_lower", "vwc")


# KAEFS (rename cols)
moist.ls$KAEFS <- lapply(list(read.csv("../data/experiments/KAEFS/input_data/SoilMoisture2018-2023_reshapeLong.csv")), function(x) x %>%
  rename(date = Timestamp, plt_name = plotID))


# Sanming
moist.ls$Sanming <- list(read.csv("../data/experiments/Sanming/input_data/TRL_MOIS_2024.csv"))


# SPRUCE
moist.ls$SPRUCE <- lapply(list.files("../data/experiments/SPRUCE/input_data", pattern = "l.csv", full.names = TRUE)[2:8], read.csv)
names(moist.ls$SPRUCE) <- paste0("soil_", seq(2017, 2023))

# Notes: 1) VWC missing from "soil_2016"; 2) these files also contain a "treatment status" column, as well as temp, H2O table, air T, rel. humid, and precip; 3) depth is relative to mean hollow elevation, so challenging to compare to other systems...

# pivot longer & remove missing data
moist.ls$SPRUCE <- lapply(moist.ls$SPRUCE, function(x) {
  x <- x %>%
    select(Timestamp, Plot, contains("VWC"))
  ix.dif <- which(grepl("VWC", names(x)))
  names(x)[ix.dif] <- sapply(
    lapply(strsplit(names(x)[ix.dif], "_"), "[[", 2), function(x) paste0(substr(x, 1, 1), "_", substr(x, 2, 2)))
  x %>%
    pivot_longer(cols = 3:8, names_sep = "_", names_to = c("rep", "depth"), values_to = "vwc") %>%
    filter(vwc != -9999) %>%
    mutate(depth = ifelse(depth == "1", 8, 20)) %>%
    rename(replicates = rep, plt_name = Plot, date = Timestamp)
})


# SWAMP
moist.ls$SWAMP <- list(
  read.csv("../data/experiments/SWAMP/input_data/soilMoist.csv"))


# SWELTR
moist.ls$SWELTR <- list(read.csv("../data/experiments/SWELTR/input_data/SWELTR_to2020_T_H2O.csv"))
moist.ls$SWELTR[[1]] <- moist.ls$SWELTR[[1]] %>% mutate(plt_name = paste0(PLOT, "_", TREAT)) %>%
  rename(depth = DEPTH, date = TIME) %>%
  select(date, plt_name, depth, H2O)

# note this file contains temp data as well


# TEAM
moist.ls$TEAM <- list(read.csv("../data/experiments/TEAM/input_data/moist.csv"))
moist.ls$TEAM[[1]] <- moist.ls$TEAM[[1]] %>%
  rename(plt_name = plot, date = time)


# TeRaCON
moist.ls$TeRaCON <- list(
  sentek = read.csv("../data/experiments/TeRaCON/input_data/sentek_vwc_2019-2023.csv"), 
  tdr = read.csv("../data/experiments/TeRaCON/input_data/vwc_tdr_2012-2023.csv"))


# TRACE
moist.ls$TRACE <- list(
  read.csv("../data/experiments/TRACE/input_data/TRACE_VWC_2016-2018.csv"))

# remove NULL
moist.ls <- Filter(Negate(is.null), moist.ls)
```

#### dif SM

```{r moist-ts-dif, eval=FALSE}
# 185ExperimentStation
e185.sm.ls <- filPltTbl.fx(moist.ls, "185ExperimentStation", orders = "mdy HM")
# fix NA values and convert to numeric
e185.sm.ls[[1]][["soil.moisture"]] <- as.numeric(ifelse(e185.sm.ls[[1]][["soil.moisture"]] == "#N/A", NA, e185.sm.ls[[1]][["soil.moisture"]]))
# remove values > 1 [assuming soil moisture is expressed as a proportion?]
e185.sm.ls[[1]] <- e185.sm.ls[[1]][which(e185.sm.ls[[1]][["soil.moisture"]] < 1), ]
e185.sm.sum.ls <- difSum.ts.fx(
  e185.sm.ls[[1]],
  dat_col_nm = "soil.moisture")
# plt.fx("185ExperimentStation", e185.sm.sum.ls, "1 year", "%b", units = "ppn")
# plt_treat.fx("185ExperimentStation", e185.sm.sum.ls$subDaily, dat_bks = "1 year", dat_lbs = "%Y", window_size = 24*7, avg = "moving")
# plt_treat.fx("185ExperimentStation", e185.sm.sum.ls$subDaily, dat_bks = "1 year", dat_lbs = "%Y")

# ACBB
ACBB.sm.ls <- filPltTbl.fx(moist.ls, "ACBB", orders = "mdy HM")
ACBB.sm.sum.ls <- setNames(lapply(ACBB.sm.ls, function(x) {
  difSum.ts.fx(x, dat_col_nm = "data")
}), nm = names(moist.ls$ACBB))
ACBB.sm.sum.ls2 <- setNames(
  lapply(names(ACBB.sm.sum.ls[[1]]), function(name) {
    # Extract the elements corresponding to 'name' from all sublists in ACBB.sm.sum.ls
    elements <- lapply(seq_along(ACBB.sm.sum.ls), function(i) {
      element <- ACBB.sm.sum.ls[[i]][[name]]
      # Add the sit_name column with the name of the current sublist
      if (!is.null(element)) {
        element$sit_name <- names(ACBB.sm.sum.ls)[i]
        element 
      } else {
        NULL
      }
    })
    
    # Combine all elements by row
    do.call(rbind, elements)
  }), nm = names(ACBB.sm.sum.ls[[1]])) 
# plt.fx("ACBB", ACBB.sm.sum.ls2, "1 year", "%Y", facet_col = "sit_name", units = "pct")
# plt_treat.fx("ACBB", ACBB.sm.sum.ls2$subDaily, dat_bks = "3 months", dat_lbs = "%b%y", window_size = 3*48, by_site = TRUE, avg = "moving")
# plt_treat.fx("ACBB", ACBB.sm.sum.ls2$subDaily, dat_bks = "3 months", dat_lbs = "%b%y", by_site = TRUE)


# Achenkirch
Achn.sm.ls <- filPltTbl.fx(moist.ls, "Achenkirch", orders = "ymd")
Achn.sm.sum.ls <- difSum.ts.fx(
  Achn.sm.ls[[1]],
  dat_col_nm = "soil_moist_manual..Vol..")
# plt.fx("Achenkirch", Achn.sm.sum.ls, "1 year", "%Y", units = "pct")
# plt_treat.fx("Achenkirch", Achn.sm.sum.ls$subDaily, dat_bks = "1 year", dat_lbs = "%Y", window_size = 1, avg = "moving")
# plt_treat.fx("Achenkirch", Achn.sm.sum.ls$subDaily, dat_bks = "1 year", dat_lbs = "%Y")


# B4W
## additional treatment "canopy" will be treated as a subsite within each site
B4WM.sm.ls <- filPltTbl.fx(moist.ls, "B4WarmED", orders = "ymd HMS", heat_only = FALSE)
B4WM.sm.ls2 <- lapply(B4WM.sm.ls, function(df) {
  df <- df[which(df$water_treatment != "excluded"), ] 
  grps <- unique(sub("^[^_]+_", "", df$plt_treat))
  lapply(grps, function(g) {
    df <- df[grepl(g, df$plt_treat), ]
    df$plt_treat <- sub(paste0("_", g), "", df$plt_treat)
    df
  })
})
B4WM.sm.open.ls <- lapply(B4WM.sm.ls2, function(x) x[[2]])
B4WM.sm.clsd.ls <- lapply(B4WM.sm.ls2, function(x) x[[1]])
B4WM.sm.open.sum.ls <- setNames(lapply(B4WM.sm.open.ls, function(x) {
  difSum.ts.fx(x, dat_col_nm = "vwc")
}), nm = names(moist.ls$B4WarmED))
B4WM.sm.clsd.sum.ls <- setNames(lapply(B4WM.sm.clsd.ls, function(x) {
  difSum.ts.fx(x, dat_col_nm = "vwc")
}), nm = names(moist.ls$B4WarmED))

getLsNms <- function(ls) {
   setNames(
    lapply(names(ls[[1]]), function(name) {
      # Extract the elements corresponding to 'name' from all sublists in ls
      elements <- lapply(seq_along(ls), function(i) {
        element <- ls[[i]][[name]]
        # Add the sit_name column with the name of the current sublist
        if (!is.null(element)) {
          element$sit_name <- names(ls)[i]
          element 
        } else {
          NULL
        }
      })
      # Combine all elements by row
      do.call(rbind, elements)
    }), nm = names(ls[[1]]))
}
B4WM.clq.opn.sm.sum.ls <- lapply(
  getLsNms(B4WM.sm.open.sum.ls), function(x) if (!is.null(x)) x %>% filter(sit_name == "cloquet") %>% mutate(sit_name = paste0(sit_name, "_", "open")))
B4WM.ely.opn.sm.sum.ls <- lapply(
  getLsNms(B4WM.sm.open.sum.ls), function(x) if (!is.null(x)) x %>% filter(sit_name == "ely") %>% mutate(sit_name = paste0(sit_name, "_", "open")))
B4WM.clq.cls.sm.sum.ls <- lapply(
  getLsNms(B4WM.sm.clsd.sum.ls), function(x) if (!is.null(x)) x %>% filter(sit_name == "cloquet") %>% mutate(sit_name = paste0(sit_name, "_", "closed")))
B4WM.ely.cls.sm.sum.ls <- lapply(
  getLsNms(B4WM.sm.clsd.sum.ls), function(x) if (!is.null(x)) x %>% filter(sit_name == "ely") %>% mutate(sit_name = paste0(sit_name, "_", "closed")))
# combine all
B4WM.sm.sum.ls <- Reduce(function(x, y) mapply(rbind, x, y, SIMPLIFY = FALSE), list(B4WM.clq.opn.sm.sum.ls, B4WM.ely.opn.sm.sum.ls, B4WM.clq.cls.sm.sum.ls, B4WM.ely.cls.sm.sum.ls))

# plt.fx("B4WarmED", B4WM.clq.sm.sum.ls, "1 year", "%Y", facet_col = "sit_name", units = "ppn")
# plt.fx("B4WarmED", B4WM.ely.sm.sum.ls, "1 year", "%Y", facet_col = "sit_name", units = "ppn")
# plt_treat.fx("B4WarmED", B4WM.sm.sum.ls2$subDaily, dat_bks = "1 year", dat_lbs = "%Y", units = "ppn", by_site = TRUE, avg = "moving", window_size = 24*30)
# plt_treat.fx("B4WarmED", B4WM.sm.sum.ls2$subDaily, dat_bks = "1 year", dat_lbs = "%Y", units = "ppn", by_site = TRUE)
# B4WM.sm.sum.ls2$subDaily %>%
#   filter(date > as.Date("2020-04-01") & date < as.Date("2020-10-01")) %>%
#   plt_treat.fx("B4WarmED", ., dat_bks = "1 month", dat_lbs = "%b", units = "ppn", by_site = TRUE)
# code for plotting raw ctl/trt data averaged by day
# B4WM.sm.sum.ls$subDaily %>%
#   filter(date > as.POSIXct("2020-01-01", format = "%Y-%m-%d")) %>%
#   mutate(date = as.Date(date)) %>%
#   group_by(date, sit_name, depth) %>%
#   summarize(
#     across(c(control, contains("treatment")), 
#            ~ mean(.x, na.rm = TRUE)),
#     .groups = "drop") %>%
#   plt_treat.fx("B4WarmED", ., dat_bks = "1 year", dat_lbs = "%Y", units = "ppn", by_site = TRUE, avg = "moving", window_size = 7 * 30)

# Blodgett
Bldg.sm.ls <- filPltTbl.fx(moist.ls, "Blodgett", orders = "ymd HMS")
Bldg.sm.sum.ls <- difSum.ts.fx(
  Bldg.sm.ls[[1]],
  dat_col_nm = "moisture")
# plt.fx("Blodgett", Bldg.sm.sum.ls, "1 year", "%Y", units = "ppn")
# plt_treat.fx("Blodgett", Bldg.sm.sum.ls$subDaily, dat_bks = "1 year", dat_lbs = "%Y")


# CiPEHR
# remove "Z" at end of date strings
moist.ls$CiPEHR[[1]][["date"]] <- substr(moist.ls$CiPEHR[[1]][["date"]], 1, nchar(moist.ls$CiPEHR[[1]][["date"]])-1)
CPHR.sm.ls <- filPltTbl.fx(moist.ls, "CiPEHR", plt_cols = c("plt_block", "plt_subBlock", "plt_rep"), orders = "ymd HMS")
CPHR.sm.sum.ls <- difSum.ts.fx(
  CPHR.sm.ls[[1]],
  id_col_nms = c("plt_block", "plt_subBlock", "plt_rep"),
  dat_col_nm = "vwc")
# plt.fx("CiPEHR", CPHR.sm.sum.ls, "1 year", "%Y")
# plt_treat.fx("CiPEHR", CPHR.sm.sum.ls$subDaily, dat_bks = "1 year", dat_lbs = "%Y", window_size = 7*48)
 

# FutureClim
FCLM.sm.ls <- filPltTbl.fx(moist.ls, "FutureClim", orders = "dmy HM", dateName = "Timestamp", plt_cols = "plt_name", time_zone = "Australia/Sydney")
FCLM.sm.sum.ls <- difSum.ts.fx(
  FCLM.sm.ls[[1]],
  id_col_nms = "plt_name",
  dat_col_nm = "VWC")
# plt.fx("FutureClim", FCLM.sm.sum.ls, "3 months", "%b%y", units = "ppn")
# plt_treat.fx("FutureClim", FCLM.sm.sum.ls$subDaily, dat_bks = "3 months", dat_lbs = "%b%Y", unit = "ppn")
# plt_treat.fx("FutureClim", FCLM.sm.sum.ls$subDaily, dat_bks = "3 months", dat_lbs = "%b%Y", unit = "ppn", window_size = 30, avg = "moving")
# FCLM.sm.sum.ls$subDaily %>%
#   mutate(
#     heat_on = ifelse(date > ymd("2023-07-03") & date < ymd("2023-09-01"), 0,
#                                     ifelse(date > ymd("2024-05-10") & date < ymd("2024-09-18"), 0, 1))) %>%
#   filter(heat_on == 1) %>%
#   plt_treat.fx("FutureClim", ., dat_bks = "3 months", dat_lbs = "%b%Y", unit = "ppn")

# Harvard Forest
HRVF.sm.ls <- filPltTbl.fx(moist.ls, "HarvardForest", plt_cols = c("plt_rep", "plt_block"), orders = "ymd")
HRVF.sm.sum.ls <- difSum.ts.fx(
  HRVF.sm.ls[[1]],
  id_col_nms = c("plt_block", "plt_rep"),
  dat_col_nm = "vwc")
# plt.fx("Harvard Forest", HRVF.sm.sum.ls, "1 year", "%Y", units = "ppn")
# plt_treat.fx("Harvard Forest", HRVF.sm.sum.ls$subDaily, dat_bks = "1 year", dat_lbs = "%Y", window_size = 30, units = "ppn", avg = "moving")


# KAEFS
KAEF.sm.ls <- filPltTbl.fx(moist.ls, "KAEFS", plt_cols = c("plt_block", "plt_rep"), orders = "mdy")
KAEF.sm.sum.ls <- difSum.ts.fx(
  KAEF.sm.ls[[1]],
  id_col_nms = c("plt_block", "plt_rep"),
  dat_col_nm = "vwc_pct")
# plt.fx("KAEFS", KAEF.sm.sum.ls, "1 year", "%Y")
# plt_treat.fx("KAEFS", KAEF.sm.sum.ls$subDaily, dat_bks = "1 year", dat_lbs = "%Y")


# Sanming
SNMG.sm.ls <- filPltTbl.fx(moist.ls, "Sanming", orders = "ymd")
SNMG.sm.sum.ls <- difSum.ts.fx(
  SNMG.sm.ls[[1]],
  dat_col_nm = "mean_value")
# plt.fx("Sanming", SNMG.sm.sum.ls, "3 months", "%b")
# plt_treat.fx("Sanming", SNMG.sm.sum.ls$subDaily, dat_bks = "3 months", dat_lbs = "%b")


# SPRUCE
SPRC.sm.ls <- filPltTbl.fx(moist.ls, "SPRUCE", orders = rep("ymd HM", length(moist.ls$SPRUCE)))
SPRC.sm.sum.ls <- lapply(SPRC.sm.ls, function(x) {
  difSum.ts.fx(x, dat_col_nm = "vwc")
})
SPRC.sm.sum.ls2 <- do.call(Map, c(rbind, SPRC.sm.sum.ls))
# plt.fx("SPRUCE", SPRC.sm.sum.ls2, "1 year", "%Y")
# plt_treat.fx("SPRUCE", SPRC.sm.sum.ls2$subDaily, dat_bks = "1 year", dat_lbs = "%Y", window_size = 7*48)


# SWAMP
SWMP.sm.ls <- filPltTbl.fx(moist.ls, "SWAMP", orders = "ymd")
# block out non-growing season data (oct-mar)
test <- SWMP.sm.ls[[1]] %>%
  mutate(month = month(date)) %>%
  filter(month > 3 & month < 10) %>%
  select(-month)
SWMP.sm.sum.ls <- difSum.ts.fx(
  test,
  dat_col_nm = "vwc")
# plt.fx("SWAMP", SWMP.sm.sum.ls, "3 months", "%b")
# plt_treat.fx("SWAMP", SWMP.sm.sum.ls$subDaily, dat_bks = "3 months", dat_lbs = "%b")
# plt_treat.fx("SWAMP", SWMP.sm.sum.ls$subDaily, dat_bks = "3 months", dat_lbs = "%b", avg = "moving", window_size = 30)


# SWELTR
SWTR.sm.ls <- filPltTbl.fx(moist.ls, "SWELTR", orders = "dmy HM")
# exclude 2018 data > max of 2017 data, per A. Nottingham's notes
max.17 <- max(SWTR.sm.ls[[1]][SWTR.sm.ls[[1]][["date"]] < as.Date("2018-01-01"), "H2O"], na.rm = T)
SWTR.sm.ls[[1]][["H2O"]] <- ifelse(SWTR.sm.ls[[1]]$date > as.Date("2018-01-01") & SWTR.sm.ls[[1]]$H2O > max.17, NA, SWTR.sm.ls[[1]]$H2O)
SWTR.sm.sum.ls <- difSum.ts.fx(
  SWTR.sm.ls[[1]],
  dat_col_nm = "H2O")
# plt.fx("SWELTR", SWTR.sm.sum.ls, "4 months", "%b-%y", units = "ppn")
# plt_treat.fx("SWELTR", SWTR.sm.sum.ls$subDaily, dat_bks = "4 months", dat_lbs = "%b-%y", window_size = 30*48, units = "ppn", avg = "moving")


# TEAM
TEAM.sm.ls <- filPltTbl.fx(moist.ls, "TEAM", orders = "ymd")
TEAM.sm.sum.ls <- difSum.ts.fx(
  TEAM.sm.ls[[1]],
  dat_col_nm = "moist")
# plt.fx("TEAM", TEAM.sm.sum.ls, "1 year", "%Y", units = "ppn")
# plt_treat.fx("TEAM", TEAM.sm.sum.ls$subDaily, dat_bks = "1 year", dat_lbs = "%Y", window_size = 7*30, units = "ppn", avg = "moving")


# TeRaCON
TRCN.sm.ls <- filPltTbl.fx(moist.ls, "TeRaCON", orders = rep("ymd HMS", 2))
TRCN.sm.sum.ls <- setNames(lapply(TRCN.sm.ls, function(x) {
  difSum.ts.fx(x, dat_col_nm = "vwc")
}), nm = names(moist.ls$TeRaCON))
TRCN.sm.sum.ls.s <- TRCN.sm.sum.ls$sentek
# plt.fx("TeRaCON", TRCN.sm.sum.ls, "1 year", "%Y")
# plt_treat.fx("TeRaCON", TRCN.sm.sum.ls$sentek$subDaily, dat_bks = "1 year", dat_lbs = "%Y")
# plt_treat.fx("TeRaCON", TRCN.sm.sum.ls$tdr$subDaily, dat_bks = "1 year", dat_lbs = "%Y")

# # get on/off dates
# trcn <- TRCN.sm.sum.ls$sentek$subDaily 
# trcn$year <- year(trcn$date)
# trcn.on.off <- lapply(split(trcn, trcn$year), function(x) list(min = min(x$date), max = max(x$date)))
# TRCN.sm.sum.ls$sentek$subDaily %>%
#   filter(date > as.Date("2021-04-04", format = "%Y-%m-%d") & date < as.Date("2021-10-02", format = "%Y-%m-%d")) %>%
# plt_treat.fx("TeRaCON", ., dat_bks = "1 month", dat_lbs = "%b", avg = "moving", window_size = 7*24*4)
# TRCN.sm.sum.ls$sentek$subDaily %>%
#   filter(date > as.Date("2022-04-03", format = "%Y-%m-%d") & date < as.Date("2022-10-04", format = "%Y-%m-%d")) %>%
# plt_treat.fx("TeRaCON", ., dat_bks = "1 month", dat_lbs = "%b", avg = "moving", window_size = 7*24*4)


# TRACE
TRCE.sm.ls <- filPltTbl.fx(moist.ls, "TRACE", orders = "ymd HMS")
TRCE.sm.sum.ls <- difSum.ts.fx(
  TRCE.sm.ls[[1]],
  dat_col_nm = "vwc")
# plt.fx("TRACE", TRCE.sm.sum.ls, "1 year", "%Y")
# plt_treat.fx("TRACE", TRCE.sm.sum.ls$subDaily, dat_bks = "3 months", dat_lbs = "%b%y", avg = "moving", window_size = 30*24, units = "ppn")


# combine moisture data
moist.clean.ls <- list(
  one85ExperimentStation = e185.sm.sum.ls,
  ACBB = ACBB.sm.sum.ls2,
  Achenkirch = Achn.sm.sum.ls,
  B4WarmED = B4WM.sm.sum.ls,
  Blodgett = Bldg.sm.sum.ls,
  CiPEHR = CPHR.sm.sum.ls,
  FutureClim = FCLM.sm.sum.ls,
  HarvardForest = HRVF.sm.sum.ls,
  KAEFS = KAEF.sm.sum.ls,
  Sanming = SNMG.sm.sum.ls,
  SPRUCE = SPRC.sm.sum.ls2,
  SWAMP = SWMP.sm.sum.ls,
  SWELTR = SWTR.sm.sum.ls,
  TEAM = TEAM.sm.sum.ls,
  TeRaCON = TRCN.sm.sum.ls$tdr,
  TRACE = TRCE.sm.sum.ls
)

# write to file
saveRDS(moist.clean.ls, file = "/Users/jbeemmil@umich.edu/eco-warm/src/data/sm.clean.ls_20250916.RDS")
```

### temp dat
#### load ST

```{r read-temp-data, eval=FALSE}
temp.ls <- setNames(vector(mode = "list", length = length(expName.ls)), nm = expName.ls)

# 185Exp
temp.ls$`185ExperimentStation` <- list(read.csv( "../data/experiments/185ExperimentStation/input_data/datafile_soilT.csv"))
temp.ls$`185ExperimentStation`[[1]] <- temp.ls$`185ExperimentStation`[[1]] %>%
  rename(depth = Depth)

# ACBB
temp.ls$ACBB <- list(
  cropland = read.csv("../data/experiments/ACBB/input_data/temp_C.csv"),
  grassland = read.csv("../data/experiments/ACBB/input_data/temp_G.csv"))
temp.ls$ACBB <- setNames(lapply(seq_along(temp.ls$ACBB), function(i) {
  x <- temp.ls$ACBB[[i]]
  x$plt_name <- paste0(
    names(temp.ls$ACBB)[i], "_", ifelse(x$treat == "C", 4, 0), "_", x$plot)
  x
}), nm = c("cropland", "grassland"))

# ACBB.st.ls <- filPltTbl.fx(temp.ls, "ACBB", orders = "mdy HM", dateName = "TIMESTAMP")
# ACBB.st.sum.ls <- setNames(lapply(ACBB.st.ls, function(x) {
#   difSum.ts.fx(x, dat_col_nm = "data")
# }), nm = names(temp.ls$ACBB))
# ACBB.st.sum.ls2 <- setNames(
#   lapply(names(ACBB.st.sum.ls[[1]]), function(name) {
#     # Extract the elements corresponding to 'name' from all sublists in ACBB.sm.sum.ls
#     elements <- lapply(seq_along(ACBB.st.sum.ls), function(i) {
#       element <- ACBB.st.sum.ls[[i]][[name]]
#       # Add the sit_name column with the name of the current sublist
#       if (!is.null(element)) {
#         element$sit_name <- names(ACBB.st.sum.ls)[i]
#         element 
#       } else {
#         NULL
#       }
#     })
#     
#     # Combine all elements by row
#     do.call(rbind, elements)
#   }), nm = names(ACBB.st.sum.ls[[1]])) 
# 
# ACBB.sm.st.day.df <- merge(
#   ACBB.st.sum.ls2$dailySit, 
#   ACBB.sm.sum.ls2$dailySit,
#   by = c("dateDay", "depth", "dif", "sit_name"),
#   suffixes = c("_tempr", "_moist"))
# 
# sp.fx <- function(x, y, method, depths) {
#   sp <- spline(x, y, method = method)
#   sp.ss <- smooth.spline(sp) # convert to class "spline" with smooth.spline fxn
#   spp <- predict(sp.ss, depths) 
#   data.frame(spp)
# }
# 
# ACBB.st.df <- rbind(ACBB.st.ls[[1]], ACBB.st.ls[[2]])
# ACBB.sm.ls2 <- lapply(ACBB.sm.ls, function(x)
#   bind_rows(lapply(split(x, x$date), function(y) 
#     bind_rows(lapply(split(y, y$plt_name), function(z)
#       sp.fx(z$depth, z$data, method = "natural", depths = c(5, 15, 30, 50, 75, 100))
#       ), .id = "plt_name")), .id = "date"))
# ACBB.sm.df <- rbind(ACBB.sm.ls2[[1]], ACBB.sm.ls2[[2]]) %>%
#   rename(depth = x, data = y)
# ACBB.st.sm.df <- merge(
#   ACBB.st.df[ , names(ACBB.st.df) %in% names(ACBB.sm.df)],
#   ACBB.sm.df,
#   by = c("depth", "plt_name", "date"),
#   suffixes = c("_st", "_sm")
# )
# ACBB.st.sm.df$month <- month(ACBB.st.sm.df$date)
# ACBB.st.sm.df$plt_treat <- ifelse(grepl(0, ACBB.st.sm.df$plt_name), "control", "treatment")
# ACBB.st.sm.df$plt_rep <- substr(ACBB.st.sm.df$plt_name, nchar(ACBB.st.sm.df$plt_name), nchar(ACBB.st.sm.df$plt_name))
# ACBB.st.sm.df$sit_name <- ifelse(grepl("crop", ACBB.st.sm.df$plt_name), "cropland", "grassland")
# 
# # look at relationship between ST & SM
# ## decrease in soil moisture with increasing temperature is faster in warmed plots: soil moisture decreases by 1% for every 0.6 deg increase in soil temp in control plots, while the decrease is 1% for every 0.5 deg increase in treatment plots
# test <- ACBB.st.sm.df %>%
#   mutate(day = as.Date(date)) %>%
#   group_by(sit_name, depth, plt_treat, day) %>%
#   summarize(
#     across(contains("data"), list(mean = mean, sd = sd)), .groups = "drop") 
# test %>%
#   ggplot(., aes(data_st_mean, data_sm_mean, color = plt_treat)) + 
#   geom_smooth(method = "lm", se = F) +
#   geom_point(alpha = .1) +
#   facet_grid(cols = vars(sit_name), rows = vars(depth), scales = "free") +
#   theme_bw() +
#   theme(panel.grid = element_blank())
# summary(lm(data_sm_mean ~ data_st_mean * plt_treat + sit_name, subset(test, depth < 50)))


# Achenkirch
temp.ls$Achenkirch <- list(read.csv("../data/experiments/Achenkirch/input_data/soilTemp.csv"))
# filter out non-heating period
temp.ls$Achenkirch[[1]] <- merge(
  temp.ls$Achenkirch[[1]],
  ACHN.heat) %>%
  filter(heating.on.off == "on") %>%
  filter(!is.na(soilTemp))


# B4W
temp.ls$B4WarmED <- list(
  cloquet = read.csv("../data/experiments/B4WarmED/input_data/clq_soilTemp_2013.2022.csv"),
  ely = read.csv("../data/experiments/B4WarmED/input_data/ely_soilTemp_2013.2022.csv"))
# remove deep soil T from Ely (weird) and all data prior to Aug. 2016
temp.ls$B4WarmED <- lapply(temp.ls$B4WarmED, function(x) {
  x %>%
    filter(date > as.Date("2016-08-01", format = "%Y-%m-%d"))
})


# Blodgett
temp.ls$Blodgett <- list(
  read.csv("../data/experiments/Blodgett/input_data/20240125_processed Blodgett soil temperature.csv") %>%
    mutate(
      plt_name = paste0(ifelse(trt == "H", "treatment", "control"), "_",  PP),
      date = ymd_hms(TIMESTAMP)) %>%
    select(date, plt_name, depth, temp)
  )


# CiPEHR
temp.ls$CiPEHR <- list(
  read.csv("../data/experiments/CiPEHR/input_data/flux_hh.csv") %>%
  mutate(
    date = ymd_hms(ts),
    plt_name = paste0(
      ifelse(treatment == "Air Warming", "control_summerWarm",
             ifelse(treatment == "Control", "control_",
                    ifelse(treatment == "Soil Warming", "treatment_", "treatment_summerWarm"))), "_", block, "_", fence, "_", plot)) %>%
  select(date, plt_name, ends_with("f")) %>% 
  pivot_longer(
    cols = ends_with("f"),
    names_to = "depth",
    values_to = "soilT",
    names_pattern = "t(.*)f")
)
# filter summer T data?


# FutureClim
# heat on/off
FTCL.heatON <- data.frame(
  year = c(2022, 2023, 2024),
  date_on = c(
    "2022-11-01",
    "2023-09-01",
    "2024-09-18"),
  date_off = c(
    "2022-04-01", # arbitrary, heat first turned on in Nov.
    "2023-07-03",
    "2024-05-10"))
temp.ls$FutureClim <- list(
  read.csv("../data/experiments/FutureClim/input_data/Temp.csv"))
temp.ls$FutureClim[[1]]$Timestamp <- as.POSIXct(temp.ls$FutureClim[[1]]$Timestamp, format = "%d/%m/%Y %H:%M")
# filter out non-heating period
temp.ls$FutureClim[[1]]$year <- year(temp.ls$FutureClim[[1]]$Timestamp) 
temp.ls$FutureClim[[1]] <- bind_rows(lapply(
  split(temp.ls$FutureClim[[1]], temp.ls$FutureClim[[1]]$year), function(x) {
    y <- unique(x$year)
    onOff <- FTCL.heatON %>%
      filter(year == y)
    x %>%
      filter(Timestamp > as.Date(onOff$date_on, format = "%Y-%m-%d") | Timestamp < as.Date(onOff$date_off, format = "%Y-%m-%d"))
}))


# GENX
temp.ls$GENX <- list(
  rbind(
    read.csv('../data/experiments/GENX/input_data/soil temperature_22.csv'),
    read.csv('../data/experiments/GENX/input_data/soil temperature_23.csv')
))


# Harvard Forest
temp.ls$HarvardForest <- list(
  read.csv("../data/experiments/HarvardForest/input_data/hf005-04-soil-temp_PH.csv") %>%
  pivot_longer(cols = 6:26, names_to = "plot", values_to = "soilT") %>%
  mutate(
    date = ymd(date), 
    depth = 5, 
    plt_name = paste0("p", str_extract(plot, "(\\d+)"))) %>%
  select("date", "plt_name", "depth", "soilT")
)


# KAEFS (rename cols)
temp.ls$KAEFS <- list(
  d2018_2023 = read.csv("../data/experiments/KAEFS/input_data/SoilTemperature2Depth_2018-2023_reshape_long.csv") %>%
    # filter out deep soil temp as it is unreliable
    filter(depth == 30),
  d2009_2018 = read.csv("../data/experiments/KAEFS/input_data/temperature_200908_201802_daily_reshaped.csv") %>%
    filter(clippingTreatment != "air") %>%
    mutate(plt_name = ifelse(clippingTreatment == "Clipped", paste0(plotID, "S"), paste0(plotID, "N"))) %>%
    rename(date = Date, depth = depth_cm, soilT = T) %>%
    select(date, plt_name, depth, soilT)
  )


# MERIT
temp.ls$MERIT <- list(read.csv("../data/experiments/MERIT/input_data/merit_soilT.csv"))


# Sanming
temp.ls$Sanming <- list(read.csv("../data/experiments/Sanming/input_data/TRL_TEMP_2024.csv"))


# SMARTX
temp.ls$SMARTX <- list(read.csv("../data/experiments/SMARTX/input_data/soilT.csv"))
temp.ls$SMARTX <- split(temp.ls$SMARTX[[1]], temp.ls$SMARTX[[1]]$sit_name)


# SPRUCE
temp.ls$SPRUCE <- lapply(list.files("../data/experiments/SPRUCE/input_data", full.names = TRUE)[2:7], read.csv)

# Notes: 1) VWC missing from "soil_2016"; 2) these files also contain a "treatment status" column, as well as temp, H2O table, air T, rel. humid, and precip; 3) depth is relative to mean hollow elevation, so challenging to compare to other systems...

# pivot longer & remove missing data
temp.ls$SPRUCE <- list(bind_rows(lapply(temp.ls$SPRUCE, function(x) {
  x <- x %>%
    select(Timestamp, Plot, starts_with("TS"))
  x %>%
    pivot_longer(
      cols = starts_with("TS"), 
      names_sep = "_", 
      names_prefix = "TS_",
      names_to = c("depth", "rep"), 
      values_to = "soilT") %>%
    mutate(rep = substr(rep, 1, 1)) %>%
    filter(soilT != -9999) %>%
    filter(depth != "Hummock") %>%
    rename(replicates = rep, plt_name = Plot, date = Timestamp)
})))


# SMARTX
temp.ls$SMARTX <- list(read.csv("../data/experiments/SMARTX/input_data/soilT.csv"))


# SWAMP
## filter out non-heating period
temp.ls$SWAMP <- list(
  read.csv("../data/experiments/SWAMP/input_data/soilT.csv") %>%
    mutate(month = month(as.Date(date, format = "%Y-%m-%d"))) %>%
    filter(month > 4 & month < 10) %>%
    select(-month))


# SWELTR
temp.ls$SWELTR <- list(read.csv("../data/experiments/SWELTR/input_data/SWELTR_to2020_T_H2O.csv"))
temp.ls$SWELTR[[1]] <- temp.ls$SWELTR[[1]] %>% 
  mutate(plt_name = paste0(PLOT, "_", TREAT)) %>%
  rename(depth = DEPTH, date = TIME, soilT = T) %>%
  select(date, plt_name, depth, soilT)


# TEAM
temp.ls$TEAM <- list(read.csv("../data/experiments/TEAM/input_data/temp.csv"))
temp.ls$TEAM[[1]] <- temp.ls$TEAM[[1]] %>%
  rename(plt_name = plot, date = time)


# TeRaCON
temp.ls$TeRaCON <- list(
  # campbell = read.csv("../data/experiments/TeRaCON/input_data/soilT_2012-2023.csv"),
  sentek = read.csv("../data/experiments/TeRaCON/input_data/sentek_st_2019-2023.csv"))
temp.ls$TeRaCON$sentek$depth <- temp.ls$TeRaCON$sentek$depth * 10

# TRACE
temp.ls$TRACE <- list(
  read.csv("../data/experiments/TRACE/input_data/TRACE_soilT_2016-2018.csv") %>% mutate(date = as.POSIXct(date, format = format("%Y-%m-%d %H:%M:%S"))) %>%
  filter(date > as.Date("2016-09-27", format = "%Y-%m-%d") & date < as.Date("2017-09-07", format = "%Y-%m-%d")))


# remove NULL
temp.ls <- Filter(Negate(is.null), temp.ls)
```

#### dif ST

```{r temp-difs, eval=FALSE}
# 185ES
e185.st.ls <- filPltTbl.fx(temp.ls, "185ExperimentStation", dateName = "Date", orders = "mdy HM")
e185.st.ls <- lapply(e185.st.ls, function(x) x %>% mutate(soil.temperature = as.numeric(soil.temperature))) 
e185.st.sum.ls <- difSum.ts.fx(e185.st.ls[[1]], dat_col_nm = "soil.temperature")
# plt_treat.fx("185ExperimentStation", e185.st.sum.ls$subDaily, dat_bks = "1 year", dat_lbs = "%Y")


# ACBB
ACBB.st.ls <- filPltTbl.fx(temp.ls, "ACBB", dateName = "TIMESTAMP", orders = "mdy HM")
ACBB.st.sum.ls <- setNames(lapply(ACBB.st.ls, function(x) {
  difSum.ts.fx(x, dat_col_nm = "data")
}), nm = names(temp.ls$ACBB))
ACBB.st.sum.ls2 <- setNames(
  lapply(names(ACBB.st.sum.ls[[1]]), function(name) {
    # Extract the elements corresponding to 'name' from all sublists in ACBB.sm.sum.ls
    elements <- lapply(seq_along(ACBB.st.sum.ls), function(i) {
      element <- ACBB.st.sum.ls[[i]][[name]]
      # Add the sit_name column with the name of the current sublist
      if (!is.null(element)) {
        element$sit_name <- names(ACBB.st.sum.ls)[i]
        element 
      } else {
        NULL
      }
    })
    
    # Combine all elements by row
    do.call(rbind, elements)
  }), nm = names(ACBB.st.sum.ls[[1]])) 
# plt_treat.fx("ACBB", ACBB.st.sum.ls2$subDaily, by_site = TRUE, dat_bks = "1 year", dat_lbs = "%Y")


# Achenkirch
Achn.st.ls <- filPltTbl.fx(temp.ls, "Achenkirch", orders = "ymd")
Achn.st.sum.ls <- difSum.ts.fx(Achn.st.ls[[1]], dat_col_nm = "soilTemp")
# plt_treat.fx("Achenkirch", Achn.st.sum.ls$subDaily, dat_bks = "1 year", dat_lbs = "%Y")


# B4W
B4Wm.st.ls <- filPltTbl.fx(temp.ls, "B4WarmED", orders = "ymd HMS", heat_only = FALSE)
B4Wm.st.ls2 <- lapply(B4Wm.st.ls, function(df) {
  grps <- unique(sub("^[^_]+_", "", df$plt_treat))
  lapply(grps, function(g) {
    df <- df[grepl(g, df$plt_treat), ]
    df$plt_treat <- sub(paste0("_", g), "", df$plt_treat)
    df
  })
})
B4WM.st.open.ls <- lapply(B4Wm.st.ls2, function(x) x[[2]])
B4WM.st.clsd.ls <- lapply(B4Wm.st.ls2, function(x) x[[1]])
B4WM.st.open.sum.ls <- setNames(lapply(B4WM.st.open.ls, function(x) {
  difSum.ts.fx(x, dat_col_nm = "soilTempC")
}), nm = names(temp.ls$B4WarmED))
B4WM.st.clsd.sum.ls <- setNames(lapply(B4WM.st.clsd.ls, function(x) {
  difSum.ts.fx(x, dat_col_nm = "soilTempC")
}), nm = names(temp.ls$B4WarmED))

B4WM.clq.opn.st.sum.ls <- lapply(
  getLsNms(B4WM.st.open.sum.ls), function(x) if (!is.null(x)) x %>% filter(sit_name == "cloquet") %>% mutate(sit_name = paste0(sit_name, "_", "open")))
B4WM.ely.opn.st.sum.ls <- lapply(
  getLsNms(B4WM.st.open.sum.ls), function(x) if (!is.null(x)) x %>% filter(sit_name == "ely") %>% mutate(sit_name = paste0(sit_name, "_", "open")))
B4WM.clq.cls.st.sum.ls <- lapply(
  getLsNms(B4WM.st.clsd.sum.ls), function(x) if (!is.null(x)) x %>% filter(sit_name == "cloquet") %>% mutate(sit_name = paste0(sit_name, "_", "closed")))
B4WM.ely.cls.st.sum.ls <- lapply(
  getLsNms(B4WM.st.clsd.sum.ls), function(x) if (!is.null(x)) x %>% filter(sit_name == "ely") %>% mutate(sit_name = paste0(sit_name, "_", "closed")))
# combine all
B4WM.st.sum.ls <- Reduce(function(x, y) mapply(rbind, x, y, SIMPLIFY = FALSE), list(B4WM.clq.opn.st.sum.ls, B4WM.ely.opn.st.sum.ls, B4WM.clq.cls.st.sum.ls, B4WM.ely.cls.st.sum.ls))

# B4WM.st.sum.ls$subDaily %>%
#   filter(date > as.Date("2020-01-01", format = "%Y-%m-%d")) %>%
#   filter(grepl("cloquet", sit_name)) %>%
#   plt_treat.fx("B4warmED", ., by_site = TRUE, dataType = "soil temp", VAR = "°C", dat_bks = "1 year", dat_lbs = "%Y")


# Blodgett
Bldg.st.ls <- filPltTbl.fx(temp.ls, "Blodgett", orders = "ymd HMS")
Bldg.st.sum.ls <- difSum.ts.fx(Bldg.st.ls[[1]], dat_col_nm = "temp")
# plt_treat.fx("Blodgett", Bldg.st.sum.ls$subDaily, dat_bks = "1 year", dat_lbs = "%Y")


# CiPEHR
CPHR.st.ls <- filPltTbl.fx(temp.ls, "CiPEHR", orders = "ymd HMS")
CPHR.st.sum.ls <- difSum.ts.fx(CPHR.st.ls[[1]], dat_col_nm = "soilT")
# plt_treat.fx("CiPEHR", CPHR.st.sum.ls$subDaily, dat_bks = "1 year", dat_lbs = "%Y")

# FutureClim
FTCL.st.ls <- filPltTbl.fx(temp.ls, "FutureClim", dateName = "Timestamp", orders = "dmy HM")
FTCL.st.sum.ls <- difSum.ts.fx(FTCL.st.ls[[1]], dat_col_nm = "Temp")
FTCL.st.sum.ls2 <- lapply(FTCL.st.sum.ls, function(x) {
  if (!is.null(x)) {
    
  }
})
# plt_treat.fx("FutureClim", FTCL.st.sum.ls$subDaily , dat_bks = "3 months", dat_lbs = "%b")


# GENX
GENX.st.ls <- filPltTbl.fx(temp.ls, "GENX", orders = "ymd HMS", dateName = "timestamp")
# change "treatmentamb" to "control"
GENX.st.ls[[1]]$plt_treat <- ifelse(grepl("amb", GENX.st.ls[[1]]$plt_treat), "control", GENX.st.ls[[1]]$plt_treat)
# add depth
GENX.st.ls[[1]]$depth <- 15
GENX.st.sum.ls <- difSum.ts.fx(GENX.st.ls[[1]], dat_col_nm = "soil_temp_avg")
# plt_treat.fx("GENX", GENX.st.sum.ls$subDaily, dataType = "soil temp", VAR = "°C", dat_bks = "3 months", dat_lbs = "%m-%y")


# Harvard Forest 
HVFS.st.ls <- filPltTbl.fx(temp.ls, "HarvardForest", orders = "ymd")
HVFS.st.sum.ls <- difSum.ts.fx(HVFS.st.ls[[1]], dat_col_nm = "soilT")
# plt_treat.fx("HarvardForest", HVFS.st.sum.ls$subDaily, dataType = "soil temp", VAR = "°C", dat_bks = "5 years", dat_lbs = "%Y")


# KAEFS
KAEF.st.ls <- filPltTbl.fx(temp.ls, "KAEFS", orders = c("ymd", "mdy"))
KAEF.st.sum.ls <- difSum.ts.fx(KAEF.st.ls[[2]], dat_col_nm = "soilT")
# plt_treat.fx("KAEFS", KAEF.st.sum.ls$subDaily, dat_bks = "1 year", dat_lbs = "%Y")


# MERIT
MERIT.st.ls <- filPltTbl.fx(temp.ls, "MERIT", orders = "ymd HMS", dateName = "timestamp")
# change "treatmentamb" to "control"
MERIT.st.ls[[1]]$plt_treat <- ifelse(grepl("amb", MERIT.st.ls[[1]]$plt_treat), "control", MERIT.st.ls[[1]]$plt_treat)
MERIT.st.ls[[1]]$depth <- MERIT.st.ls[[1]]$depth * 100
MRIT.st.sum.ls <- difSum.ts.fx(MERIT.st.ls[[1]], dat_col_nm = "soilT")
# plt_treat.fx("MERIT", MERIT.st.sum.ls$subDaily, dataType = "soil temp", VAR = "°C", dat_bks = "3 months", dat_lbs = "%m-%y")


# Sanming
SNMG.st.ls <- filPltTbl.fx(temp.ls, "Sanming", orders = "ymd")
SNMG.st.sum.ls <- difSum.ts.fx(SNMG.st.ls[[1]], dat_col_nm = "mean_value")
# plt_treat.fx("Sanming", SNMG.st.sum.ls$subDaily, dat_bks = "3 months", dat_lbs = "%b")


# SPRUCE
SPRC.st.ls <- filPltTbl.fx(temp.ls, "SPRUCE", orders = "ymd HM")
SPRC.st.sum.ls <- difSum.ts.fx(SPRC.st.ls[[1]], dat_col_nm = "soilT")
SPRC.st.sum.ls$subDaily$depth <- as.numeric(SPRC.st.sum.ls$subDaily$depth)
# plt_treat.fx("SPRUCE", SPRC.st.sum.ls$subDaily, dat_bks = "1 year", dat_lbs = "%Y")


# SMARTX
SMARTX.st.ls <- filPltTbl.fx(temp.ls, "SMARTX", orders = "ymd HMS", dateName = "timestamp")
# convert depth in cm to m
SMARTX.st.ls <- lapply(SMARTX.st.ls, function(x) x %>% mutate(depth = depth * 100))
# change "treatmentamb" to "control"
SMARTX.st.sum.ls <- setNames(lapply(SMARTX.st.ls, function(x) {
  difSum.ts.fx(x, dat_col_nm = "soilT")
}), nm = names(temp.ls$SMARTX))
SMTX.st.sum.ls2 <- setNames(
  lapply(names(SMARTX.st.sum.ls[[1]]), function(name) {
    # Extract the elements corresponding to 'name' from all sublists in ACBB.sm.sum.ls
    elements <- lapply(seq_along(SMARTX.st.sum.ls), function(i) {
      element <- SMARTX.st.sum.ls[[i]][[name]]
      # Add the sit_name column with the name of the current sublist
      if (!is.null(element)) {
        element$sit_name <- names(SMARTX.st.sum.ls)[i]
        element 
      } else {
        NULL
      }
    })
    
    # Combine all elements by row
    do.call(rbind, elements)
  }), nm = names(SMARTX.st.sum.ls[[1]]))
# plt_treat.fx("SMARTX", SMARTX.st.sum.ls2$subDaily, dataType = "soil temp", VAR = "°C", dat_bks = "1 year", dat_lbs = "%y")


# SWAMP
SWAMP.st.ls <- filPltTbl.fx(temp.ls, "SWAMP", orders = "ymd")
SWAMP.st.sum.ls <- difSum.ts.fx(SWAMP.st.ls[[1]], dat_col_nm = "soilT")
# plt_treat.fx("SWAMP", SWAMP.st.sum.ls$subDaily, datType = "soil temp", VAR = "°C", dat_bks = "1 month", dat_lbs = "%m")

# SWELTR
SWTR.st.ls <- filPltTbl.fx(temp.ls, "SWELTR", orders = "dmy HM")
SWTR.st.sum.ls <- difSum.ts.fx(SWTR.st.ls[[1]], dat_col_nm = "soilT")
# plt_treat.fx("SWELTR", SWTR.st.sum.ls$subDaily, dat_bks = "1 year", dat_lbs = "%Y")

# TEAM
TEAM.st.ls <- filPltTbl.fx(temp.ls, "TEAM", orders = "ymd")
TEAM.st.sum.ls <- difSum.ts.fx(TEAM.st.ls[[1]], dat_col_nm = "temp")
# plt_treat.fx("TEAM", TEAM.st.sum.ls$subDaily, dat_bks = "1 year", dat_lbs = "%Y")

# TeRaCON
TRCN.st.ls <- filPltTbl.fx(temp.ls, "TeRaCON", orders = "ymd HMS")
TRCN.st.sum.ls <- difSum.ts.fx(TRCN.st.ls[[1]], dat_col_nm = "soilT")
# plt_treat.fx("TeRaCON", TRCN.st.sum.ls$subDaily, dat_bks = "1 year", dat_lbs = "%Y")

# TRACE 
TRCE.st.ls <- filPltTbl.fx(temp.ls, "TRACE", orders = "ymd HMS")
TRCE.st.sum.ls <- difSum.ts.fx(TRCE.st.ls[[1]], dat_col_nm = "soilT")
# plt_treat.fx("TRACE", TRCE.st.sum.ls$subDaily, datType = "soil temp", VAR = "°C", dat_bks = "3 months", dat_lbs = "%m-%y")


temp.clean.ls <- list(
  one85ExperimentStation = e185.st.sum.ls,
  ACBB = ACBB.st.sum.ls2,
  Achenkirch = Achn.st.sum.ls,
  B4WarmED = B4WM.st.sum.ls,
  Blodgett = Bldg.st.sum.ls,
  CiPEHR = CPHR.st.sum.ls,
  FutureClim = FTCL.st.sum.ls,
  GENX = GENX.st.sum.ls,
  HarvardForest = HVFS.st.sum.ls,
  KAEFS = KAEF.st.sum.ls,
  MERIT = MRIT.st.sum.ls,
  Sanming = SNMG.st.sum.ls,
  SMARTX = SMTX.st.sum.ls2,
  SPRUCE = SPRC.st.sum.ls,
  SWAMP = SWAMP.st.sum.ls,
  SWELTR = SWTR.st.sum.ls,
  TEAM = TEAM.st.sum.ls,
  TeRaCON = TRCN.st.sum.ls,
  TRACE = TRCE.st.sum.ls
)
temp.clean.ls <- Filter(Negate(is.null), temp.clean.ls)

# write to file
saveRDS(temp.clean.ls, file = "/Users/jbeemmil@umich.edu/eco-warm/src/data/st.clean.ls_20250916.RDS")
```

# SM anom

```{r moist-anom, eval=FALSE}
acbbG <- ACBB.sm.sum.ls2$subDaily %>%
  filter(sit_name == "grassland")

acbbG.ecdf <- bind_rows(lapply(split(acbbG, acbbG$depth), function(x) {
  fx <- ecdf(x$control)
  med <- median(x$control, na.rm = TRUE)
  mean <- mean(x$control, na.rm = TRUE)
  iqr <- IQR(x$control, na.rm = TRUE)
  x$pctl <- fx(x$treatment4)
  x$meda <- x$treatment4 - med
  x$mena <- x$treatment4 - mean
  x$smda <- (x$treatment4 - med) / iqr
  return(x)
}), .id = "depth")


acbbG.ecdf %>%
  ggplot(., aes(date, pctl, color = depth)) +
  geom_point() +
  theme_bw() +
  theme(panel.grid = element_blank())

b4wC <- B4WM.sm.sum.ls2$subDaily %>% filter(sit_name == "cloquet")
b4wC.ecdf <- bind_rows(lapply(split(b4wC, b4wC$depth), function(y) {
  y$day <- yday(y$date)
  bind_rows(lapply(split(y, y$day), function(x) {
    fx <- ecdf(x$control)
    med <- median(x$control, na.rm = TRUE)
    mean <- mean(x$control, na.rm = TRUE)
    iqr <- IQR(x$control, na.rm = TRUE)
    ix <- grep("treatment", names(x))[which(!grepl("-", names(x)[grep("treatment", names(x))]))]
    for (i in seq_along(ix)) {
      nm <- names(x)[ix[i]]
      x[[paste(nm, "pctl", sep = "_")]] <- fx(x[[ix[i]]])
      x[[paste(nm, "meda", sep = "_")]] <- x[[ix[i]]] - med
      x[[paste(nm, "mena", sep = "_")]] <- x[[ix[i]]] - mean
      x[[paste(nm, "smda", sep = "_")]] <- (x[[ix[i]]] - med) / iqr
    }
  return(x)
  }))
}), .id = "depth")

b4wC.ecdf %>%
  filter(treatment3.6_smda > -1 & treatment3.6_smda < 1) %>%
  ggplot(., aes(date, treatment3.6_smda)) +
  geom_point() +
  theme_bw() +
  theme(panel.grid = element_blank())


test <- bind_rows(lapply(seq_along(moist.clean.ls), function(i) {

  # get subDaily data & expName
  z <- moist.clean.ls[[i]]$subDaily
  expName <- names(moist.clean.ls)[i]
  
  # check for multiple depth cols
  if (length(which(grepl("depth", names(z)))) > 1) {
    z$depth <- z$depth_lower
    z <- z %>% select(-c(depth_lower, depth_upper))
  }
  
  # check for sites
  if (!any(grepl("sit_name", names(z)))) {
    z$sitName <- expName
  } else {
    z$sitName <- paste0(expName, "_", z$sit_name)
    z$sit_name <- NULL
  }
  
  # adjust units to pct as needed
  if (max(z$control, na.rm = TRUE) <= 1) {
    z <- z %>%
      mutate(
        across(c(contains("control"), contains("treatment")), ~ .x * 100))
  }
  
  # summarize by day
  zDay <- z %>%
    select(-grep("- control", names(z))) %>% # drop dif cols
    mutate(day = as.Date(date)) %>%
    group_by(sitName, depth, day) %>%
    summarize(
      across(c(control, contains("treatment")), ~ mean(.x, na.rm = TRUE)), 
      .groups = "drop")
  
  # function for ecdf & anomalies
  an.cdf.fx <- function(x) {
    fx <- ecdf(x$control)
    med <- median(x$control, na.rm = TRUE)
    mean <- mean(x$control, na.rm = TRUE)
    iqr <- IQR(x$control, na.rm = TRUE)
    ix <- grep("treatment", names(x))[which(!grepl("-", names(x)[grep("treatment", names(x))]))]
    x$pctlC <- fx(x$control)
    for (i in seq_along(ix)) {
      nm <- names(x)[ix[i]]
      x[[paste(nm, "pctl", sep = "_")]] <- fx(x[[ix[i]]])
      x[[paste(nm, "meda", sep = "_")]] <- x[[ix[i]]] - med
      x[[paste(nm, "mena", sep = "_")]] <- x[[ix[i]]] - mean
      x[[paste(nm, "smda", sep = "_")]] <- (x[[ix[i]]] - med) / iqr
    }
  return(x)
  }
  
  # # calculate REW (cf. Meir et al. 2015)
  # rew.fx <- function(x) {
  #   bind_rows(lapply(split(x, x$depth), function(d) {
  #     vwc.min <- min(d$control, na.rm = TRUE)
  #     d$month <- month(d$day)
  #     bind_rows(lapply(split(d, d$month), function(y) {
  #       vwc.max.min <- max(y$control, na.rm = TRUE) - vwc.min
  #       y %>%
  #         group_by(sitName, depth, day) %>%
  #         summarize(
  #           across(c(contains("control"), contains("treatment")), ~ (.x - vwc.min) / vwc.max.min), .groups = "drop")
  #     }))
  #   }), .id = "depth")
  # }
  # 
  # rew <- rew.fx(zDay)
  # rew %>%
  #   pivot_longer(
  #     cols = c("control", "treatment4"),
  #     names_to = "trt",
  #     values_to = "rew"
  #   ) %>%
  #   ggplot(., aes(day, rew, color = trt)) +
  #   geom_point() +
  #   facet_grid(rows = vars(depth), cols = vars(sitName)) +
  #   theme_bw() +
  #   theme(panel.grid = element_blank())
  
  # run anomaly cdf fx by depth and pivot longer
  bind_rows(lapply(split(zDay, zDay$depth), function(x) an.cdf.fx(x))) %>%
    pivot_longer(
      cols = contains("_"),
      names_to = c("tDif", "stat"),
      names_pattern = "treatment(.*)_(.*)",
      values_to = "value") %>%
    select(sitName, depth, day, control, pctlC, tDif, stat, value)
  
}))


test %>%
  filter(stat == "smda") %>%
  mutate(depth_cat = cut(as.numeric(depth), breaks = c(0, 10, 30, 51, Inf))) %>%
  ggplot(., aes(control, value, color = sitName)) + 
  geom_point(alpha = 0.1) + 
  geom_hline(yintercept = 0, color = "black", linetype = "dashed") + 
  geom_smooth(method = "lm", se = FALSE) +
  facet_grid(rows = vars(depth_cat)) + coord_cartesian(xlim = c(0, 100), ylim = c(-5, 5)) +
  theme_bw() +
  theme(panel.grid = element_blank())

test %>%
  filter(stat == "pctl") %>% 
  filter(depth < 21) %>% 
  mutate(sitName_tDif = paste0(sitName, "_", tDif)) %>%
  ggplot(., aes(control, value, color = sitName)) + 
  geom_point(alpha = 0.1) + 
  geom_hline(yintercept = 0.5, color = "black", linetype = "dashed") +
  stat_smooth(
    method = "glm", 
    method.args = list(family = "quasibinomial"), 
    color = "black") +
  facet_wrap(vars(sitName_tDif)) + 
  coord_cartesian(ylim = c(0,1)) +
  theme_bw() +
  theme(panel.grid = element_blank())

test %>%
  filter(stat == "smda") %>% 
  filter(depth < 11) %>% 
  mutate(sitName_tDif = paste0(sitName, "_", tDif)) %>%
  ggplot(., aes(day, value, color = sitName)) + 
  geom_point(alpha = 0.1) + 
  geom_hline(yintercept = 0, color = "black", linetype = "dashed") + 
  facet_wrap(vars(sitName_tDif)) + 
  theme_bw() +
  theme(panel.grid = element_blank())

test %>%
  filter(stat == "pctl") %>% 
  filter(depth < 21) %>% 
  mutate(sitName_tDif = paste0(sitName, "_", tDif)) %>%
  ggplot(., aes(pctlC, value, color = sitName)) + 
  geom_point(alpha = 0.1) + 
  geom_hline(yintercept = 0.5, color = "black", linetype = "dashed") +
  geom_vline(xintercept = 0.5, color = "black", linetype = "dashed") + 
  stat_smooth(
      method = "glm", 
      method.args = list(family = "quasibinomial"), 
      color = "black") +
  facet_wrap(vars(sitName_tDif)) + 
  coord_cartesian(ylim = c(0,1), xlim = c(0, 1)) +
  theme_bw() +
  theme(panel.grid = element_blank())

test %>%
  filter(stat == "pctl") %>%
  filter(sitName == "Blodgett") %>%
  select(-"control") %>%
  rename(treatment = value, control = pctlC) %>%
  pivot_longer(
    cols = c(control, treatment),
    names_to = "trt",
    values_to = "pctl") %>%
  ggplot(., aes(pctl, fill = trt, color = trt)) +
  geom_histogram(position = "identity", alpha = .2) +
  scale_fill_manual(values = c("control" = "blue", "treatment" = "red")) +
  scale_color_manual(values = c("control" = "blue", "treatment" = "red")) +
  facet_grid(rows = vars(depth)) +
  theme_bw() +
  theme(panel.grid = element_blank())

```

# Growing season

```{r gs-dat}
ssd.1 <- terra::rast("/Users/jbeemmil@umich.edu/Downloads/Results/c_gls_LSP300-SOSD-S1_202301010000_GLOBE_OLCI_V1.0.1.tiff") 
ssd.2 <- terra::rast("/Users/jbeemmil@umich.edu/Downloads/Results/c_gls_LSP300-SOSD-S2_202301010000_GLOBE_OLCI_V1.0.1.tiff") 
esd.1 <- terra::rast("/Users/jbeemmil@umich.edu/Downloads/Results/c_gls_LSP300-EOSD-S1_202301010000_GLOBE_OLCI_V1.0.1.tiff") 
esd.2 <- terra::rast("/Users/jbeemmil@umich.edu/Downloads/Results/c_gls_LSP300-EOSD-S2_202301010000_GLOBE_OLCI_V1.0.1.tiff") 

ext.ssd1 <- terra::extract(ssd.1, exp.sit.df[ , c("sit_long", "sit_lat")])
ext.ssd2 <- terra::extract(ssd.2, exp.sit.df[ , c("sit_long", "sit_lat")])
ext.esd1 <- terra::extract(esd.1, exp.sit.df[ , c("sit_long", "sit_lat")])
ext.esd2 <- terra::extract(esd.2, exp.sit.df[ , c("sit_long", "sit_lat")])
gs <- cbind(
  exp.sit.df[ , c("exp_name", "sit_name")], 
  merge(
    merge(
      merge(ext.ssd1, ext.ssd2, by = "ID"),
      ext.esd1, by = "ID"),
  ext.esd2, by = "ID")) %>%
  rename(sos = `Start-Of-Season Day season 1`,
         eos = `End-Of-Season Day season 1`) %>%
  select(exp_name, sit_name, sos, eos)
gs.ls <- split(gs, gs$exp_name)
names(gs.ls)[1] <- "one85ExperimentStation"
gs.ls[[1]][ , c("exp_name", "sit_name")] <- "one85ExperimentStation"
# adjust negative SOS value for southern hemisphere site FutureClim
gs.ls$FutureClim$sos <- gs.ls$FutureClim$sos + 365
```

# Summary SM

```{r daily-raw-smoist}
moist.clean.d.ls <- setNames(lapply(seq_along(moist.clean.ls), function(i) {
  y <- moist.clean.ls[[i]]$subDaily  
  y$day <- as.Date(y$date)
  if (any("sit_name" %in% names(y))) {
    y
  } else {
    y$sit_name <- names(moist.clean.ls)[i]
  }
  if (length(which(grepl("depth", names(y)))) > 1) {
    y$depth <- mean(c(y$depth_upper, y$depth_lower))
    y <- y %>% select(-c(depth_lower, depth_upper))
  }
  
  # get index for growing season ls
  ix <- which(grepl(names(moist.clean.ls)[i], names(gs.ls)))
  GS <- gs.ls[[ix]] 
  
  y %>%
    group_by(day, sit_name, depth) %>%
      summarize(
        across(
          .cols = c(contains("control"), contains("treatment")),
          .fns = list(mean = ~ mean(.x, na.rm = TRUE), 
                      sd = ~ sd(.x, na.rm = TRUE), 
                      n = ~ n()),
          .names = "{.col}_{.fn}"), .groups = "drop") %>%
    mutate(doy = as.numeric(strftime(day, format = "%j")),
           growSeas = ifelse(doy > GS[["sos"]] & doy < GS[["eos"]], "growing season", "non-growing season"))
  }), nm = names(moist.clean.ls))

# # separate sites by heating duration
# names(database)[1] <- names(moist.clean.d.ls)[1]
# moist.clean.d.yr.ls <- moist.clean.d.ls[which(names(moist.clean.d.ls) %in% names(which(unlist(lapply(lapply(lapply(database, "[[", "experiment"), "[[", "heat_duration"), function(x) x == "year round")))))]
# moist.clean.d.ps.ls <- moist.clean.d.ls[which(names(moist.clean.d.ls) %in% names(which(unlist(lapply(lapply(lapply(database, "[[", "experiment"), "[[", "heat_duration"), function(x) x != "year round")))))]

sm.d.yr.p <- lapply(seq_along(moist.clean.d.ls), function(i) {
  df <- moist.clean.d.ls2[[i]]
  y <- names(df)[grepl("- control_mean", names(df))]
  sd <- names(df)[grepl("- control_sd", names(df))]
  plt.fx <- function(df, y, sd) {
    ggplot(df, aes(control_mean, !! sym(y), color = sit_name)) +
      geom_hline(yintercept = 0) +
      geom_errorbar(
        aes(xmin = control_mean - control_sd, xmax = control_mean + control_sd, ymin = !! sym(y) - !! sym(sd), ymax = !! sym(y) + !! sym(sd)),
        width = .2, alpha = .01) +
      geom_point() +
      facet_grid(rows = vars(depth), cols = vars(growSeas)) +
      theme_bw() +
      theme(panel.grid = element_blank())
  }
  p <- vector(mode = "list", length = length(y))
  if (length(y) > 1) {
    for (j in seq_along(y)) {
      p[[j]] <- plt.fx(df, y[j], sd[j])
    }
  } else {
    p <- plt.fx(df, y, sd)
  }
  return(p)
})


plt_treat.fx2 <- function(ls, window_size = NULL, dat_bks, dat_lbs,...) {
  lapply(seq_along(ls), function(i) {
    df <- ls[[i]]
    units <- units.ls[[i]]
    if (length(grep("depth", names(df))) == 2) {
      df <- df %>% mutate(depth = mean(c(depth_upper, depth_lower)))
    }
    if (units != "pct") {
      df <- df %>%
        mutate(
          across(c(contains("mean"), contains("sd")), .fns = ~ .x * 100))
    }
    
    # Dynamically capture all variable columns
    value_columns <- select(df, contains("mean")) %>% colnames()
  
    # moving average function; window_size is relative to time series frequency
    mv_avg.fx <- function(data, window_size) {
      data <- df %>%
        select(day, doy, growSeas, sit_name, depth, contains("mean")) %>%
        group_by(sit_name, growSeas, depth) %>%
        mutate(
          # Calculate moving averages for each data column dynamically
          across(all_of(value_columns), 
                 ~ rollapply(., width = window_size, FUN = mean, na.rm = TRUE, partial = TRUE, fill = NA, align = "center"), 
                 .names = "{.col}_moving_mean"),
          
          # Calculate moving standard deviations for each data column dynamically
          across(all_of(value_columns), 
                 ~ rollapply(., width = window_size, FUN = sd, fill = NA, align = "center"), 
                 .names = "{.col}_moving_sd")) %>%
        ungroup() %>%
        select(-all_of(value_columns))
      names(data)[which(grepl("mean_moving_", names(data)))] <- sub("mean_moving_", "", names(data)[which(grepl("mean_moving_", names(data)))])
    }
    
    if (avg == "moving") {
      if (is.null(window_size)) stop("\nwindow_size must be specified if avg = 'moving'\n")
      data <- mv_avg.fx(df, window_size = window_size)
    } else {
      # modify structure to match moving average data frame
      ix <- which(grepl("_n", names(df)))[-1] # remove site_name match
      data2 <- df[ , -ix]
    }
  
  # create plotting df
  p.df <- data %>%
    mutate(
      deg_heat = round(
        ifelse(plot == "control_mean", 0, as.numeric(str_extract(plot, "(\\d+)"))), 0),
      group = paste0(plot, depth)
    )
  
  # get color ramp
  htvl <- seq(0, 9)
  cols <- c("#0000ff", heat.colors(9))
  
  # check ylim
  if (err == "ci") {
    ymax <- max(p.df$ci.95, na.rm = TRUE)
    ymin <- min(p.df$ci.05, na.rm = TRUE) 
  } else {
    ymax <- max(p.df$mean + p.df$sd, na.rm = TRUE)
    ymin <- min(p.df$mean - p.df$sd, na.rm = TRUE) 
  }
  if (ymax == -Inf) {
    ymax <- max(p.df$mean, na.rm = TRUE)
  } else if (ymax > 100) {
    ymax = 100
  }
  if (ymin == Inf) {
    ymin <- min(p.df$mean, na.rm = TRUE)
  } else if (ymin < 0) {
    ymin <- 0
  }
  
  # plot
  p <- ggplot(p.df, aes(x = date, y = mean, group = group)) +
    geom_line(aes(color = deg_heat), size = .8) +
    scale_color_gradientn(colors = cols, values = scales::rescale(htvl, from = c(0, 9)), limits = c(0, 9)) +
    scale_fill_gradientn(colors = cols, values = scales::rescale(htvl, from = c(0, 9)), limits = c(0, 9)) +
    facet_grid(rows = vars(depth), cols = vars(!! facet_col)) +
    guides(fill = "none") +
    scale_y_continuous(limits = c(ymin, ymax)) +
    labs(
      y = paste0(VAR, " percent"),
      title = paste0(expName, ": ", datType)) +
    theme_bw() +
    theme(panel.grid = element_blank(),
          axis.title.x = element_blank(),
          text = element_text(size = 18))
  if (err == "ci") {
    p <- p +
      geom_ribbon(
        aes(ymin = ci.05, ymax = ci.95, fill = deg_heat),
        alpha = 0.2)
  } else {
    p <- p +
      geom_ribbon(
        aes(ymin = mean - sd, ymax = mean + sd, fill = deg_heat),
        alpha = 0.2)
  }
  if (any(grepl("POSIXct", class(p.df$date))))  {
    p + scale_x_datetime(date_breaks = dat_bks, date_labels = dat_lbs)
  } else {
    p + scale_x_date(date_breaks = dat_bks, date_labels = dat_lbs)
  }
  })}
```

```{r monthly-mean-moist-dif-depth}
moist.clean.m.ls <- setNames(lapply(seq_along(moist.clean.ls), function(i) {
  y <- moist.clean.ls[[i]]$subDaily
  y$month <- month(y$date)
  if (any("sit_name" %in% names(y))) {
    y
  } else {
    y$sit_name <- names(moist.clean.ls)[i]
  }
  if (length(which(grepl("depth", names(y)))) > 1) {
    y$depth <- mean(c(y$depth_upper, y$depth_lower))
    y <- y %>% select(-c(depth_lower, depth_upper))
  }
  y %>%
    group_by(month, sit_name, depth) %>%
      summarize(
        across(
          .cols = c(contains("control"), contains("treatment")),
          .fns = list(mean = ~ mean(.x, na.rm = TRUE), 
                      sd = ~ sd(.x, na.rm = TRUE), 
                      n = ~ n()),
          .names = "{.col}_{.fn}"), .groups = "drop") %>%
    rowwise() %>%
    mutate(
      across(
        ends_with("_sd"),
        ~ . / sqrt(get(sub("_sd$", "_n", cur_column()))),
        .names = "{sub('_sd$', '', .col)}_se"),
      across(
        ends_with("_mean"),
        ~ . - qt(1 - (0.05 / 2), df = get(sub("_mean$", "_n", cur_column()))) * get(sub("_mean$", "_se", cur_column())),
        .names = "{sub('_mean$', '', .col)}_ci.05"),
      across(
        ends_with("_mean"),
        ~ . + qt(1 - (0.05 / 2), df = get(sub("_mean$", "_n", cur_column()))) * get(sub("_mean$", "_se", cur_column())),
        .names = "{sub('_mean$', '', .col)}_ci.95"))
  }), nm = names(moist.clean.ls))

m.ls <- lapply(seq_along(moist.clean.m.ls), function(i) {
  x <- moist.clean.m.ls[[i]]
  y <- names(x)[grepl("control_mean", names(x))]
  sd <- names(x)[grepl("_sd", names(x))]
  plt.fx <- function(x, y, sd) {
    ggplot(x, aes(month, !! sym(y), color = sit_name)) +
      geom_hline(yintercept = 0) +
      geom_point() +
      geom_line() +
      geom_errorbar(
        aes(ymin = !! sym(y) - !! sym(sd), ymax = !! sym(y) + !! sym(sd)),
        width = .2) +
      scale_x_continuous(breaks = 1:12, labels = month.abb) +
      facet_grid(rows = vars(depth)) +
      theme_bw() +
      theme(panel.grid = element_blank())
  }
  p <- vector(mode = "list", length = length(y))
  if (length(y) > 1) {
    for (j in seq_along(y)) {
      p[[j]] <- plt.fx(x, y[j], sd[j])
    }
  } else {
    p <- plt.fx(x, y, sd)
  }
  return(p)
})
m.ls
```

# site plots

```{r moist-ts-prep}
p.save <- function(expName, p, pName = "sm") {
  dir <- "../docs/AGU24"
  fnm <- file.path(dir, paste0(expName, "_", pName, ".png"))
  if (file.exists(fnm)) {
    fnm <- file.path(dir, paste0(expName, "_", pName, "1.png"))
  }
  ggsave(
    filename = fnm,
    plot = p,
    height = 5.3, 
    width = 8.5, 
    units = "in")
}

p.save(expName = "185ExperimentStation", plt.fx("185ExperimentStation", e185.sm.sum.ls, "1 year", "%Y", units = "ppn"))

p.save(expName = "ACBB", plt.fx("ACBB", ACBB.sm.sum.ls2, "3 months", "%b", facet_col = "sit_name"))

p.save(expName = "Blodgett", plt.fx("Blodgett", Bldg.sm.sum.ls, "1 year", "%Y", units = "ppn"))

p.save(expName = "CiPEHR", plt.fx("CiPEHR", CPHR.sm.sum.ls, "1 year", "%y"))

p.save(expName = "Harvard Forest", plt.fx("Harvard Forest", HRVF.sm.sum.ls, "1 year", "%Y", units = "ppn"))

p.save(expName = "KAEFS", plt.fx("KAEFS", KAEF.sm.sum.ls, "1 year", "%Y"))

p.save(expName = "SPRUCE", plt.fx("SPRUCE", SPRC.sm.sum.ls2, "1 year", "%Y", units = "ppn"))

p.save(expName = "SWELTR", plt.fx("SWELTR", SWTR.sm.sum.ls, "4 months", "%b-%y", units = "ppn"))

lapply(seq_along(TEAM.sm.sum.ls), function(i) {
  if (i == 2) {
    TEAM.sm.sum.ls[[i]] <- TEAM.sm.sum.ls[[i]][TEAM.sm.sum.ls[[i]][["mean"]] < .4, ]
    TEAM.sm.sum.ls[[i]]
  } else {
    TEAM.sm.sum.ls[[i]]
  }
})
test <- TEAM.sm.sum.ls
test$dailySit <- test$dailySit[which(test$dailySit$mean < .4 & test$dailySit$mean > -.4), ]

p.save(expName = "TEAM", plt.fx("TEAM", test, "1 year", "%Y"))

p.save(expName = "TeRaCON", plt.fx("TeRaCON", TRCN.sm.sum.ls, "1 year", "%Y"))
```

# Load sm.clean.ls and temp.clean.ls

```{r load-dat}
if (!exists("moist.clean.ls")) {
  moist.clean.ls <- readRDS("../src/data/sm.clean.ls_20250916.RDS")
}
if (!exists("temp.clean.ls")) {
  temp.clean.ls <- readRDS("../src/data/st.clean.ls_20250916.RDS")
}
```

```{r filter-match-depths-fx}
filter_matching_depths <- function(data, sit_col = "sit_name", depth_col = "depth",
                                   treat_pattern = "^treatment[0-9]") {
  # 1. identify treatment columns (exclude difference columns)
  treat_cols <- grep(treat_pattern, names(data), value = TRUE)
  if (length(treat_cols) == 0) {
    stop("No treatment columns found matching pattern: ", treat_pattern)
  }
  
  # 2. drop rows with NA in depth or treatment columns
  data_clean <- data %>%
    filter(!is.na(.data[[depth_col]])) %>%
    filter(if_all(all_of(treat_cols), ~ !is.na(.)))
  
  # 3. reshape to long (only treatments)
  df_long <- data_clean %>%
    select(all_of(c(sit_col, depth_col, treat_cols))) %>%
    pivot_longer(cols = all_of(treat_cols), names_to = "treatment", values_to = "value")
  
  # 4. collect depth levels per sit_name × treatment
  depth_by_group <- df_long %>%
    group_by(.data[[sit_col]], treatment) %>%
    summarise(levels = list(sort(unique(.data[[depth_col]]))), .groups = "drop")
  
  # 5. determine common depths per site
  common_depths <- depth_by_group %>%
    group_by(.data[[sit_col]]) %>%
    summarise(common = Reduce(intersect, levels), .groups = "drop")
  
  # 6. join back to original *cleaned* data and filter
  filtered <- data_clean %>%
    inner_join(common_depths, by = setNames("sit_name", sit_col)) %>%
    filter(.data[[depth_col]] %in% common) %>%
    select(-common)
  
  return(filtered)
}
```

# SM summary
## SM dif

```{r sum-stats-sm}
dpts.sm <- lapply(moist.clean.ls, function(x) {
  unlist(unique(x$subDaily[, grep("depth", names(x$subDaily))]))
})
dpts.st <- lapply(temp.clean.ls, function(x) {
  lapply(x, function(y) unlist(unique(y[, grep("depth", names(y))])))
})
units.ls <- list(
  one85ExperimentStation = "ppn",
  ACBB = "pct",
  Achenkirch = "pct",
  B4WarmED = "ppn",
  Blodgett = "ppn",
  CiPEHR = "pct",
  FutureClim = "ppn",  
  HarvardForest = "ppn",
  KAEFS = "pct",
  Sanming = "pct",
  SPRUCE = "ppn",
  SWAMP = "pct",
  SWELTR = "ppn",
  TEAM = "ppn",
  TeRaCON = "ppn",
  TRACE = "ppn"
)
eco.df <- data.frame(
  sit_name = c("one85ExperimentStation", "ACBB_cropland", "ACBB_grassland", "Achenkirch", "B4WarmED_cloquet_open", "B4WarmED_cloquet_closed", "B4WarmED_ely_open", "B4WarmED_ely_closed", "Blodgett", "CiPEHR", "FutureClim", "GENX", "HarvardForest", "KAEFS", "MERIT", "SMARTX_c3", "SMARTX_c4", "Sanming", "SPRUCE", "SWAMP", "SWELTR", "TEAM", "TeRaCON", "TRACE"),
  eco = c("cropland", "cropland", "grassland", "temperate forest", "temperate forest", "temperate forest", "boreal forest", "boreal forest", "temperate forest", "tundra", "grassland", "temperate saltmarsh", "temperate forest", "grassland", "temperate saltmarsh", "temperate saltmarsh", "temperate saltmarsh", "subtropical forest", "boreal forest", "tundra", "tropical forest", "tundra", "grassland", "tropical forest")
) %>%
  mutate(biome = ifelse(grepl("forest", eco), "forest", "grassland"))
wrm.df <- data.frame(
  sit_name = c("one85ExperimentStation", "ACBB_cropland", "ACBB_grassland", "Achenkirch", "B4WarmED_cloquet_open", "B4WarmED_cloquet_closed", "B4WarmED_ely_open", "B4WarmED_ely_closed", "Blodgett", "CiPEHR", "FutureClim", "GENX", "HarvardForest", "KAEFS", "MERIT", "SMARTX_c3", "SMARTX_c4", "Sanming", "SPRUCE", "SWAMP", "SWELTR", "TEAM", "TeRaCON", "TRACE"),
  wrm = c("above (IR)", "below", "below", "below", "above (IR)/below", "above (IR)/below", "above (IR)/below", "above (IR)/below", "below", "above (snow)", "above (OTC)/below", "below", "below", "above (IR)", "above (OTC)/below", "above (IR)/below", "above (IR)/below", "below", "above (FA)/below", "below", "below", "below", "above (IR)/below", "above (IR)")
)
database$DWFP <- NULL
database$ForHot <- NULL
database$LyonHI <- NULL
database$PtReyes <- NULL
database$Stillberg <- NULL
insertRow <- function(existingDF, newrow, r) {
  existingDF[seq(r+1,nrow(existingDF)+1),] <- existingDF[seq(r,nrow(existingDF)),]
  existingDF[r,] <- newrow
  existingDF
}
mat.map.df <- bind_rows(lapply(database, function(x) {
  x$site[ , c("exp_name", "sit_name", "MAT", "MAP")]
}))
mat.map.df$MAT <- as.numeric(mat.map.df$MAT)
mat.map.df$MAP <- as.numeric(mat.map.df$MAP)
mat.map.df[1, "sit_name"] <- "one85ExperimentStation"
mat.map.df[9, "sit_name"] <- "HarvardForest"
mat.map.df <- insertRow(mat.map.df, c("ACBB", "ACBB_grassland", 12, 760), 3)
mat.map.df[2, "sit_name"] <- "ACBB_cropland"
mat.map.df[mat.map.df$exp_name == "B4WarmED", "sit_name"] <- tolower(mat.map.df[mat.map.df$exp_name == "B4WarmED", "sit_name"])
mat.map.df[, "sit_name"] <- ifelse(
  mat.map.df$exp_name == "ACBB", mat.map.df$sit_name, 
  ifelse(mat.map.df$exp_name == "B4WarmED", paste0(mat.map.df$exp_name, "_", mat.map.df$sit_name), mat.map.df$exp_name))
mat.map.df <- insertRow(mat.map.df, c("B4WarmED", "B4WarmED_cloquet_open", 4.5, 807), 5)
mat.map.df <- insertRow(mat.map.df, c("B4WarmED", "B4WarmED_ely_open", 3, 722), 7)
mat.map.df[6, "sit_name"] <- "B4WarmED_cloquet_closed"
mat.map.df[8, "sit_name"] <- "B4WarmED_ely_closed"
clm.df <- bind_rows(lapply(database, function(x) {
  x$site[ , c("sit_long", "sit_lat")]
}), .id = "expName")
# gai.list <- list.files(
#   path = "/Users/jeff/Seafile/ISRaD_geospatial_data/Global-AI_v3_monthly", 
#   pattern = "\\.tif$", full.names = TRUE)
# gai <- lapply(gai.list, function(x) rast(x))
# names(gai) <- str_extract(basename(gai.list), "(?<=ai_v3_)\\d+(?=\\.tif)")

dat.rng <- lapply(seq_along(moist.clean.ls), function(i) {
  x <- moist.clean.ls[[i]]
  df <- data.frame(max = max(x$dailySit$mean, na.rm = T),
                   min = min(x$dailySit$mean, na.rm = T))
  if (units.ls[[i]] != "pct") {
    df * 100
  } else {
    df
  }
})
max(unlist(sapply(dat.rng, "[[", 1)))
min(unlist(sapply(dat.rng, "[[", 2)))

# no grouping
sm.mean.ls <- setNames(lapply(seq_along(moist.clean.ls), function(i) {
  
  df <- moist.clean.ls[[i]][["subDaily"]]
  ix.dif <- grep("- control", names(df))
  if (units.ls[[i]] == "ppn") {
    for (j in seq_along(ix.dif)) {
      df[[ix.dif[j]]] <- df[[ix.dif[j]]] * 100  
    }
  }
  if (length(grep("depth", names(df))) == 2) {
    df$depth <- mean(c(as.numeric(df$depth_upper), as.numeric(df$depth_lower)))
  }
  if (any(grepl("sit_name", names(df)))) {
    df$sit_name <- paste0(names(moist.clean.ls[i]), "_", df$sit_name)
  } else {
    df$sit_name <- names(moist.clean.ls[i])
  }
  df %>%
    group_by(sit_name) %>%
    summarize(
      across(
        .cols = contains("- control"),
        .fns = list(mean = ~ mean(.x, na.rm = TRUE),
                    sd = ~ sd(.x, na.rm = TRUE),
                    n = ~ n())),
      .groups = "drop") %>%
   rowwise() %>%
      mutate(
        across(
          ends_with("_sd"),
          ~ . / sqrt(get(sub("_sd$", "_n", cur_column()))),
          .names = "{sub('_sd$', '', .col)}_se"),
        across(
          ends_with("_mean"),
          ~ . - qt(1 - (0.05 / 2), df = get(sub("_mean$", "_n", cur_column()))) * get(sub("_mean$", "_se", cur_column())),
          .names = "{sub('_mean$', '', .col)}_ci.05"),
        across(
          ends_with("_mean"),
          ~ . + qt(1 - (0.05 / 2), df = get(sub("_mean$", "_n", cur_column()))) * get(sub("_mean$", "_se", cur_column())),
          .names = "{sub('_mean$', '', .col)}_ci.95")) %>%
      ungroup() %>%
      select(sit_name, contains("_mean"), contains("_ci."), contains("_sd")) %>%
      pivot_longer(
        cols = contains("- control"),
        names_to = c("dif", ".value"),
        names_pattern = "^(.*)_(.*)$")
  }), nm = names(moist.clean.ls))
sm.mean.df <- bind_rows(sm.mean.ls, .id = "exp_name")
sm.mean.df$eco <- eco.df[match(sm.mean.df$sit_name, eco.df$sit_name), "eco"]
sm.mean.df$wrm <- wrm.df[match(sm.mean.df$sit_name, wrm.df$sit_name), "wrm"]
sm.mean.df$biome <- eco.df[match(sm.mean.df$sit_name, eco.df$sit_name), "biome"]
sm.mean.df <- cbind(sm.mean.df, mat.map.df[match(sm.mean.df$sit_name, mat.map.df$sit_name), c("MAT", "MAP")])
sm.mean.df$tDif <- as.numeric(str_extract(sm.mean.df$dif, "\\d+\\.*\\d*"))

# realized warming
tDifR.sm.df <- bind_rows(setNames(lapply(seq_along(moist.clean.ls), function(i) {
  sm.df <- moist.clean.ls[[i]]$dailySit
  if (length(grep("depth", names(sm.df))) == 2) {
    sm.df$depth <- mean(c(as.numeric(sm.df$depth_upper), as.numeric(sm.df$depth_lower)))
  }
  sm.mxD <- max(sm.df$depth)
  ix <- which(names(moist.clean.ls)[i] == names(temp.clean.ls))
  st.df <- temp.clean.ls[[ix]]$dailySit
  if (length(grep("depth", names(st.df))) == 2) {
    st.df$depth <- mean(c(as.numeric(st.df$depth_upper), as.numeric(st.df$depth_lower)))
  }
  if (any(grepl("sit_name", names(st.df)))) {
    st.df$sit_name <- paste0(names(moist.clean.ls[i]), "_", st.df$sit_name)
  } else {
    st.df$sit_name <- names(moist.clean.ls[i])
  }
  st.df$tDif <- as.numeric(str_extract(st.df$dif, "\\d+\\.*\\d*"))
  st.df %>% 
    filter(depth <= sm.mxD) %>%
    group_by(sit_name, tDif) %>%
    summarize(tDifR = mean(mean, na.rm = T), .groups = "drop")
}), nm = names(moist.clean.ls)))

sm.mean.df <- merge(sm.mean.df, tDifR.sm.df)

library(ggtext)

# Create a vector of labels with alternating bold and regular
y_levels <- levels(fct_reorder2(
  paste0(sm.mean.df$sit_name, " (", sm.mean.df$tDif, ")"), 
  sm.mean.df$tDif, 
  sm.mean.df$eco
))

# Alternate background for each label
y_labels <- ifelse(seq_along(y_levels) %% 2 == 1,
                   paste0("<span style='background-color:lightgray;'>", y_levels, "</span>"),
                   y_levels)


# plot
eco_cols <- c(
  "cropland"          = "#E69F00",
  "grassland"         = "#56B4E9",  
  "tundra"            = "#0072B2",
  "tropical forest"   = "#BAE4B3", 
  "subtropical forest"= "#74C476", 
  "temperate forest"  = "#31A354", 
  "boreal forest"     = "#006D2C")
p <- sm.mean.df %>%
  mutate(
    eco = factor(
      eco, 
      levels = c("boreal forest", "temperate forest", "subtropical forest", "tropical forest",
                "cropland", "grassland", "tundra"), ordered = TRUE),
    sit_name_T = paste0(sit_name, "_", tDif,  " (", round(tDifR, 1) , ")"),
    wrm2 = recode(
      wrm,
      "below" = "below",
      "above (IR)/below" = "above/below",
      "above (OTC)/below" = "above/below",
      "above (FA)/below" = "above/below",
      "above (IR)" = "above",
      "above (snow)" = "above")) %>%
  # group_by(exp_name) %>%
  # mutate(max_tDifR = max(tDifR, na.rm = TRUE)) %>%
  # ungroup() %>%
  # group_by(sit_name) %>%
  # mutate(max_tDifRs = max(tDifR, na.rm = TRUE)) %>%
  # ungroup() %>%
  # arrange(desc(max_tDifR), exp_name, desc(max_tDifRs), desc(tDifR)) %>%
  arrange(desc(tDifR)) %>%
  mutate(sit_name_T = factor(sit_name_T, levels = rev(unique(sit_name_T)))) %>%
  ggplot(., aes(mean, sit_name_T, color = eco, fill = eco)) +
  geom_vline(xintercept = 0) +
  # geom_errorbarh(
  #   aes(xmin = ci.05, xmax = ci.95), 
  #   alpha = .5) +
  geom_errorbarh(
    aes(xmin = mean - sd, xmax = mean + sd),
    alpha = .5, height = .3, show.legend = FALSE) +
  # geom_point(
  #   aes(size = tDifR, shape = wrm2), 
  #   stroke = 2) +
  # scale_shape_manual(
  #   name = "",
  #   values = c("below" = 25, 
  #              "above (IR)/below" = 7, 
  #              "above (OTC)/below" = 12, 
  #              "above (FA)/below" = 13, 
  #              "above (IR)" = 2, 
  #              "above (snow)" = 8)) +
  geom_point(
    aes(shape = wrm2), 
    size = 5) +
  scale_shape_manual(
    name = "Warming",
    values = c("below" = 25, 
               "above/below" = 22, 
               "above" = 24)) +
  scale_color_manual(name = "Ecosystem", values = eco_cols) +
  scale_fill_manual(name = "Ecosystem", values = eco_cols) +
  scale_size_continuous(name = "mean warming\n(°C)", range = c(1, 6), breaks = c(1, 2, 3, 4, 5)) +
  # scale_y_discrete(labels = y_labels) +
  expand_limits(y = c(-1, length(unique(sm.mean.df$sit_name)) + 2)) +
  guides(color = guide_legend(override.aes = list(size = 5)),
         shape = guide_legend(override.aes = list(shape = c(24, 22, 25), fill = rep("black", 3), size = 5))) +
  labs(x = "mean (trt - ctl), %VWC") +
  theme_bw() +
  theme(panel.grid = element_blank(),
        axis.title.y = element_blank(),
        # Adjusting legend text size
        legend.text = element_text(size = 14),
        legend.title = element_text(size = 14),
        # Adjusting x-axis text size
        axis.text.x = element_text(size = 14),
        # Adjusting x-axis title size
        axis.title.x = element_text(size = 14),
        # Adjusting y-axis text size
        axis.text.y = element_text(size = 12))

ggsave(
    filename = "../docs/AGU24/mean_difSM.png",
    plot = p,
    height = 23.62, 
    width = 37.94, 
    dpi = 300,
    units = "cm")

ggsave(
  filename = "../docs/Manuscripts/figs/mean_difSM.png",
  plot = p,
  height = 6, 
  width = 10, 
  units = "in",
  device = "png")

# Save with ragg for proper HTML rendering
ragg::agg_png(
  "../docs/Manuscripts/figs/mean_difSM.png", 
  height = 6, 
  width = 10, 
  units = "in", 
  res = 300)
print(p)
dev.off()
```

## SM dif, D

```{r sm-gs-dif}
# separate sites by heating duration
names(database)[1] <- names(moist.clean.ls)[1]
yr <- names(which(unlist(lapply(lapply(lapply(database, "[[", "experiment"), "[[", "heat_duration"), function(x) x == "year round"))))
pt <- names(which(unlist(lapply(lapply(lapply(database, "[[", "experiment"), "[[", "heat_duration"), function(x) x != "year round"))))

sm.mean.ls <- setNames(lapply(seq_along(moist.clean.ls), function(i) {
  
  df <- moist.clean.ls[[i]][["subDaily"]]
  ix.dif <- grep("- control", names(df))
  if (units.ls[[i]] == "ppn") {
    for (j in seq_along(ix.dif)) {
      df[[ix.dif[j]]] <- df[[ix.dif[j]]] * 100  
    }
  }
  if (length(grep("depth", names(df))) == 2) {
    df$depth <- mean(c(as.numeric(df$depth_upper), as.numeric(df$depth_lower)))
  }
  if (any(grepl("sit_name", names(df)))) {
    df$sit_name <- paste0(names(moist.clean.ls[i]), "_", df$sit_name)
  } else {
    df$sit_name <- names(moist.clean.ls[i])
  }
  
  # get heating duration
  if (any(names(moist.clean.ls)[i] %in% yr)) {
    df$heatDur <- "all year"
  } else {
    df$heatDur <- "partial"
  }

  df %>%
    group_by(sit_name, heatDur) %>%
    summarize(
      across(
        .cols = contains("- control"),
        .fns = list(mean = ~ mean(.x, na.rm = TRUE),
                    sd = ~ sd(.x, na.rm = TRUE),
                    n = ~ n())),
      .groups = "drop") %>%
   rowwise() %>%
      mutate(
        across(
          ends_with("_sd"),
          ~ . / sqrt(get(sub("_sd$", "_n", cur_column()))),
          .names = "{sub('_sd$', '', .col)}_se"),
        across(
          ends_with("_mean"),
          ~ . - qt(1 - (0.05 / 2), df = get(sub("_mean$", "_n", cur_column()))) * get(sub("_mean$", "_se", cur_column())),
          .names = "{sub('_mean$', '', .col)}_ci.05"),
        across(
          ends_with("_mean"),
          ~ . + qt(1 - (0.05 / 2), df = get(sub("_mean$", "_n", cur_column()))) * get(sub("_mean$", "_se", cur_column())),
          .names = "{sub('_mean$', '', .col)}_ci.95")) %>%
      ungroup() %>%
      select(sit_name, heatDur, contains("_mean"), contains("_ci."), contains("_sd")) %>%
      pivot_longer(
        cols = contains("- control"),
        names_to = c("dif", ".value"),
        names_pattern = "^(.*)_(.*)$")
  }), nm = names(moist.clean.ls))
sm.mean.df <- bind_rows(sm.mean.ls)
sm.mean.df$eco <- eco.df[match(sm.mean.df$sit_name, eco.df$sit_name), "eco"]
sm.mean.df$wrm <- wrm.df[match(sm.mean.df$sit_name, wrm.df$sit_name), "wrm"]
sm.mean.df$biome <- eco.df[match(sm.mean.df$sit_name, eco.df$sit_name), "biome"]
sm.mean.df <- cbind(sm.mean.df, mat.map.df[match(sm.mean.df$sit_name, mat.map.df$sit_name), c("MAT", "MAP")])
sm.mean.df$tDif <- as.numeric(str_extract(sm.mean.df$dif, "\\d+\\.*\\d*"))
p <- sm.mean.df %>%
  mutate(eco = factor(
    eco, 
    levels = c("boreal forest", "temperate forest", "tropical forest",
               "cropland", "grassland", "tundra"), ordered = TRUE),
    sit_name_T = paste0(sit_name, " (", tDif, ")")) %>%
  mutate(sit_name_T = fct_reorder(sit_name_T, tDif)) %>%
  ggplot(., aes(mean, sit_name_T, color = eco)) +
  geom_vline(xintercept = 0) +
  geom_errorbarh(
    aes(xmin = ci.05, xmax = ci.95),
    alpha = .5) +
  # geom_errorbarh(
  #   aes(xmin = mean - sd, xmax = mean + sd), 
  #   alpha = .5) +
  geom_point(
    aes(size = tDif, shape = heatDur)) +
  scale_size_continuous(name = "°C warming", range = c(1, 9), breaks = c(2, 4, 6, 8)) +
  scale_color_manual(
    name = "",
    values = c("cropland" = "#bf535f",
               "grassland" = "#b7bce4",
               "tundra" = "#535fbf",
               "tropical forest" = "#bce4b7",
               "temperate forest" = "#5fbf53",
               "boreal forest" = "#398030")) +
  guides(color = guide_legend(override.aes = list(size = 5)),
         shape = guide_legend(override.aes = list(size = 5))) +
  labs(x = "mean (trt - ctl), %VWC", shape = "") +
  # facet_grid(rows = vars(heatDur), scales = "free_y") +
  theme_bw() +
  theme(panel.grid = element_blank(),
        axis.title.y = element_blank(),
        # Adjusting legend text size
        legend.text = element_text(size = 32),
        legend.title = element_text(size = 32),
        # Adjusting x-axis text size
        axis.text.x = element_text(size = 24),
        # Adjusting x-axis title size
        axis.title.x = element_text(size = 24),
        # Adjusting y-axis text size
        axis.text.y = element_text(size = 18),
        # Adjusting strip text size
        strip.text = element_text(size = 24))

ggsave(
    filename = "../docs/EGU25/mean_difSM_HD_sd.png",
    plot = p,
    height = 23.62, 
    width = 37.94, 
    dpi = 300,
    units = "cm")
```

## SM dif, GS+D

```{r sm-gs-dif}
# separate sites by heating duration
names(database)[1] <- names(moist.clean.ls)[1]
yr <- names(which(unlist(lapply(lapply(lapply(database, "[[", "experiment"), "[[", "heat_duration"), function(x) x == "year round"))))
pt <- names(which(unlist(lapply(lapply(lapply(database, "[[", "experiment"), "[[", "heat_duration"), function(x) x != "year round"))))

sm.mean.ls <- setNames(lapply(seq_along(moist.clean.ls), function(i) {
  
  # get index for growing season ls
  ix <- which(grepl(names(moist.clean.ls)[i], names(gs.ls)))
  GS <- gs.ls[[ix]]
  if (ix == 4) {
    GS$sit_name <- ifelse(grepl("loquet", GS$sit_name), "B4WarmED_cloquet", "B4WarmED_ely")
    GS <- rbind(GS, GS) %>%
      mutate(sit_name = paste0(rep(GS$sit_name, 2), rep(c("_open","_closed"), ea = 2)))
  }
  
  df <- moist.clean.ls[[i]][["subDaily"]]
  ix.dif <- grep("- control", names(df))
  if (units.ls[[i]] == "ppn") {
    for (j in seq_along(ix.dif)) {
      df[[ix.dif[j]]] <- df[[ix.dif[j]]] * 100  
    }
  }
  if (length(grep("depth", names(df))) == 2) {
    df$depth <- mean(c(as.numeric(df$depth_upper), as.numeric(df$depth_lower)))
  }
  if (any(grepl("sit_name", names(df)))) {
    df$sit_name <- paste0(names(moist.clean.ls[i]), "_", df$sit_name)
  } else {
    df$sit_name <- names(moist.clean.ls[i])
    GS$sit_name <- GS$exp_name
  }
  
  # get heating duration
  if (any(names(moist.clean.ls)[i] %in% yr)) {
    df$heatDur <- "all year"
  } else {
    df$heatDur <- "partial"
  }

  df %>%
    filter(!is.na(date)) %>%
    left_join(GS[ , c("sit_name", "sos", "eos")], by = "sit_name") %>%
    mutate(
      doy = as.numeric(strftime(date, format = "%j")),
      growSeas = ifelse(sos < eos,
                        ifelse(doy > sos & doy < eos,
                               "growing season", "non-growing season"),
                        ifelse(doy > sos | doy < eos, 
                               "growing season", "non-growing season"))) %>%
    group_by(sit_name, heatDur, growSeas) %>%
    summarize(
      across(
        .cols = contains("- control"),
        .fns = list(mean = ~ mean(.x, na.rm = TRUE),
                    sd = ~ sd(.x, na.rm = TRUE),
                    n = ~ n())),
      .groups = "drop") %>%
   rowwise() %>%
      mutate(
        across(
          ends_with("_sd"),
          ~ . / sqrt(get(sub("_sd$", "_n", cur_column()))),
          .names = "{sub('_sd$', '', .col)}_se"),
        across(
          ends_with("_mean"),
          ~ . - qt(1 - (0.05 / 2), df = get(sub("_mean$", "_n", cur_column()))) * get(sub("_mean$", "_se", cur_column())),
          .names = "{sub('_mean$', '', .col)}_ci.05"),
        across(
          ends_with("_mean"),
          ~ . + qt(1 - (0.05 / 2), df = get(sub("_mean$", "_n", cur_column()))) * get(sub("_mean$", "_se", cur_column())),
          .names = "{sub('_mean$', '', .col)}_ci.95")) %>%
      ungroup() %>%
      select(sit_name, growSeas, heatDur, contains("_mean"), contains("_ci."), contains("_sd")) %>%
      pivot_longer(
        cols = contains("- control"),
        names_to = c("dif", ".value"),
        names_pattern = "^(.*)_(.*)$")
  }), nm = names(moist.clean.ls))
sm.mean.df <- bind_rows(sm.mean.ls)
sm.mean.df$eco <- eco.df[match(sm.mean.df$sit_name, eco.df$sit_name), "eco"]
sm.mean.df$wrm <- wrm.df[match(sm.mean.df$sit_name, wrm.df$sit_name), "wrm"]
sm.mean.df$biome <- eco.df[match(sm.mean.df$sit_name, eco.df$sit_name), "biome"]
sm.mean.df <- cbind(sm.mean.df, mat.map.df[match(sm.mean.df$sit_name, mat.map.df$sit_name), c("MAT", "MAP")])
sm.mean.df$tDif <- as.numeric(str_extract(sm.mean.df$dif, "\\d+\\.*\\d*"))
p <- sm.mean.df %>%
  filter(heatDur == "all year") %>%
  mutate(eco = factor(
    eco, 
    levels = c("boreal forest", "temperate forest", "tropical forest",
               "cropland", "grassland", "tundra"), ordered = TRUE),
    sit_name_T = paste0(sit_name, " (", tDif, ")")) %>%
  mutate(sit_name_T = fct_reorder(sit_name_T, tDif)) %>%
  ggplot(., aes(mean, sit_name_T, color = eco)) +
  geom_vline(xintercept = 0) +
  # geom_errorbarh(
  #   aes(xmin = ci.05, xmax = ci.95, linetype = growSeas), 
  #   alpha = .5) +
  geom_errorbarh(
    aes(xmin = mean - sd, xmax = mean + sd, linetype = growSeas), 
    alpha = .5) +
  geom_point(
    aes(size = tDif, shape = growSeas)) +
  scale_size_continuous(name = "Target warming\n(°C)", range = c(1, 9), breaks = c(2, 4, 6, 8)) +
  scale_linetype_manual(
    name = "", 
    values = c("growing season" = 1, "non-growing season" = 3)) +
  scale_shape_manual(
    name = "",
    values = c("growing season" = 16, "non-growing season" = 1)) +
  scale_color_manual(
    name = "",
    values = c("cropland" = "#bf535f",
               "grassland" = "#b7bce4",
               "tundra" = "#535fbf",
               "tropical forest" = "#bce4b7",
               "temperate forest" = "#5fbf53",
               "boreal forest" = "#398030")) +
  # expand_limits(y = c(-1, length(unique(sm.mean.df$sit_name)) + 2)) +
  guides(color = guide_legend(override.aes = list(size = 5)),
         shape = guide_legend(override.aes = list(size = 5))) +
  labs(x = "mean (trt - ctl), %VWC") +
  theme_bw() +
  theme(panel.grid = element_blank(),
        axis.title.y = element_blank(),
        # Adjusting legend text size
        legend.text = element_text(size = 32),
        legend.title = element_text(size = 32),
        # Adjusting x-axis text size
        axis.text.x = element_text(size = 24),
        # Adjusting x-axis title size
        axis.title.x = element_text(size = 24),
        # Adjusting y-axis text size
        axis.text.y = element_text(size = 12),
        # Adjusting strip text size
        strip.text = element_text(size = 24))

ggsave(
    filename = "../docs/EGU25/mean_difSM_gsHD_sd.png",
    plot = p,
    height = 23.62, 
    width = 37.94, 
    dpi = 300,
    units = "cm")
```


## SM dif, GS+dC

```{r sm-dif-gs-depth}
sm.mean.ls <- setNames(lapply(seq_along(moist.clean.ls), function(i) {

  # get index for growing season ls
  ix <- which(grepl(names(moist.clean.ls)[i], names(gs.ls)))
  GS <- gs.ls[[ix]] 
  if (ix == 4) {
    GS$sit_name <- ifelse(grepl("loquet", GS$sit_name), "B4WarmED_cloquet", "B4WarmED_ely")
    GS <- rbind(GS, GS) %>%
      mutate(sit_name = paste0(rep(GS$sit_name, 2), rep(c("_open","_closed"), ea = 2)))
  }
  
  df <- moist.clean.ls[[i]][["subDaily"]]
  ix.dif <- grep("- control", names(df))
  if (units.ls[[i]] == "ppn") {
    for (j in seq_along(ix.dif)) {
      df[[ix.dif[j]]] <- df[[ix.dif[j]]] * 100  
    }
  }
  if (length(grep("depth", names(df))) == 2) {
    df$depth <- mean(c(as.numeric(df$depth_upper), as.numeric(df$depth_lower)))
  }
 if (any(grepl("sit_name", names(df)))) {
    df$sit_name <- paste0(names(moist.clean.ls[i]), "_", df$sit_name)
  } else {
    df$sit_name <- names(moist.clean.ls[i])
    GS$sit_name <- GS$exp_name
  }
  df %>%
    filter(!is.na(date)) %>%
    left_join(GS[ , c("sit_name", "sos", "eos")], by = "sit_name") %>%
    mutate(
      depth_cat = cut(
        as.numeric(depth), 
        breaks = c(0, 10, 30, 50, Inf),
        include.lowest = TRUE, 
        right = TRUE),
      doy = as.numeric(strftime(date, format = "%j")),
      growSeas = ifelse(sos < eos,
                        ifelse(doy > sos & doy < eos,
                               "growing season", "non-growing season"),
                        ifelse(doy > sos | doy < eos, 
                               "growing season", "non-growing season"))) %>%
    group_by(sit_name, depth_cat, growSeas) %>%
    summarize(
      across(
        .cols = contains("- control"),
        .fns = list(mean = ~ mean(.x, na.rm = TRUE),
                    sd = ~ sd(.x, na.rm = TRUE),
                    n = ~ n())),
      .groups = "drop") %>%
   rowwise() %>%
      mutate(
        across(
          ends_with("_sd"),
          ~ . / sqrt(get(sub("_sd$", "_n", cur_column()))),
          .names = "{sub('_sd$', '', .col)}_se"),
        across(
          ends_with("_mean"),
          ~ . - qt(1 - (0.05 / 2), df = get(sub("_mean$", "_n", cur_column()))) * get(sub("_mean$", "_se", cur_column())),
          .names = "{sub('_mean$', '', .col)}_ci.05"),
        across(
          ends_with("_mean"),
          ~ . + qt(1 - (0.05 / 2), df = get(sub("_mean$", "_n", cur_column()))) * get(sub("_mean$", "_se", cur_column())),
          .names = "{sub('_mean$', '', .col)}_ci.95")) %>%
      ungroup() %>%
      select(sit_name, depth_cat, growSeas, contains("_mean"), contains("_ci.")) %>%
      pivot_longer(
        cols = contains("- control"),
        names_to = c("dif", ".value"),
        names_pattern = "^(.*)_(.*)$")
  }), nm = names(moist.clean.ls))
sm.mean.df <- bind_rows(sm.mean.ls)
sm.mean.df$eco <- eco.df[match(sm.mean.df$sit_name, eco.df$sit_name), "eco"]
sm.mean.df$wrm <- wrm.df[match(sm.mean.df$sit_name, wrm.df$sit_name), "wrm"]
sm.mean.df$biome <- eco.df[match(sm.mean.df$sit_name, eco.df$sit_name), "biome"]
sm.mean.df <- cbind(sm.mean.df, mat.map.df[match(sm.mean.df$sit_name, mat.map.df$sit_name), c("MAT", "MAP")])
sm.mean.df$tDif <- as.numeric(str_extract(sm.mean.df$dif, "\\d+\\.*\\d*"))
sm.mean.df %>%
  mutate(eco = factor(
    eco, 
    levels = c("boreal forest", "temperate forest", "tropical forest",
               "cropland", "grassland", "tundra")),
    ordered = TRUE) %>%
  arrange(eco) %>%
  mutate(sit_name = ordered(sit_name, levels = unique(sit_name))) %>%
  ggplot(., aes(mean, sit_name, color = eco, group = )) +
  geom_vline(xintercept = 0) +
  geom_errorbarh(
    aes(xmin = ci.05, xmax = ci.95, linetype = growSeas), 
    alpha = .5) +
  geom_point(
    aes(size = tDif, shape = growSeas)) +
  scale_size_continuous(name = "tDif", range = c(1, 9), breaks = c(2, 4, 6, 8)) +
  scale_linetype_manual(
    name = "", 
    values = c("growing season" = 1, "non-growing season" = 2)) +
  scale_shape_manual(
    name = "",
    values = c("growing season" = 16, "non-growing season" = 1)) +
  scale_color_manual(
    name = "",
    values = c("cropland" = "#bf535f",
               "grassland" = "#b7bce4",
               "tundra" = "#535fbf",
               "tropical forest" = "#bce4b7",
               "temperate forest" = "#5fbf53",
               "boreal forest" = "#398030")) +
  expand_limits(y = c(-1, length(unique(sm.mean.df$sit_name)) + 2)) +
  guides(color = guide_legend(override.aes = list(size = 5)),
         shape = guide_legend(override.aes = list(size = 5))) +
  labs(x = "mean (trt - ctl), %VWC") +
  facet_grid(rows = vars(depth_cat)) +
  theme_bw() +
  theme(panel.grid = element_blank(),
        axis.title.y = element_blank(),
        # Adjusting legend text size
        legend.text = element_text(size = 32),
        # Adjusting x-axis text size
        axis.text.x = element_text(size = 24),
        # Adjusting x-axis title size
        axis.title.x = element_text(size = 24),
        # Adjusting y-axis text size
        axis.text.y = element_text(size = 12),
        # Adjusting strip text size
        strip.text = element_text(size = 24))
```

## SM dif, GS+d

```{r sm-dif-gs-depth}
sm.mean.ls <- setNames(lapply(seq_along(moist.clean.ls), function(i) {
  
  # get index for growing season ls
  ix <- which(grepl(names(moist.clean.ls)[i], names(gs.ls)))
  GS <- gs.ls[[ix]] 
  if (ix == 4) {
    GS$sit_name <- ifelse(grepl("loquet", GS$sit_name), "B4WarmED_cloquet", "B4WarmED_ely")
    GS <- rbind(GS, GS) %>%
      mutate(sit_name = paste0(rep(GS$sit_name, 2), rep(c("_open","_closed"), ea = 2)))
  }
  
  df <- moist.clean.ls[[i]][["subDaily"]]
  ix.dif <- grep("- control", names(df))
  if (units.ls[[i]] == "ppn") {
    for (j in seq_along(ix.dif)) {
      df[[ix.dif[j]]] <- df[[ix.dif[j]]] * 100  
    }
  }
  if (length(grep("depth", names(df))) == 2) {
    df$depth <- mean(c(as.numeric(df$depth_upper), as.numeric(df$depth_lower)))
  }
 if (any(grepl("sit_name", names(df)))) {
    df$sit_name <- paste0(names(moist.clean.ls[i]), "_", df$sit_name)
  } else {
    df$sit_name <- names(moist.clean.ls[i])
    GS$sit_name <- GS$exp_name
  }
  
  # get heating duration
  if (any(names(moist.clean.ls)[i] %in% yr)) {
    df$heatDur <- "all year"
  } else {
    df$heatDur <- "partial"
  }
  
  df %>%
    filter(!is.na(date)) %>%
    left_join(GS[ , c("sit_name", "sos", "eos")], by = "sit_name") %>%
    mutate(
      doy = as.numeric(strftime(date, format = "%j")),
      growSeas = ifelse(sos < eos,
                        ifelse(doy > sos & doy < eos,
                               "growing season", "non-growing season"),
                        ifelse(doy > sos | doy < eos, 
                               "growing season", "non-growing season"))) %>%
    group_by(sit_name, depth, growSeas, heatDur) %>%
    summarize(
      across(
        .cols = contains("- control"),
        .fns = list(mean = ~ mean(.x, na.rm = TRUE),
                    sd = ~ sd(.x, na.rm = TRUE),
                    n = ~ n())),
      .groups = "drop") %>%
   rowwise() %>%
      mutate(
        across(
          ends_with("_sd"),
          ~ . / sqrt(get(sub("_sd$", "_n", cur_column()))),
          .names = "{sub('_sd$', '', .col)}_se"),
        across(
          ends_with("_mean"),
          ~ . - qt(1 - (0.05 / 2), df = get(sub("_mean$", "_n", cur_column()))) * get(sub("_mean$", "_se", cur_column())),
          .names = "{sub('_mean$', '', .col)}_ci.05"),
        across(
          ends_with("_mean"),
          ~ . + qt(1 - (0.05 / 2), df = get(sub("_mean$", "_n", cur_column()))) * get(sub("_mean$", "_se", cur_column())),
          .names = "{sub('_mean$', '', .col)}_ci.95")) %>%
      ungroup() %>%
      select(sit_name, depth, heatDur, growSeas, contains("_mean"), contains("_ci.")) %>%
      pivot_longer(
        cols = contains("- control"),
        names_to = c("dif", ".value"),
        names_pattern = "^(.*)_(.*)$")
  }), nm = names(moist.clean.ls))
sm.mean.df <- bind_rows(sm.mean.ls, .id = "exp_name")
sm.mean.df$eco <- eco.df[match(sm.mean.df$sit_name, eco.df$sit_name), "eco"]
sm.mean.df$wrm <- wrm.df[match(sm.mean.df$sit_name, wrm.df$sit_name), "wrm"]
sm.mean.df$biome <- eco.df[match(sm.mean.df$sit_name, eco.df$sit_name), "biome"]
sm.mean.df <- cbind(sm.mean.df, mat.map.df[match(sm.mean.df$sit_name, mat.map.df$sit_name), c("MAT", "MAP")])
sm.mean.df$tDif <- as.numeric(str_extract(sm.mean.df$dif, "\\d+\\.*\\d*"))
p <- sm.mean.df %>%
  group_by(sit_name) %>%
  # filter(n_distinct(depth) > 1) %>%
  ungroup() %>%
  mutate(eco = factor(
    eco, 
    levels = c("boreal forest", "temperate forest", "tropical forest",
               "cropland", "grassland", "tundra")),
    ordered = TRUE) %>%
  arrange(eco) %>%
  mutate(tDif_sit_name_gs = paste0(tDif, sit_name, growSeas)) %>%
  ggplot(., aes(mean, depth, color = eco, group = tDif_sit_name_gs)) +
  geom_vline(xintercept = 0) +
  geom_errorbarh(
    aes(xmin = ci.05, xmax = ci.95, linetype = growSeas), 
    alpha = .5) +
  geom_point(
    aes(size = tDif, shape = growSeas)) +
  geom_path() +
  scale_linetype_manual(
    name = "", 
    values = c("growing season" = 1, "non-growing season" = 2)) +
  scale_shape_manual(
    name = "",
    values = c("growing season" = 16, "non-growing season" = 1)) +
  scale_color_manual(
    name = "",
    values = c("cropland" = "#bf535f",
               "grassland" = "#b7bce4",
               "tundra" = "#535fbf",
               "tropical forest" = "#bce4b7",
               "temperate forest" = "#5fbf53",
               "boreal forest" = "#398030")) +
  scale_size_continuous(name = "°C", range = c(2, 8), breaks = c(2, 4, 6, 8)) +
  scale_y_reverse() +
  guides(color = guide_legend(override.aes = list(size = 5), ncol = 2, order = 2),
         linetype = guide_legend(ncol = 1, order = 3),
         size = guide_legend(title.position = "top", ncol = 1, order = 1),
         shape = guide_legend(override.aes = list(size = 5), order = 3, ncol = 1)) +
  labs(x = "mean (trt - ctl), %VWC") +
  facet_grid(cols = vars(eco), scales = "free_x") +
  theme_bw() +
  theme(panel.grid = element_blank(),
        legend.position = "bottom",
        axis.title.y = element_blank(),
        # Adjusting legend text size
        legend.text = element_text(size = 28),
        legend.title = element_text(size = 32),
        # Adjusting x-axis text size
        axis.text.x = element_text(size = 18),
        # Adjusting x-axis title size
        axis.title.x = element_text(size = 24),
        # Adjusting y-axis text size
        axis.text.y = element_text(size = 18),
        # Adjusting strip text size
        strip.text = element_text(size = 20))

ggsave(
    filename = "../docs/EGU25/mean_difSM_gsDpt.png",
    plot = p,
    height = 23.62, 
    width = 37.94, 
    dpi = 300,
    units = "cm")

# 
# # Prepare data with both growing and non-growing season in same row
# sm_polygon_df <- sm.mean.df %>%
#   filter(growSeas %in% c("growing season", "non-growing season")) %>%
#   select(sit_name, eco, depth, growSeas, mean, tDif) %>%
#   pivot_wider(
#     names_from = growSeas,
#     values_from = mean,
#     names_prefix = "mean_"
#   ) %>%
#   filter(!is.na(`mean_growing season`), !is.na(`mean_non-growing season`)) %>%
#   arrange(eco, sit_name, depth)
# 
# # Construct polygon: for each group, go down one line and up the other to form a closed polygon
# polygon_data <- sm_polygon_df %>%
#   group_by(sit_name, eco, tDif) %>%
#   arrange(depth) %>%
#   summarise(
#     depth = c(depth, rev(depth)),
#     mean = c(`mean_growing season`, rev(`mean_non-growing season`)),
#     .groups = "drop"
#   )
# 
# # Base plot
# sm.mean.df %>%
#   mutate(eco = factor(
#     eco,
#     levels = c("boreal forest", "temperate forest", "tropical forest",
#                "cropland", "grassland", "tundra"),
#     ordered = TRUE)) %>%
#   arrange(eco) %>%
#   mutate(tDif_sit_name_gs = paste0(tDif, sit_name, growSeas)) %>%
#   ggplot(aes(mean, depth, color = eco, group = tDif_sit_name_gs)) +
# 
#   # Add polygon
#   geom_polygon(
#     data = polygon_data,
#     aes(x = mean, y = depth, group = interaction(sit_name, eco, tDif), fill = eco),
#     alpha = 0.2,
#     inherit.aes = FALSE
#   ) +
# 
#   geom_vline(xintercept = 0) +
#   geom_errorbarh(
#     aes(xmin = ci.05, xmax = ci.95, linetype = growSeas),
#     alpha = .5) +
#   geom_point(
#     aes(size = tDif, shape = growSeas)) +
#   geom_path() +
#   scale_linetype_manual(
#     name = "",
#     values = c("growing season" = 1, "non-growing season" = 2)) +
#   scale_shape_manual(
#     name = "",
#     values = c("growing season" = 16, "non-growing season" = 1)) +
#   scale_color_manual(
#     name = "",
#     values = c("cropland" = "#bf535f",
#                "grassland" = "#b7bce4",
#                "tundra" = "#535fbf",
#                "tropical forest" = "#bce4b7",
#                "temperate forest" = "#5fbf53",
#                "boreal forest" = "#398030")) +
#   scale_fill_manual(
#     name = "",
#     values = c("cropland" = "#bf535f",
#                "grassland" = "#b7bce4",
#                "tundra" = "#535fbf",
#                "tropical forest" = "#bce4b7",
#                "temperate forest" = "#5fbf53",
#                "boreal forest" = "#398030")) +
#   scale_size_continuous(name = "°C", range = c(2, 8), breaks = c(2, 4, 6, 8)) +
#   scale_y_reverse() +
#   guides(color = guide_legend(override.aes = list(size = 5), ncol = 2, order = 2),
#          fill = "none",
#          linetype = guide_legend(ncol = 1, order = 3),
#          size = guide_legend(title.position = "top", ncol = 1, order = 1),
#          shape = guide_legend(override.aes = list(size = 5), order = 3, ncol = 1)) +
#   labs(x = "mean (trt - ctl), %VWC") +
#   facet_grid(cols = vars(eco), scales = "free_x") +
#   theme_bw() +
#   theme(panel.grid = element_blank(),
#         legend.position = "bottom",
#         axis.title.y = element_blank(),
#         legend.text = element_text(size = 28),
#         legend.title = element_text(size = 32),
#         axis.text.x = element_text(size = 18),
#         axis.title.x = element_text(size = 24),
#         axis.text.y = element_text(size = 18),
#         strip.text = element_text(size = 20))
```
## SM dif, d

```{r sm-dif-depth}
sm.mean.ls <- setNames(lapply(seq_along(moist.clean.ls), function(i) {
  
  df <- moist.clean.ls[[i]][["subDaily"]]
  ix.dif <- grep("- control", names(df))
  if (units.ls[[i]] == "ppn") {
    for (j in seq_along(ix.dif)) {
      df[[ix.dif[j]]] <- df[[ix.dif[j]]] * 100  
    }
  }
  if (length(grep("depth", names(df))) == 2) {
    df$depth <- mean(c(as.numeric(df$depth_upper), as.numeric(df$depth_lower)))
  }
 if (any(grepl("sit_name", names(df)))) {
    df$sit_name <- paste0(names(moist.clean.ls[i]), "_", df$sit_name)
  } else {
    df$sit_name <- names(moist.clean.ls[i])
  }
  
  df %>%
    filter(!is.na(date)) %>%
    group_by(sit_name, depth) %>%
    summarize(
      across(
        .cols = contains("- control"),
        .fns = list(mean = ~ mean(.x, na.rm = TRUE),
                    sd = ~ sd(.x, na.rm = TRUE),
                    n = ~ n())),
      .groups = "drop") %>%
   rowwise() %>%
      mutate(
        across(
          ends_with("_sd"),
          ~ . / sqrt(get(sub("_sd$", "_n", cur_column()))),
          .names = "{sub('_sd$', '', .col)}_se"),
        across(
          ends_with("_mean"),
          ~ . - qt(1 - (0.05 / 2), df = get(sub("_mean$", "_n", cur_column()))) * get(sub("_mean$", "_se", cur_column())),
          .names = "{sub('_mean$', '', .col)}_ci.05"),
        across(
          ends_with("_mean"),
          ~ . + qt(1 - (0.05 / 2), df = get(sub("_mean$", "_n", cur_column()))) * get(sub("_mean$", "_se", cur_column())),
          .names = "{sub('_mean$', '', .col)}_ci.95")) %>%
      ungroup() %>%
      select(sit_name, depth, contains("_mean"), contains("_ci."), contains("_sd")) %>%
      pivot_longer(
        cols = contains("- control"),
        names_to = c("dif", ".value"),
        names_pattern = "^(.*)_(.*)$")
  }), nm = names(moist.clean.ls))
sm.mean.df <- bind_rows(sm.mean.ls, .id = "exp_name")
sm.mean.df$eco <- eco.df[match(sm.mean.df$sit_name, eco.df$sit_name), "eco"]
sm.mean.df$wrm <- wrm.df[match(sm.mean.df$sit_name, wrm.df$sit_name), "wrm"]
sm.mean.df$biome <- eco.df[match(sm.mean.df$sit_name, eco.df$sit_name), "biome"]
sm.mean.df <- cbind(sm.mean.df, mat.map.df[match(sm.mean.df$sit_name, mat.map.df$sit_name), c("MAT", "MAP")])
sm.mean.df$tDif <- as.numeric(str_extract(sm.mean.df$dif, "\\d+\\.*\\d*"))
p <- sm.mean.df %>%
  group_by(sit_name) %>%
  # filter(n_distinct(depth) > 1) %>%
  ungroup() %>%
  mutate(eco = factor(
    eco, 
    levels = c("boreal forest", "temperate forest", "tropical forest",
               "cropland", "grassland", "tundra")),
    ordered = TRUE) %>%
  arrange(eco) %>%
  mutate(tDif_sit_name = paste0(tDif, sit_name)) %>%
  ggplot(., aes(mean, depth, color = tDif, group = tDif_sit_name)) +
  geom_vline(xintercept = 0) +
  geom_path(linewidth = 1) +
  # geom_errorbarh(
  #   aes(xmin = ci.05, xmax = ci.95), 
  #   alpha = .5) +
  geom_errorbarh(
    aes(xmin = mean - sd, xmax = mean + sd), 
    linetype = 2) +
  geom_point(
    aes(shape = wrm), size = 5, stroke = 1) +
  # scale_color_manual(
  #   name = "",
  #   values = c("cropland" = "#bf535f",
  #              "grassland" = "#b7bce4",
  #              "tundra" = "#535fbf",
  #              "tropical forest" = "#bce4b7",
  #              "temperate forest" = "#5fbf53",
  #              "boreal forest" = "#398030")) +
  scale_color_viridis(name = "°C", option = "C", begin = .35, end = .9) +
  scale_shape_manual(
    name = "",
    values = c("below" = 25, 
               "above (IR)/below" = 7, 
               "above (OTC)/below" = 12, 
               "above (FA)/below" = 13, 
               "above (IR)" = 2, 
               "above (snow)" = 8)) +
  scale_y_reverse(breaks = seq(0, 140, 20)) +
  guides(shape = guide_legend(override.aes = list(size = 5), order = 1, ncol = 2),
         color = guide_colorbar(title.position = "top", label.theme = element_text(size = 18), title.theme = element_text(size = 22)),) +
  labs(x = "mean (trt - ctl), %VWC") +
  facet_wrap(vars(eco), scales = "free") +
  theme_bw() +
  theme(panel.grid.minor = element_blank(),
        legend.position = "bottom",
        axis.title.y = element_blank(),
        # Adjusting legend text size
        legend.text = element_text(size = 28),
        legend.title = element_text(size = 32),
        # Adjusting x-axis text size
        axis.text.x = element_text(size = 18),
        # Adjusting x-axis title size
        axis.title.x = element_text(size = 24),
        # Adjusting y-axis text size
        axis.text.y = element_text(size = 18),
        # Adjusting strip text size
        strip.text = element_text(size = 20))

ggsave(
    filename = "../docs/EGU25/mean_difSM_Dpt_sd.png",
    plot = p,
    height = 23.62, 
    width = 37.94, 
    dpi = 300,
    units = "cm")
```


```{r raw-sm}
sm.raw.mean.ls <- setNames(lapply(seq_along(moist.clean.ls), function(i) {
  
  # get index for growing season ls
  ix <- which(grepl(names(moist.clean.ls)[i], names(gs.ls)))
  GS <- gs.ls[[ix]] 
  
  df <- moist.clean.ls[[i]][["subDaily"]]
  ix.ct <- unique(c(grep("control", names(df)), grep("treatment", names(df))))
  if (units.ls[[i]] == "ppn") {
    for (j in seq_along(ix.ct)) {
      df[[ix.ct[j]]] <- df[[ix.ct[j]]] * 100  
    }
  }
  if (length(grep("depth", names(df))) == 2) {
    df$depth <- rowMeans(df[ , c("depth_upper", "depth_lower")])
  }
  if (any(grepl("sit_name", names(df)))) {
    df$sit_name <- paste0(names(moist.clean.ls[i]), "_", df$sit_name)
  } else {
    df$sit_name <- names(moist.clean.ls[i])
  }
  df %>%
    select(control, depth, starts_with("treatment"), date, sit_name) %>%
    group_by(sit_name, depth) %>%
    summarize(
      across(
        .cols = c(control, starts_with("treatment")),
        .fns = list(mean = ~ mean(.x, na.rm = TRUE),
                    sd = ~ sd(.x, na.rm = TRUE),
                    n = ~ n())),
      .groups = "drop") %>%
   rowwise() %>%
      mutate(
        across(
          ends_with("_sd"),
          ~ . / sqrt(get(sub("_sd$", "_n", cur_column()))),
          .names = "{sub('_sd$', '', .col)}_se"),
        across(
          ends_with("_mean"),
          ~ . - qt(1 - (0.05 / 2), df = get(sub("_mean$", "_n", cur_column()))) * get(sub("_mean$", "_se", cur_column())),
          .names = "{sub('_mean$', '', .col)}_ci.05"),
        across(
          ends_with("_mean"),
          ~ . + qt(1 - (0.05 / 2), df = get(sub("_mean$", "_n", cur_column()))) * get(sub("_mean$", "_se", cur_column())),
          .names = "{sub('_mean$', '', .col)}_ci.95")) %>%
      ungroup() %>%
      select(sit_name, depth, contains("_mean"), contains("_ci."), contains("_sd")) %>%
      pivot_longer(
        cols = c(contains("control"), contains("treatment")),
        names_to = c("stat", ".value"),
        names_pattern = "^(.*)_(.*)$")
  }), nm = names(moist.clean.ls))
sm.raw.mean.df <- bind_rows(sm.raw.mean.ls)
sm.raw.mean.df$eco <- eco.df[match(sm.raw.mean.df$sit_name, eco.df$sit_name), "eco"]
sm.raw.mean.df$wrm <- wrm.df[match(sm.raw.mean.df$sit_name, wrm.df$sit_name), "wrm"]
sm.raw.mean.df$biome <- eco.df[match(sm.raw.mean.df$sit_name, eco.df$sit_name), "biome"]
sm.raw.mean.df <- cbind(sm.raw.mean.df, mat.map.df[match(sm.raw.mean.df$sit_name, mat.map.df$sit_name), c("MAT", "MAP")])

sm.ctl.mean.df <- sm.raw.mean.df %>%
  filter(stat == "control") %>%
  select(-stat)
sm.trt.dif.mean.df <- sm.raw.mean.df %>%
  filter(stat != "control") %>%
  mutate(tDif = as.numeric(str_extract(stat, "\\d+\\.*\\d*")))
sm.trt.mean.df <- sm.trt.dif.mean.df %>%
  filter(!grepl("-", stat)) %>%
  select(-stat)
sm.dif.mean.df <- sm.trt.dif.mean.df %>%
  filter(grepl("-", stat)) %>%
  select(-stat)
sm.raw.mean.df2 <- left_join(
  left_join(
    sm.trt.mean.df,
    sm.dif.mean.df,
    by = c("sit_name", "depth", "eco", "wrm", "biome", "MAT", "MAP", "tDif"),
    suffix = c("_trt", "_dif")),
  sm.ctl.mean.df,
  by = c("sit_name", "depth", "eco", "wrm", "biome", "MAT", "MAP"))

sm.raw.mean.df2 %>%
  mutate(sit_nameTdif = paste0(sit_name, tDif)) %>%
  ggplot(., aes(mean_dif, depth, color = eco, group = sit_nameTdif)) +
  geom_vline(xintercept = 0, linetype = "dashed") +
  # geom_errorbarh(
  #   aes(xmin = mean - sd, xmax = mean + sd),
  #   alpha = .5) +
  # geom_errorbarh(
  #   aes(xmin = mean_dif - sd_dif, xmax = mean_dif + sd_dif),
  #   alpha = .5) +
  geom_point(aes(size = tDif)) +
  geom_path() +
  scale_size_continuous(name = "heating (°C)", range = c(1, 9), breaks = c(2, 4, 6, 8)) +
  scale_color_manual(
    name = "",
    values = c("cropland" = "#bf535f",
               "grassland" = "#b7bce4",
               "tundra" = "#535fbf",
               "tropical forest" = "#bce4b7",
               "temperate forest" = "#5fbf53",
               "boreal forest" = "#398030")) +
  scale_y_reverse() +
  guides(color = guide_legend(override.aes = list(size = 5), ncol = 2),
         size = guide_legend(ncol = 1),
         shape = guide_legend(override.aes = list(size = 3), ncol = 2)) +
  theme_bw() +
  theme(panel.grid = element_blank(),
        legend.title.position = "top",
        legend.position = "bottom")
```

```{r sm-models}
sm.daily.raw.ls <- setNames(lapply(seq_along(moist.clean.ls), function(i) {
  df <- moist.clean.ls[[i]][["subDaily"]]
  ix.ct <- unique(c(grep("control", names(df)), grep("treatment", names(df))))
  # trt.ix <- names(df)[which(grepl("treatment", names(df)))]
  # trt_nm <- trt.ix[which(nchar(trt.ix) == min(nchar(trt.ix)))]
  if (units.ls[[i]] == "ppn") {
    for (j in seq_along(ix.ct)) {
      df[[ix.ct[j]]] <- df[[ix.ct[j]]] * 100  
    }
  }
  if (length(grep("depth", names(df))) == 2) {
    df$depth <- rowMeans(df[ , c("depth_upper", "depth_lower")])
  }
  if (any(grepl("sit_name", names(df)))) {
    df$sit_name <- paste0(names(moist.clean.ls[i]), "_", df$sit_name)
  } else {
    df$sit_name <- names(moist.clean.ls[i])
  }
  df %>%
    mutate(day = date(date)) %>%
    group_by(sit_name, date) %>%
    summarize(
      across(
        .cols = c(control, starts_with("treatment")),
        .fns = list(mean = ~ mean(.x, na.rm = TRUE),
                    sd = ~ sd(.x, na.rm = TRUE),
                    n = ~ n())),
      .groups = "drop") %>%
   rowwise() %>%
      mutate(
        across(
          ends_with("_sd"),
          ~ . / sqrt(get(sub("_sd$", "_n", cur_column()))),
          .names = "{sub('_sd$', '', .col)}_se"),
        across(
          ends_with("_mean"),
          ~ . - qt(1 - (0.05 / 2), df = get(sub("_mean$", "_n", cur_column()))) * get(sub("_mean$", "_se", cur_column())),
          .names = "{sub('_mean$', '', .col)}_ci.05"),
        across(
          ends_with("_mean"),
          ~ . + qt(1 - (0.05 / 2), df = get(sub("_mean$", "_n", cur_column()))) * get(sub("_mean$", "_se", cur_column())),
          .names = "{sub('_mean$', '', .col)}_ci.95")) %>%
      ungroup() %>%
      select(sit_name, contains("_mean"), contains("_ci.")) %>%
      pivot_longer(
        cols = c(contains("control"), contains("treatment")),
        names_to = c("stat", ".value"),
        names_pattern = "^(.*)_(.*)$")
  }), nm = names(moist.clean.ls))

sm.raw.mean.df <- bind_rows(sm.raw.mean.ls)
sm.raw.mean.df$eco <- eco.df[match(sm.raw.mean.df$sit_name, eco.df$sit_name), "eco"]
sm.raw.mean.df$wrm <- wrm.df[match(sm.raw.mean.df$sit_name, wrm.df$sit_name), "wrm"]
sm.raw.mean.df$biome <- eco.df[match(sm.raw.mean.df$sit_name, eco.df$sit_name), "biome"]
sm.raw.mean.df <- cbind(sm.raw.mean.df, mat.map.df[match(sm.raw.mean.df$sit_name, mat.map.df$sit_name), c("MAT", "MAP")])
```

```{r sm-mo}
# split by site, get driest and wettest months 
wet.dry.m.ls <- lapply(moist.clean.ls, function(x) {
  df <- x$subDaily
  if (length(grep("depth", names(df))) == 2) {
    df$depth <- mean(c(as.numeric(df$depth_upper), as.numeric(df$depth_lower)))
  }
  mm <- df %>%
    na.exclude() %>%
    mutate(month = month(date),
           year = year(date),
           ym = paste0(year, month)) %>%
    group_by(depth, ym) %>%
    summarize(
      across(control, list(mean = mean)), .groups = "drop")
  bind_rows(lapply(split(mm, mm$depth), function(y) {
      list(min = y[which(y$control_mean == min(y$control_mean)), "ym"],
           max = y[which(y$control_mean == max(y$control_mean)), "ym"])
  }), .id = "depth")
})
wet.dry.m.1.df <- bind_rows(lapply(wet.dry.m.ls, function(x) x[1, ]), .id = "exp_name")
wet.dry.m.df <- bind_rows(wet.dry.m.ls, .id = "exp_name")

sm.mean.m.ls <- setNames(lapply(seq_along(moist.clean.ls), function(i) {
  df <- moist.clean.ls[[i]][["subDaily"]]
  ix.dif <- grep("- control", names(df))
  if (units.ls[[i]] == "ppn") {
    for (j in seq_along(ix.dif)) {
      df[[ix.dif[j]]] <- df[[ix.dif[j]]] * 100  
    }
  }
  if (length(grep("depth", names(df))) == 2) {
    df$depth <- mean(c(as.numeric(df$depth_upper), as.numeric(df$depth_lower)))
  }
  if (any(grepl("sit_name", names(df)))) {
    df$sit_name <- paste0(names(moist.clean.ls[i]), "_", df$sit_name)
  } else {
    df$sit_name <- names(moist.clean.ls[i])
  }
  df %>%
    mutate(depth = as.numeric(depth)) %>%
    mutate(depth = as.numeric(depth),
           depth_cat = cut(depth, breaks = c(0, 10, 30, 51, Inf)),
           month = month(date)) %>%
    group_by(sit_name, depth_cat, month) %>%
    summarize(
      across(
        .cols = c(contains("control"), contains("treatment")),
        .fns = list(mean = ~ mean(.x, na.rm = TRUE),
                    sd = ~ sd(.x, na.rm = TRUE),
                    n = ~ n())),
      .groups = "drop") %>%
   rowwise() %>%
      mutate(
        across(
          ends_with("_sd"),
          ~ . / sqrt(get(sub("_sd$", "_n", cur_column()))),
          .names = "{sub('_sd$', '', .col)}_se"),
        across(
          ends_with("_mean"),
          ~ . - qt(1 - (0.05 / 2), df = get(sub("_mean$", "_n", cur_column()))) * get(sub("_mean$", "_se", cur_column())),
          .names = "{sub('_mean$', '', .col)}_ci.05"),
        across(
          ends_with("_mean"),
          ~ . + qt(1 - (0.05 / 2), df = get(sub("_mean$", "_n", cur_column()))) * get(sub("_mean$", "_se", cur_column())),
          .names = "{sub('_mean$', '', .col)}_ci.95")) %>%
      ungroup() %>%
      select(sit_name, month, depth_cat, contains("_mean"), contains("_ci."), contains("_sd")) %>%
      pivot_longer(
        cols = c(contains("control"), contains("treatment")),
        names_to = c("stat", ".value"),
        names_pattern = "^(.*)_(.*)$")
  }), nm = names(moist.clean.ls))
sm.mean.m.df <- bind_rows(sm.mean.m.ls)
sm.mean.m.df2 <- left_join(
  sm.mean.m.df, 
  sm.raw.mean.df2 %>%
    select(sit_name, eco, wrm, biome, MAT, MAP), 
  by = "sit_name",
  multiple = "first")

p <- sm.mean.m.df %>%
  mutate(mean = ifelse(sit_name == "SPRUCE" & mean > .2, NA, mean)) %>%
  filter(!is.na(month)) %>%
  mutate(`temp. dif.` = as.numeric(str_extract(dif, "\\d+\\.*\\d*")),
         jitter_offset = runif(n(), -0.2, 0.2),
         group = paste0(sit_name, `temp. dif.`)) %>%
  rename(`site name` = sit_name) %>%
  ggplot(., aes(month, mean, color = `site name`, group = group)) +
  geom_hline(yintercept = 0) +
  geom_line() + 
  # geom_errorbar(
  #   aes(x = month + jitter_offset, ymin = ci.05, ymax = ci.95), 
  #   alpha = .5, width = .2) +
  geom_point(
    aes(x = month + jitter_offset, mean, shape = biome, size = `temp. dif.`)) +
  scale_size_continuous(range = c(1, 9), breaks = c(2, 4, 6, 8)) +
  scale_shape_manual(
    values = c("forest" = 7, "grassland" = 1)) +
  # scale_colour_gradientn(colors = terrain.colors(5)) + 
  scale_x_continuous(breaks = 1:12, labels = month.abb) +
  facet_grid(rows = vars(depth_cat)) +
  labs(y = "mean (trt - ctl), %VWC") +
  guides(color = guide_legend(override.aes = list(size = 5)),
         shape = guide_legend(override.aes = list(size = 5))) +
  theme_bw() +
  theme(panel.grid = element_blank(),
        axis.title.x = element_blank(),
        text = element_text(size = 24))

ggsave(
    filename = "../docs/AGU24/month_meanSMdif.png",
    plot = p,
    height = 23.62, 
    width = 37.94, 
    dpi = 300,
    units = "cm")



long.lat <- bind_rows(
      lapply(database, function(x) x$site[ , c("sit_long", "sit_lat")]), .id = "expName")
sm.mean.m.df2 <- sm.mean.m.df %>%
  mutate(
    sit_name = ifelse(
      sit_name == "one85ExperimentStation", "185ExperimentStation", sit_name),
    expName = sapply(sit_name, function(sit) {
      match <- x$expName[str_detect(sit, x$expName)]
      if (length(match) > 0) match else NA
    })) %>%
  left_join(long.lat, by = "expName")
sm.mean.m.ls <- split(sm.mean.m.df2, sm.mean.m.df2$month)
sm.mean.m.df3 <- bind_rows(lapply(seq_along(sm.mean.m.ls), function(i) {
  x <- sm.mean.m.ls[[i]]
  ai <- terra::extract(gai[[i]], x[, c("sit_long", "sit_lat")])
  names(ai)[2] <- "ai"
  cbind(x, ai = ai[, "ai"])
}))

summary(lmer(mean ~ depth_cat + wrm + (1 | sit_name), sm.mean.df))

p <- ggplot(sm.mean.df, aes(forcats::fct_infreq(eco), fill = eco)) +
  geom_bar() +
  scale_fill_brewer("", palette = "Paired") +
  theme_bw() +
  theme(panel.grid = element_blank(),
        axis.text.x = element_text(angle = 45, hjust = 1, size = 20),
        axis.text.y = element_text(size = 24),
        axis.title.y = element_text(size = 24),
        axis.title.x = element_blank(),
        legend.position = "none") 

ggsave(
    filename = "../docs/AGU24/eco.png",
    plot = p,
    height = 12.49, 
    width = 21.48, 
    dpi = 300,
    units = "cm")

```


# ST summary
## ST dif

```{r st-plot}
eco.df <- eco.df[-which(grepl("SMARTX", eco.df$sit_name))[1], ]
eco.df$sit_name <- ifelse(grepl("SMARTX", eco.df$sit_name), "SMARTX", eco.df$sit_name)
wrm.df <- wrm.df[-which(grepl("SMARTX", wrm.df$sit_name))[1], ]
wrm.df$sit_name <- ifelse(grepl("SMARTX", wrm.df$sit_name), "SMARTX", wrm.df$sit_name)

st.mean.ls <- setNames(lapply(seq_along(temp.clean.ls), function(i) {
  
  df <- temp.clean.ls[[i]][["subDaily"]]
  
  if (length(grep("depth", names(df))) == 2) {
    df$depth <- mean(c(as.numeric(df$depth_upper), as.numeric(df$depth_lower)))
  }
  
  if (any(grepl("sit_name", names(df)))) {
    df$sit_name <- paste0(names(temp.clean.ls[i]), "_", df$sit_name)
  } else {
    df$sit_name <- names(temp.clean.ls[i])
  }

  df %>%
    filter(!is.na(date)) %>%
    group_by(sit_name, depth) %>%
    summarize(
      across(
        .cols = contains("- control"),
        .fns = list(mean = ~ mean(.x, na.rm = TRUE),
                    sd = ~ sd(.x, na.rm = TRUE),
                    n = ~ n())),
      .groups = "drop") %>%
   rowwise() %>%
      mutate(
        across(
          ends_with("_sd"),
          ~ . / sqrt(get(sub("_sd$", "_n", cur_column()))),
          .names = "{sub('_sd$', '', .col)}_se"),
        across(
          ends_with("_mean"),
          ~ . - qt(1 - (0.05 / 2), df = get(sub("_mean$", "_n", cur_column()))) * get(sub("_mean$", "_se", cur_column())),
          .names = "{sub('_mean$', '', .col)}_ci.05"),
        across(
          ends_with("_mean"),
          ~ . + qt(1 - (0.05 / 2), df = get(sub("_mean$", "_n", cur_column()))) * get(sub("_mean$", "_se", cur_column())),
          .names = "{sub('_mean$', '', .col)}_ci.95")) %>%
      ungroup() %>%
      select(sit_name, depth, contains("_mean"), contains("_ci."), contains("_sd")) %>%
      pivot_longer(
        cols = contains("- control"),
        names_to = c("dif", ".value"),
        names_pattern = "^(.*)_(.*)$")
  }), nm = names(temp.clean.ls))
st.mean.d.df <- type.convert(bind_rows(lapply(st.mean.ls, function(x) x %>%  mutate_all(as.character))), as.is = TRUE)
st.mean.d.df$eco <- eco.df[match(st.mean.d.df$sit_name, eco.df$sit_name), "eco"]
st.mean.d.df$wrm <- wrm.df[match(st.mean.d.df$sit_name, wrm.df$sit_name), "wrm"]
st.mean.d.df$biome <- eco.df[match(st.mean.d.df$sit_name, eco.df$sit_name), "biome"]
st.mean.d.df <- cbind(st.mean.d.df, mat.map.df[match(st.mean.d.df$sit_name, mat.map.df$sit_name), c("MAT", "MAP")])
st.mean.d.df$tDif <- as.numeric(str_extract(st.mean.d.df$dif, "\\d+\\.*\\d*"))

# realized warming
tDifR.st.df <- bind_rows(lapply(seq_along(temp.clean.ls), function(i) {
  st.df <- temp.clean.ls[[i]]$dailySit
  if (length(grep("depth", names(st.df))) == 2) {
    st.df$depth <- mean(c(as.numeric(st.df$depth_upper), as.numeric(st.df$depth_lower)))
  }
  if (any(grepl("sit_name", names(st.df)))) {
    st.df$sit_name <- paste0(names(temp.clean.ls[i]), "_", st.df$sit_name)
  } else {
    st.df$sit_name <- names(temp.clean.ls[i])
  }
  st.df$tDif <- as.numeric(str_extract(st.df$dif, "\\d+\\.*\\d*"))
  st.df <- st.df %>% 
    group_by(sit_name, depth, tDif) %>%
    summarize(tDifR = mean(mean, na.rm = T), .groups = "drop")
  st.df <- type.convert(st.df, as.is = FALSE)
  return(data.frame(st.df))
}), .id = "exp_name")
st.mean.d.df <- merge(st.mean.d.df, tDifR.st.df)

# plot
eco_cols.st <- c(
  "cropland"          = "#E69F00",
  "grassland"         = "#56B4E9",  
  "tundra"            = "#0072B2",
  "tropical forest"   = "#BAE4B3", 
  "subtropical forest"= "#74C476", 
  "temperate forest"  = "#31A354", 
  "boreal forest"     = "#006D2C",
  "saltmarsh"         ="#CC79A7")
p <- st.mean.d.df %>%
  group_by(sit_name) %>%
  filter(n_distinct(depth) > 1) %>%
  ungroup() %>%
  mutate(
    # eco = recode(
    #   eco,
    #   "boreal forest" = "a) boreal forest", 
    #   "temperate forest" = "b) temperate forest", 
    #   "subtropical forest" = "c) subtropical forest", 
    #   "tropical forest" = "d) tropical forest",
    #   "cropland" = "e) cropland", 
    #   "grassland" = "f) grassland",
    #   "tundra" = "g) tundra",
    #   "temperate saltmarsh" = "h) saltmarsh"),
    eco = recode(eco, "temperate saltmarsh" = "saltmarsh"),
    eco = factor(
      eco, 
      levels = c("boreal forest", "temperate forest", "subtropical forest", "tropical forest",
                 "cropland", "grassland", "tundra", "saltmarsh"), 
      ordered = TRUE),
    wrm2 = recode(
      wrm,
      "below" = "below",
      "above (IR)/below" = "above/below",
      "above (OTC)/below" = "above/below",
      "above (FA)/below" = "above/below",
      "above (IR)" = "above",
      "above (snow)" = "above")) %>%
  arrange(eco, depth) %>%
  mutate(tDif_sit_name = paste0(tDif, sit_name),
         `warming (°C)` = round(tDifR, 1)) %>%
  ggplot(., aes(mean, round(depth / 100, 2), group = tDif_sit_name)) +
  # geom_errorbarh(
  #   aes(xmin = ci.05, xmax = ci.95), 
  #   alpha = .5) +
  geom_path() +
  geom_errorbarh(
    aes(xmin = mean - sd, xmax = mean + sd, color = `warming (°C)`), 
    linetype = 2, alpha = .6) +
  geom_point(
    aes(shape = wrm2, fill = eco), 
    size = 4, color = "black") +
  scale_shape_manual(
    name = "method",
    values = c("below" = 25, 
               "above/below" = 22, 
               "above" = 24)) +
  # scale_color_viridis(option = "C", begin = .35, end = .9, breaks = seq(2, 8, 2)) +
  # scale_fill_viridis_c(option = "C", begin = .35, end = .9, breaks = seq(1, 8, 2)) +
  scale_y_reverse() +
  scale_x_continuous(breaks = seq(0, 8, 2)) +
  guides(
    color = guide_colorbar(
      title.position = "top", 
      label.theme = element_text(size = 14), 
      title.theme = element_text(size = 16)),
    fill = "none",
    shape = guide_legend(
      title.position = "top", 
      label.theme = element_text(size = 14), 
      title.theme = element_text(size = 16),
      override.aes = list(size = 5, shape = c(24, 22, 25), fill = rep("black", 3)), 
      order = 3, 
      ncol = 1)) +
  labs(x = "mean (trt - ctl), °C", y = "depth (m)") +
  # facet_wrap(vars(eco), scales = "free_y") +
  facet_wrap(vars(exp_name), scales = "free_y") +
  theme_bw() +
  theme(legend.position = "bottom",
        panel.grid.minor = element_blank(),
        # Adjusting legend text size
        legend.text = element_text(size = 14),
        legend.title = element_text(size = 14),
        # Adjusting x-axis text size
        axis.text.x = element_text(size = 12),
        # Adjusting axes title size
        axis.title.x = element_text(size = 18),
        axis.title.y = element_text(size = 18),
        # Adjusting y-axis text size
        axis.text.y = element_text(size = 14),
        # Adjusting strip
        strip.text = element_text(size = 12, hjust = 0),
        strip.background = element_blank())


ggsave(
    filename = "../docs/EGU25/meanHeatPros_sd.png",
    plot = p,
    height = 13.49, 
    width = 21.48, 
    dpi = 300,
    units = "cm")

ggsave(
    filename = "../docs/Manuscripts/figs/meanHeatPros_sd.png",
    plot = p,
    height = 15, 
    width = 20, 
    dpi = 300,
    units = "cm")

```

## ST v SM

```{r sm-v-st}
moist.clean.d.ls2 <- setNames(lapply(seq_along(moist.clean.ls), function(i) {
  
  df <- moist.clean.ls[[i]][["subDaily"]]
  df$day <- as.Date(df$date)
  ix.ct <- unique(c(grep("control", names(df)), grep("treatment", names(df))))
  if (units.ls[[i]] == "ppn") {
    for (j in seq_along(ix.ct)) {
      df[[ix.ct[j]]] <- df[[ix.ct[j]]] * 100  
    }
  }
  if (length(grep("depth", names(df))) == 2) {
    df$depth <- rowMeans(df[ , c("depth_upper", "depth_lower")])
  }
  if (any(grepl("sit_name", names(df)))) {
    df$sit_name <- paste0(names(moist.clean.ls[i]), "_", df$sit_name)
  } else {
    df$sit_name <- names(moist.clean.ls[i])
  }
  
  # get index for growing season ls
  ix <- which(grepl(names(moist.clean.ls)[i], names(gs.ls)))
  GS <- gs.ls[[ix]] 
  
  df <- df %>%
    select(control, depth, starts_with("treatment"), day, sit_name) %>%
    group_by(sit_name, depth, day) %>%
    summarize(
      across(
        .cols = c(control, starts_with("treatment")),
        .fns = list(mean = ~ mean(.x, na.rm = TRUE))),
      .groups = "drop") %>%
    select(sit_name, day, depth, contains("_mean")) %>%
    pivot_longer(
      cols = contains("treatment"),
      names_to = "stat",
      values_to = "sm_mean") %>%
    mutate(tDif = as.numeric(str_extract(stat, "\\d+\\.*\\d*")),
           stat = ifelse(grepl("-", stat), "dif", "treatment"),
           doy = as.numeric(strftime(day, format = "%j")),
           growSeas = ifelse(doy > GS[["sos"]] & doy < GS[["eos"]], "growing season", "non-growing season"))
  }), nm = names(moist.clean.ls))

temp.clean.d.ls2 <- setNames(lapply(seq_along(temp.clean.ls), function(i) {

  df <- temp.clean.ls[[i]][["subDaily"]]
  df$day <- as.Date(df$date)
  if (length(grep("depth", names(df))) == 2) {
    df$depth <- rowMeans(df[ , c("depth_upper", "depth_lower")])
  }
  if (any(grepl("sit_name", names(df)))) {
    df$sit_name <- paste0(names(temp.clean.ls[i]), "_", df$sit_name)
  } else {
    df$sit_name <- names(temp.clean.ls[i])
  }
  
  df.l <- df %>%
    select(control, depth, starts_with("treatment"), day, sit_name) %>%
    group_by(sit_name, depth, day) %>%
    summarize(
      across(
        .cols = c(control, starts_with("treatment")),
        .fns = list(mean = ~ mean(.x, na.rm = TRUE))),
      .groups = "drop") %>%
    select(sit_name, day, depth, contains("_mean")) %>%
    pivot_longer(
      cols = contains("mean"),
      names_to = "stat",
      values_to = "st_mean")
  
  # get soil moisture depths
  sm.ds <- as.numeric(unique(moist.clean.d.ls2[[i]][["depth"]]))
  st.ds <- as.numeric(unique(df.l$depth))
  
  # spline temp to moisture depths, if different
  if (!all(sm.ds %in% st.ds)) {
    
    # remove soil moisture depths > soil temp depths to prevent extrapolation
    sm.ds <- sm.ds[which(sm.ds < max(st.ds))]
    
    if (length(sm.ds) != 0) {
    
      # order data frame by depth
      if (!is.numeric(df.l$depth)) {
        df.l$depth <- as.numeric(df.l$depth)
      }
      df.l <- df.l[order(df.l$depth), ]
      df.l <- bind_rows(lapply(split(df.l, df.l$sit_name), function(s) 
        bind_rows(lapply(split(s, s$day), function(d) 
          bind_rows(lapply(split(d, d$stat), function(z) {
            z <- data.frame(z)
            # only spline if # unique depths > 2
            if (nrow(z) - length(which(is.na(z$st_mean))) > 1) {
              sp <- spline(z$depth, z$st_mean, method = "natural")
              ss <- smooth.spline(sp, lambda = .1, tol = 1e-4)
              sp.smd <- predict(ss, sm.ds)
              data.frame(depth = sp.smd$x, st_mean = sp.smd$y)
            }
          }), .id = "stat")), .id = "day")), .id = "sit_name") %>%
        mutate(day = as.Date(day))
    }
  }
  
  # add tDif, recode stat values
  df.sp <- df.l %>%
    mutate(tDif = as.numeric(str_extract(stat, "\\d+\\.*\\d*")),
           stat = ifelse(grepl("-", stat), "dif", ifelse(grepl("control", stat), "control", "treatment")))
  
  # separate control values into their own column
  ctl <- df.sp %>% filter(stat == "control") %>% select(sit_name, day, depth, control_mean = st_mean)
  df.sp %>% filter(stat != "control") %>% left_join(ctl, by = c("sit_name", "day", "depth"))
}), nm = names(temp.clean.ls))

# merge st & sm
st.sm.df <- left_join(
  bind_rows(moist.clean.d.ls2, .id = "exp_name"),
  bind_rows(temp.clean.d.ls2, .id = "exp_name"), 
  by = c("exp_name", "sit_name", "day", "depth", "stat", "tDif"), 
  suffix = c(".sm", ".st"))

st.sm.df$eco <- eco.df[match(st.sm.df$sit_name, eco.df$sit_name), "eco"]
st.sm.df$wrm <- wrm.df[match(st.sm.df$sit_name, wrm.df$sit_name), "wrm"]
st.sm.df$biome <- eco.df[match(st.sm.df$sit_name, eco.df$sit_name), "biome"]
st.sm.df <- cbind(st.sm.df, mat.map.df[match(st.sm.df$sit_name, mat.map.df$sit_name), c("MAT", "MAP")])

# st.sm.df %>% filter(stat == "dif") %>% ggplot(., aes(st_mean, sm_mean, color = depth)) + geom_hline(yintercept = 0, linetype = 2) + geom_vline(xintercept = 0, linetype = 2) + geom_point() + facet_wrap(vars(eco), scales = "free") + theme_bw() + theme(panel.grid = element_blank())

# run model
sm.st.lmx <- lmer(sm_mean ~ st_mean * control_mean.sm + st_mean * control_mean.st + st_mean * eco + depth + growSeas + (st_mean | sit_name), subset(st.sm.df, st.sm.df$stat == "dif"))

# note that model with st_mean * depth interaction performs slightly better, but the absolute effect is small
sm.st.lmx2 <- lmer(sm_mean ~ st_mean * control_mean.sm + st_mean * control_mean.st + st_mean * eco + st_mean * depth + growSeas + (st_mean | sit_name), subset(st.sm.df, st.sm.df$stat == "dif"))

# force sm_mean to be 0 when st_mean = 0
sm.st.lmx3 <- lmer(sm_mean ~ 0 + st_mean * control_mean.sm + st_mean * control_mean.st + st_mean * eco + depth + growSeas + (0 + st_mean | sit_name), subset(st.sm.df, st.sm.df$stat == "dif"))

# remove interaction between eco & st_mean
sm.st.lmx6 <- lmer(sm_mean ~ st_mean * control_mean.sm + st_mean * control_mean.st + eco + depth + growSeas + (st_mean | sit_name), subset(st.sm.df, st.sm.df$stat == "dif"))

# drop tundra samples
sm.st.lmx7 <- st.sm.df %>%
  filter(stat == "dif") %>%
  filter(eco != "tundra") %>%
  mutate(across(c(st_mean, control_mean.sm, control_mean.st), ~ scale(.x, center = TRUE, scale = FALSE))) %>%
  lmer(sm_mean ~ st_mean * control_mean.sm + st_mean * control_mean.st + st_mean * eco + depth + growSeas + (st_mean | sit_name), ., control = lmerControl(optimizer = "bobyqa"))

sm.st.lmx.tn <- st.sm.df %>%
  filter(stat == "dif") %>%
  filter(eco == "tundra") %>%
  lmer(sm_mean ~ st_mean * control_mean.sm + st_mean * control_mean.st + depth + growSeas + (st_mean | sit_name), .)

# check eco * depth interaction
sm.st.lmx8 <- st.sm.df %>%
  filter(stat == "dif") %>%
  mutate(across(c(st_mean, control_mean.sm, control_mean.st), ~ scale(.x, center = TRUE, scale = FALSE))) %>%
  lmer(sm_mean ~ st_mean * control_mean.sm + st_mean * control_mean.st + depth * eco + growSeas + (st_mean | sit_name), ., control = lmerControl(optimizer = "bobyqa"))

sm.st.lmx9 <- st.sm.df %>%
  filter(stat == "dif") %>%
  mutate(across(c(st_mean, control_mean.sm, control_mean.st), ~ scale(.x, center = TRUE, scale = FALSE))) %>%
  lmer(sm_mean ~ st_mean * control_mean.sm + st_mean * control_mean.st + st_mean * eco + eco * depth + growSeas + (st_mean | sit_name), ., control = lmerControl(optimizer = "bobyqa"))

# assess growSeas effect for all-year only heating
heatDur <- data.frame(rbind(
      cbind(heatDur = 1, exp_name = yr),
      cbind(heatDur = 0, exp_name = pt)))
sm.st.lmx10 <- st.sm.df %>%
  left_join(heatDur, by = "exp_name") %>%
  filter(stat == "dif") %>%
  filter(heatDur == 1) %>%
  lmer(sm_mean ~ growSeas + (1 | sit_name), .)

# soil T
## note that eco does not improve AIC; sm_mean also insig.
st.mod.df <- st.sm.df %>%
  filter(stat == "dif") %>%
  mutate(wrm_ab = ifelse(!grepl("above", wrm), "below ground", ifelse(!grepl("below", wrm), "above ground", "above + below ground")),
         st_cent = st_mean - tDif,
         tDif_cent = scale(tDif, scale = FALSE),
         control_mean.sm = scale(control_mean.sm, scale = FALSE),
         control_mean.st = scale(control_mean.st, scale = FALSE)) 

st.sm.lmx <- lmer(st_mean ~ tDif + control_mean.sm + control_mean.st + depth + (1 | sit_name), st.mod.df)

st.sm.lmx2 <- lmer(st_mean ~ tDif * depth + control_mean.sm + control_mean.st + (1 | sit_name), st.mod.df)

st.sm.lmx3 <- lmer(st_mean ~ tDif * depth + tDif * control_mean.sm + tDif * control_mean.st + (1 | sit_name), st.mod.df)

st.sm.lmx4 <- lmer(st_mean ~ wrm_ab * tDif * depth + tDif * control_mean.sm + tDif * control_mean.st + (1 | sit_name), st.mod.df)

st.sm.lmx5 <- lmer(st_cent ~ tDif * wrm_ab * depth + control_mean.sm + control_mean.st + (1 | sit_name), st.mod.df)

st.sm.lmx6 <- lmer(st_cent ~ tDif_cent * wrm_ab * depth + control_mean.sm + control_mean.st + (1 | sit_name), st.mod.df)

st.sm.lmx7 <- lmer(st_cent ~ tDif_cent * wrm_ab + wrm_ab * depth + control_mean.sm + control_mean.st + (1 | sit_name), st.mod.df)

# check_model(sm.st.lmx) # req. "performance" package; gives diagnostic plots

# check comparisons
emmeans(sm.st.lmx, list(pairwise ~ eco), adjust = "tukey")

# extract conditional means by ecosystem; at mean tDif and for the growing season
emmeans(sm.st.lmx, ~ eco, at = list(st_mean = 4, growSeas = "growing season"))

# plot interaction slopes by ecosystem
## first plot only tundra & bor forest, @10% and 80% VWC
emmip.sm10.tbf.dat <- emmip(
  sm.st.lmx, 
  eco ~ st_mean, 
  at = list(
    st_mean = seq(1, 5, .5), 
    growSeas = "growing season", 
    control_mean.sm = 10,
    eco = c("boreal forest", "tundra")),
  CIs = TRUE)
emmip.sm80.tbf.dat <- emmip(
  sm.st.lmx, 
  eco ~ st_mean, 
  at = list(
    st_mean = seq(1, 5, .5), 
    growSeas = "growing season", 
    control_mean.sm = 80,
    eco = c("boreal forest", "tundra")),
  CIs = TRUE)

ggplot(emmip.sm10.tbf.dat$data, aes(xvar, yvar)) +
  geom_hline(yintercept = 0, linetype = 2) +
  geom_ribbon(aes(ymin = LCL, ymax = UCL, fill = eco), alpha = .2) +
  geom_line(aes(color = eco), linewidth = 2, linetype = 1) +
  scale_color_manual(
    name = "",
    values = c("tundra" = "#535fbf",
               "boreal forest" = "#398030")) +
  scale_fill_manual(
    name = "",
    values = c("tundra" = "#535fbf",
               "boreal forest" = "#398030")) +
  labs(y = "Predicted ∆VWC (%)", x = "∆ soil T (°C)") +
  theme_bw() + 
  theme(panel.grid = element_blank())

ggplot(emmip.sm80.tbf.dat$data, aes(xvar, yvar)) +
  geom_hline(yintercept = 0, linetype = 2) +
  geom_ribbon(aes(ymin = LCL, ymax = UCL, fill = eco), alpha = .2) +
  geom_line(aes(color = eco), linewidth = 2, linetype = 1) +
  scale_color_manual(
    name = "",
    values = c("tundra" = "#535fbf",
               "boreal forest" = "#398030")) +
  scale_fill_manual(
    name = "",
    values = c("tundra" = "#535fbf",
               "boreal forest" = "#398030")) +
  labs(y = "Predicted ∆VWC (%)", x = "∆ soil T (°C)") +
  theme_bw() + 
  theme(panel.grid = element_blank())

## then plot everything at same soil moisture levels
emmip.sm10.dat <- emmip(
  sm.st.lmx, 
  eco ~ st_mean, 
  at = list(
    st_mean = seq(1, 5, .5), 
    growSeas = "growing season",
    control_mean.sm = 10),
  CIs = TRUE)
emmip.sm80.dat <- emmip(
  sm.st.lmx, 
  eco ~ st_mean, 
  at = list(
    st_mean = seq(1, 5, .5), 
    growSeas = "growing season",
    control_mean.sm = 80),
  CIs = TRUE)

emmip.sm10.dat +
  geom_hline(yintercept = 0, linetype = 2) +
  geom_line(linewidth = 1, linetype = 1) +
  scale_color_manual(
    name = "",
    values = c("cropland" = "#bf535f",
               "grassland" = "#b7bce4",
               "tundra" = "#535fbf",
               "tropical forest" = "#bce4b7",
               "temperate forest" = "#5fbf53",
               "boreal forest" = "#398030")) +
  labs(y = "Predicted ∆VWC (%)", x = "∆ soil T (°C)") +
  theme_bw() + 
  theme(panel.grid = element_blank())

ggplot(emmip.sm10.dat$data, aes(xvar, yvar)) +
  geom_hline(yintercept = 0, linetype = 2) +
  geom_ribbon(aes(ymin = LCL, ymax = UCL, color = eco, fill = eco), alpha = .1, linetype = "dotted") +
  geom_line(aes(color = eco), linewidth = 2, linetype = 1) +
  scale_color_manual(
    name = "",
    values = c("cropland" = "#bf535f",
               "grassland" = "#b7bce4",
               "tundra" = "#535fbf",
               "tropical forest" = "#bce4b7",
               "temperate forest" = "#5fbf53",
               "boreal forest" = "#398030")) +
  scale_fill_manual(
    name = "",
    values = c("cropland" = "#bf535f",
               "grassland" = "#b7bce4",
               "tundra" = "#535fbf",
               "tropical forest" = "#bce4b7",
               "temperate forest" = "#5fbf53",
               "boreal forest" = "#398030")) +
  labs(y = "Predicted ∆VWC (%)", x = "∆ soil T (°C)") +
  theme_bw() + 
  theme(panel.grid = element_blank())

ggplot(emmip.sm80.dat$data, aes(xvar, yvar)) +
  geom_hline(yintercept = 0, linetype = 2) +
  geom_ribbon(aes(ymin = LCL, ymax = UCL, color = eco, fill = eco), alpha = .1, linetype = "dotted") +
  geom_line(aes(color = eco), linewidth = 2, linetype = 1) +
  scale_color_manual(
    name = "",
    values = c("cropland" = "#bf535f",
               "grassland" = "#b7bce4",
               "tundra" = "#535fbf",
               "tropical forest" = "#bce4b7",
               "temperate forest" = "#5fbf53",
               "boreal forest" = "#398030")) +
  scale_fill_manual(
    name = "",
    values = c("cropland" = "#bf535f",
               "grassland" = "#b7bce4",
               "tundra" = "#535fbf",
               "tropical forest" = "#bce4b7",
               "temperate forest" = "#5fbf53",
               "boreal forest" = "#398030")) +
  labs(y = "Predicted ∆VWC (%)", x = "∆ soil T (°C)") +
  theme_bw() + 
  theme(panel.grid = element_blank())

# compare slopes w/ interaction
emtrends(sm.st.lmx, specs = "eco", var = "st_mean", at = list(growSeas = "growing season", control_mean.sm = 10))

# estimate variance contributions
r2_nakagawa(sm.st.lmx) # marg = fixed, cond = fixed + rand

# print depths
lapply(seq_along(moist.clean.ls), function(i) {
  cat(names(moist.clean.ls)[i], "\nsm: ", unique(moist.clean.ls[[i]]$dailySit$depth), "\n",
      "st: ", unique(temp.clean.ls[[i]]$dailySit$depth), "\n")
})

# plot emmeans across various levels of explanatory variables
emm.df <- rbind(
  cbind(as.data.frame(
    emmeans(sm.st.lmx, ~ eco, at = list(
      st_mean = 1,
      control_mean.st = 5,
      growSeas = "growing season"))), 
    dst = "1", cst = "5"),
  cbind(
    as.data.frame(emmeans(sm.st.lmx, ~ eco, at = list(
      st_mean = 5, 
      control_mean.st = 5,
      growSeas = "growing season"))),
    dst = "5", cst = "5"),
  cbind(as.data.frame(
    emmeans(sm.st.lmx, ~ eco, at = list(
      st_mean = 1,
      control_mean.st = 20,
      growSeas = "growing season"))), 
    dst = "1", cst = "20"),
  cbind(
    as.data.frame(emmeans(sm.st.lmx, ~ eco, at = list(
      st_mean = 5, 
      control_mean.st = 20,
      growSeas = "growing season"))),
    dst = "5", cst = "20"))

ggplot(emm.df, aes(emmean, eco)) +
  geom_vline(xintercept = 0, linetype = 2) +
  geom_point() +
  geom_errorbarh(
    aes(xmin = asymp.LCL, xmax = asymp.UCL)) +
  facet_grid(cols = vars(dst), rows = vars(cst)) +
  theme_bw() +
  theme(panel.grid = element_blank())

# table
library(broom.mixed)
library(gt)
library(dplyr)

# Extract tidy fixed effects with confidence intervals
tidy_table <- tidy(sm.st.lmx4, effects = "fixed", conf.int = TRUE)

term_labels <- c(
  "(Intercept)" = "intercept",
  "st_mean" = "deg. warming",
  "control_mean.sm" = "ambient soil moist.",
  "control_mean.st" = "ambient soil temp.",
  "depth" = "depth",
  "growSeasgrowing season" = "growing season",
  "st_mean:control_mean.sm" = "deg. warming × ambient soil moist.",
  "st_mean:control_mean.st" = "deg. warming × ambient soil temp.",
  "st_mean:ecoTemperate Forest" = "deg. warming × temperate forest",
  "st_mean:ecoBoreal Forest" = "deg. warming × boreal forest",
  "ecoTemperate Forest" = "temp. for",
  "ecoBoreal Forest" = "bore. for"
)

# Step 3: Process the table
tidy_table %>%
  select(-effect) %>%  # Drop the 'effect' column
  mutate(term = recode(term, !!!term_labels)) %>%  # Rename terms
  mutate(across(where(is.numeric), ~ round(., 3))) %>%
  rename(
    Term = term,
    Estimate = estimate,
    `Std. Error` = std.error,
    `Lower CI` = conf.low,
    `Upper CI` = conf.high
  ) %>%
  gt() %>%
  tab_header(
    title = "Fixed Effects from Linear Mixed Model"
  ) %>%
  fmt_number(columns = 2:5, decimals = 3) %>%
  opt_row_striping()


# center variables to address collinearity with interaction terms
sm.st.lmx4 <- subset(st.sm.df, st.sm.df$stat == "dif") %>%
  mutate(across(c(st_mean, control_mean.sm, control_mean.st), ~ scale(.x, center = TRUE, scale = FALSE))) %>%
  lmer(sm_mean ~ st_mean * control_mean.sm + st_mean * control_mean.st + st_mean * eco + depth + growSeas + (st_mean | sit_name), ., control = lmerControl(optimizer = "bobyqa"))

# Extract residuals and fitted values
resid_vals <- resid(sm.st.lmx7)
fitted_vals <- fitted(sm.st.lmx7)

# Plot
plot(fitted_vals, resid_vals,
     xlab = "Fitted values", ylab = "Residuals",
     main = "Residuals vs Fitted")
abline(h = 0, col = "red")

# look at a predictor, e.g., depth, to check heteroscedacity
cbind(
  sm.st.lmx4@frame, res = resid_vals) %>%
  ggplot(., aes(x = depth, y = resid_vals)) +
  geom_point(alpha = 0.5) + 
  geom_smooth(method = "loess", se = FALSE) +
  labs(title = "Residuals vs Predictor") +
  theme_bw() +
  theme(panel.grid = element_blank())

library(DHARMa)

sim_res <- simulateResiduals(fittedModel = sm.st.lmx7)
plot(sim_res)

ggplot(sm.st.lmx4@frame, aes(x = st_mean)) + 
  geom_histogram(bins = 30) +
  labs(title = "Distribution of Predictor") +
  theme_bw() +
  theme(panel.grid = element_blank())
skewness(sm.st.lmx7@frame$sm_mean)


# try Bayesian glmer
library(rstanarm)

# speed up by running in parallel
options(mc.cores = parallel::detectCores())

# Fit Bayesian mixed model
df <- subset(st.sm.df, st.sm.df$stat == "dif") %>%
  mutate(across(c(st_mean, control_mean.sm, control_mean.st), ~ scale(.x, center = TRUE, scale = FALSE))) %>%
  filter(if_all(c(control_mean.sm, sm_mean, control_mean.st, st_mean), ~ !is.na(.)))
sm.st.lmx.b <- stan_glmer(
    sm_mean ~ st_mean * control_mean.sm + 
              st_mean * control_mean.st + 
              st_mean * eco + 
              depth + growSeas + 
              (st_mean | sit_name),
    data = df,
    family = gaussian(),           # continuous response
    prior = normal(0, 2.5),        # weakly informative prior for fixed effects
    prior_intercept = normal(0, 5),# slightly wider prior for the intercept
    prior_covariance = decov(regularization = 2),  # for random effects
    chains = 1, iter = 500, seed = 1234, refresh = 10
  )

# Summary of posterior distributions
summary(sm.st.lmx.b)

# Plot posterior intervals
plot(sm.st.lmx.b)

# Posterior predictive checks
pp_check(sm.st.lmx.b)
pp_check(sm.st.lmx.b, plotfun = "hist")
pp_check(sm.st.lmx.b, plotfun = "stat_grouped", stat = "median", group = "eco")

# Extract posterior draws
posterior <- as.data.frame(sm.st.lmx.b)

library(bayesplot)

# Extract posterior samples for all group-specific effects
posterior <- as.matrix(sm.st.lmx.b)

# Get all group-level intercepts and slopes
intercepts <- posterior[, grep("^b\\[\\(Intercept\\) sit_name:", colnames(posterior))]
slopes <- posterior[, grep("^b\\[st_mean sit_name:", colnames(posterior))]

# Create tidy summaries
intercept_df <- as.data.frame(intercepts) %>%
  pivot_longer(everything(), names_to = "parameter", values_to = "value") %>%
  group_by(parameter) %>%
  summarise(
    mean = mean(value),
    lower = quantile(value, 0.1),
    upper = quantile(value, 0.9)) %>%
  mutate(site = str_extract(parameter, "(?<=sit_name:)[^\\]]+")) %>%
  left_join(st.sm.df[, c("sit_name", "eco")], by = c("site" = "sit_name"))

slope_df <- as.data.frame(slopes) %>%
  pivot_longer(everything(), names_to = "parameter", values_to = "value") %>%
  group_by(parameter) %>%
  summarise(
    mean = mean(value),
    lower = quantile(value, 0.1),
    upper = quantile(value, 0.9)) %>%
  mutate(site = str_extract(parameter, "(?<=sit_name:)[^\\]]+")) %>%
  left_join(st.sm.df[, c("sit_name", "eco")], by = c("site" = "sit_name"))

# plot 
ggplot(intercept_df, aes(x = reorder(site, mean), y = mean, color = eco)) +
  geom_point() +
  geom_errorbar(aes(ymin = lower, ymax = upper), width = 0.2) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "gray50") +
  scale_color_manual(
    name = "",
    values = c("cropland" = "#bf535f",
               "grassland" = "#b7bce4",
               "tundra" = "#535fbf",
               "tropical forest" = "#bce4b7",
               "temperate forest" = "#5fbf53",
               "boreal forest" = "#398030")) +
  coord_flip() +
  labs(
    x = "",
    y = "mean trt-ctl VWC (%)") +
  theme_bw() +
  theme(panel.grid = element_blank())

ggplot(slope_df, aes(x = reorder(site, mean), y = mean, color = eco)) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "gray50") +
  geom_point() +
  geom_errorbar(aes(ymin = lower, ymax = upper), width = 0.2) +
  scale_color_manual(
    name = "",
    values = c("cropland" = "#bf535f",
               "grassland" = "#b7bce4",
               "tundra" = "#535fbf",
               "tropical forest" = "#bce4b7",
               "temperate forest" = "#5fbf53",
               "boreal forest" = "#398030")) +
  coord_flip() +
  labs(
    x = "",
    y = "change in trt-ctl VWC (%) per °C warming") +
  theme_bw() +
  theme(panel.grid = element_blank())

# extract conditional means by ecosystem; at mean tDif and for the growing season
emmeans(sm.st.lmx.b, ~ eco, at = list(growSeas = "growing season"))

# plot interaction slopes by ecosystem
emmip.sm10.dat <- emmip(
  sm.st.lmx.b, 
  eco ~ st_mean, 
  at = list(
    st_mean = seq(1, 5, .5), 
    growSeas = "growing season",
    control_mean.sm = 10),
  CIs = TRUE)
emmip.sm80.dat <- emmip(
  sm.st.lmx.b, 
  eco ~ st_mean, 
  at = list(
    st_mean = seq(1, 5, .5), 
    growSeas = "growing season",
    control_mean.sm = 80),
  CIs = TRUE)

ggplot(emmip.sm10.dat$data, aes(xvar, yvar)) +
  geom_hline(yintercept = 0, linetype = 2) +
  geom_ribbon(aes(ymin = LCL, ymax = UCL, color = eco, fill = eco), alpha = .1, linetype = "dotted") +
  geom_line(aes(color = eco), linewidth = 2, linetype = 1) +
  scale_color_manual(
    name = "",
    values = c("cropland" = "#bf535f",
               "grassland" = "#b7bce4",
               "tundra" = "#535fbf",
               "tropical forest" = "#bce4b7",
               "temperate forest" = "#5fbf53",
               "boreal forest" = "#398030")) +
  scale_fill_manual(
    name = "",
    values = c("cropland" = "#bf535f",
               "grassland" = "#b7bce4",
               "tundra" = "#535fbf",
               "tropical forest" = "#bce4b7",
               "temperate forest" = "#5fbf53",
               "boreal forest" = "#398030")) +
  labs(y = "Predicted ∆VWC (%)", x = "∆ soil T (°C)") +
  theme_bw() + 
  theme(panel.grid = element_blank())

ggplot(emmip.sm80.dat$data, aes(xvar, yvar)) +
  geom_hline(yintercept = 0, linetype = 2) +
  geom_ribbon(aes(ymin = LCL, ymax = UCL, color = eco, fill = eco), alpha = .1, linetype = "dotted") +
  geom_line(aes(color = eco), linewidth = 2, linetype = 1) +
  scale_color_manual(
    name = "",
    values = c("cropland" = "#bf535f",
               "grassland" = "#b7bce4",
               "tundra" = "#535fbf",
               "tropical forest" = "#bce4b7",
               "temperate forest" = "#5fbf53",
               "boreal forest" = "#398030")) +
  scale_fill_manual(
    name = "",
    values = c("cropland" = "#bf535f",
               "grassland" = "#b7bce4",
               "tundra" = "#535fbf",
               "tropical forest" = "#bce4b7",
               "temperate forest" = "#5fbf53",
               "boreal forest" = "#398030")) +
  labs(y = "Predicted ∆VWC (%)", x = "∆ soil T (°C)") +
  theme_bw() + 
  theme(panel.grid = element_blank())

# compare slopes w/ interaction
emtrends(sm.st.lmx.b, specs = "eco", var = "st_mean", at = list(growSeas = "growing season", control_mean.sm = 10))

# plot mean ∆M for dry and wet soil scenarios
em_res.10 <- emmeans(sm.st.lmx.brm2, ~ eco, at = list(growSeas = "growing season", control_mean.sm = 10)) 
em_draws <- as.data.frame(em_res.10)

em_draws %>%
  ggplot(., aes(x = eco, y = emmean, color = eco)) +
  geom_hline(yintercept = 0, linetype = 2) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = lower.HPD, ymax = upper.HPD), width = 0.2) +
  scale_color_manual(
    name = "",
    values = c("cropland" = "#bf535f",
               "grassland" = "#b7bce4",
               "tundra" = "#535fbf",
               "tropical forest" = "#bce4b7",
               "temperate forest" = "#5fbf53",
               "boreal forest" = "#398030")) +
  labs(y = "Predicted ∆VWC (%)", x = "") +
  theme_bw() + 
  theme(panel.grid = element_blank())

em_res.80 <- emmeans(sm.st.lmx.brm2, ~ eco, at = list(growSeas = "growing season", control_mean.sm = 80)) 
em_draws <- as.data.frame(em_res.80)

em_draws %>%
  ggplot(., aes(x = eco, y = emmean, color = eco)) +
  geom_hline(yintercept = 0, linetype = 2) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = lower.HPD, ymax = upper.HPD), width = 0.2) +
  scale_color_manual(
    name = "",
    values = c("cropland" = "#bf535f",
               "grassland" = "#b7bce4",
               "tundra" = "#535fbf",
               "tropical forest" = "#bce4b7",
               "temperate forest" = "#5fbf53",
               "boreal forest" = "#398030")) +
  labs(y = "Predicted ∆VWC (%)", x = "") +
  theme_bw() + 
  theme(panel.grid = element_blank())


## Try brms
library(brms)

# initial mod
sm.st.lmx.brm <- brm(
  bf(
    sm_mean ~ st_mean * control_mean.sm + 
              st_mean * control_mean.st + 
              st_mean * eco + 
              depth + growSeas + 
              (st_mean | sit_name),
    sigma ~ 1 + (1 | sit_name)  # <- varying residual SDs across sites
  ),
  data = df,
  family = gaussian(),
  chains = 4,
  iter = 500,
  cores = 4,
  seed = 1234,
  control = list(adapt_delta = 0.95)
)

# more iterations
sm.st.lmx.brm2 <- brm(
  bf(
    sm_mean ~ st_mean * control_mean.sm + 
              st_mean * control_mean.st + 
              st_mean * eco + 
              depth + growSeas + 
              (st_mean | sit_name),
    sigma ~ 1 + (1 | sit_name)  # varying residual SDs across sites
  ),
  data = df,
  family = gaussian(),
  chains = 4,
  iter = 2000,
  cores = 4,
  seed = 1234,
  control = list(adapt_delta = 0.95)
)

# drop tundra sites, test mod (address divergence possibly due to bimodal response)
sm.st.lmx.brm3 <- df %>%
  filter(eco != "tundra") %>% 
  brm(
    bf(
      sm_mean ~ st_mean * control_mean.sm + 
                st_mean * control_mean.st + 
                st_mean * eco + 
                depth + growSeas + 
                (st_mean | sit_name),
      sigma ~ 1 + (1 | sit_name)  # <- varying residual SDs across sites
    ),
    data = .,
    family = gaussian(),
    chains = 4,
    iter = 500,
    cores = 4,
    seed = 1234,
    control = list(adapt_delta = 0.95)
)

# set priors and try no tundra model again
priors <- c(
  prior(normal(-5, 10), class = "Intercept"),           # centered on mean
  prior(normal(-1, 1), class = "b", coef = "st_mean"),  # NEGATIVE expectation
  prior(normal(0, 2.5), class = "b"),                   # Default for other betas
  # Priors for the sigma model
  prior(normal(0, 1), class = "Intercept", dpar = "sigma"),  # Intercept for sigma, log scale
  prior(exponential(1), class = "sd", dpar = "sigma")        # Random effect SD for sigma
)

sm.st.lmx.brm4 <- df %>%
  filter(eco != "tundra") %>% 
  brm(
    bf(
      sm_mean ~ st_mean * control_mean.sm + 
                st_mean * control_mean.st + 
                st_mean * eco + 
                depth + growSeas + 
                (st_mean | sit_name),
      sigma ~ 1 + (1 | sit_name)  # <- varying residual SDs across sites
    ),
    data = .,
    family = gaussian(),
    prior = priors,
    chains = 4,
    iter = 2000,
    cores = 4,
    seed = 1234,
    control = list(adapt_delta = 0.96)
)

ranef_df <- as.data.frame(ranef(sm.st.lmx.brm2)$sit_name)
ranef_df$site <- rownames(ranef(sm.st.lmx.brm2)$sit_name)

# Example: Plotting the random intercepts
left_join(ranef_df, eco.df, by = c("site" = "sit_name")) %>%
  ggplot(., aes(x = reorder(site, Estimate.Intercept), y = Estimate.Intercept, color = eco)) +
  geom_point() +
  geom_errorbar(aes(ymin = Q2.5.Intercept, ymax = Q97.5.Intercept), width = 0.2) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "gray50") +
  scale_color_manual(
    name = "",
    values = c("cropland" = "#bf535f",
               "grassland" = "#b7bce4",
               "tundra" = "#535fbf",
               "tropical forest" = "#bce4b7",
               "temperate forest" = "#5fbf53",
               "boreal forest" = "#398030")) +
  coord_flip() +
  labs(
    x = "",
    y = "mean trt-ctl VWC (%)") +
  theme_bw() +
  theme(panel.grid = element_blank())

pp_check(sm.st.lmx.brm)

fitted_vals <- fitted(sm.st.lmx.brm2, summary = TRUE)[, "Estimate"]
observed_vals <- sm.st.lmx.brm2$data$sm_mean
eco_var <- sm.st.lmx.brm2$data$eco
plot_data <- data.frame(
  observed = observed_vals,
  predicted = fitted_vals,
  eco = eco_var
)
lims <- range(c(plot_data$predicted, plot_data$observed), na.rm = TRUE)
gg <- ggplot(plot_data, aes(x = predicted, y = observed, color = eco)) +
  geom_vline(xintercept = 0, color = "gray80") +
  geom_hline(yintercept = 0, color = "gray80") +
  geom_point(alpha = 0.6) +
  geom_abline(intercept = 0, slope = 1, linetype = "dashed", color = "gray") +
  scale_color_manual(
    name = "",
    values = c("cropland" = "#bf535f",
               "grassland" = "#b7bce4",
               "tundra" = "#535fbf",
               "tropical forest" = "#bce4b7",
               "temperate forest" = "#5fbf53",
               "boreal forest" = "#398030")) +
  labs(x = "Predicted sm_mean",
       y = "Observed sm_mean",
       color = "") +
  # xlim(lims) +
  # ylim(lims) +
  theme_bw() + 
  theme(panel.grid = element_blank(),
        legend.position = "bottom")
ggMarginal(gg, type = "density", groupColour = TRUE, groupFill = TRUE)

emmip.sm.brm.dat <- emmip(
  sm.st.lmx.brm2, 
  eco ~ control_mean.sm, 
  at = list(
    control_mean.sm = seq(10, 80, 10), 
    growSeas = "growing season"),
  CIs = TRUE)

ggplot(emmip.sm.brm.dat$data, aes(xvar, yvar)) +
  geom_hline(yintercept = 0, linetype = 2) +
  geom_ribbon(aes(ymin = LCL, ymax = UCL, color = eco, fill = eco), alpha = .1, linetype = "dotted", show.legend = FALSE) +
  geom_line(aes(color = eco), linewidth = 1, linetype = 1) +
  scale_color_manual(
    name = "",
    values = c("cropland" = "#bf535f",
               "grassland" = "#b7bce4",
               "tundra" = "#535fbf",
               "tropical forest" = "#bce4b7",
               "temperate forest" = "#5fbf53",
               "boreal forest" = "#398030")) +
  scale_fill_manual(
    name = "",
    values = c("cropland" = "#bf535f",
               "grassland" = "#b7bce4",
               "tundra" = "#535fbf",
               "tropical forest" = "#bce4b7",
               "temperate forest" = "#5fbf53",
               "boreal forest" = "#398030")) +
  labs(y = "Predicted ∆VWC (%)", x = "ambient VWC (%)") +
  theme_bw() + 
  theme(panel.grid = element_blank())


# plot ST
emtrends(st.sm.lmx6, ~ wrm_ab, var = "depth")
emmeans(st.sm.lmx6, ~ depth | wrm_ab, at = list(depth = c(5, 20, 50)))

emmip.st.wrmD.dat <- emmip(
  st.sm.lmx6, 
  wrm_ab ~ depth, 
  at = list(depth = seq(0, 75, 25)),
  CIs = TRUE,
  cov.reduce = FALSE)

emmip.st.wrmD.dat$data %>%
  ggplot(., aes(yvar, xvar, group = wrm_ab)) +
  geom_vline(xintercept = 0, linetype = "dotted") +
  geom_ribbon(aes(xmin = LCL, xmax = UCL, fill = wrm_ab), alpha = .1, show.legend = FALSE) +
  geom_line(aes(color = wrm_ab)) +
  scale_color_manual(
    name = "Warming",
    values = c("above ground" = "#D81B60", "below ground" = "#1E88E5", "above + below ground" = "#004D40")) +
  scale_fill_manual(
    values = c("above ground" = "#D81B60", "below ground" = "#1E88E5", "above + below ground" = "#004D40")) +
  scale_y_reverse() +
  labs(y = "Depth (cm)", x = "∆ soil T (°C)", color = "Warming") +
  theme_bw() + 
  theme(panel.grid = element_blank())
```

### log response ratio

```{r sm-v-st-ln}
moist.clean.lnRR.ls <- setNames(lapply(seq_along(moist.clean.ls), function(i) {
  
  df <- moist.clean.ls[[i]][["subDaily"]]
  df$day <- as.Date(df$date)
  ix.ct <- unique(c(grep("control", names(df)), grep("treatment", names(df))))
  if (units.ls[[i]] == "ppn") {
    for (j in seq_along(ix.ct)) {
      df[[ix.ct[j]]] <- df[[ix.ct[j]]] * 100  
    }
  }
  if (length(grep("depth", names(df))) == 2) {
    df$depth <- rowMeans(df[ , c("depth_upper", "depth_lower")])
  }
  if (any(grepl("sit_name", names(df)))) {
    df$sit_name <- paste0(names(moist.clean.ls[i]), "_", df$sit_name)
  } else {
    df$sit_name <- names(moist.clean.ls[i])
  }
  
  # get index for growing season ls
  ix <- which(grepl(names(moist.clean.ls)[i], names(gs.ls)))
  GS <- gs.ls[[ix]]
  
  # log RR fx
  lnRR.fx <- function(df) {

    # get trt cols
    trt_cols <- grep("treatment", names(df))
    trt_cols <- names(df)[trt_cols[-which(trt_cols == grep("-", names(df)))]]
    
    # calc log RR for each treatment col
    for (i in trt_cols) {
      lnRR <- paste0("lnRR_", i)
      df <- filter(df, !is.na(df[[i]]) & !is.na(df$control))
      min <- min(df[[i]], df$control)
      df[[i]] <- df[[i]] + 1 + abs(min)
      df$control <- df$control + 1 + abs(min)
      df[[lnRR]] <- log(df[[i]] / df$control)
    }
    
    return(df)
  }
  
  # calc lnRR and add growing season
  df %>%
    lnRR.fx(.) %>%
    group_by(sit_name, depth, day) %>%
    summarize(
      across(
        .cols = c(starts_with("lnRR"), starts_with("control")),
        .fns = list(mean = ~ mean(.x, na.rm = TRUE))),
      .groups = "drop") %>%
    pivot_longer(
      cols = starts_with("lnRR"),
      names_to = "stat",
      values_to = "mean") %>%
    select(sit_name, depth, day, starts_with("control"), stat, mean) %>%
    mutate(
      tDif = as.numeric(str_extract(stat, "\\d+\\.*\\d*")),
      stat = ifelse(grepl("lnRR", stat), "lnRR", stat),
      doy = as.numeric(strftime(day, format = "%j")),
      growSeas = ifelse(doy > GS[["sos"]] & doy < GS[["eos"]], "growing season", "non-growing season"))
  }), nm = names(moist.clean.ls))

temp.clean.lnRR.ls <- setNames(lapply(seq_along(temp.clean.ls), function(i) {

  df <- temp.clean.ls[[i]][["subDaily"]]
  df$day <- as.Date(df$date)
  if (length(grep("depth", names(df))) == 2) {
    df$depth <- rowMeans(df[ , c("depth_upper", "depth_lower")])
  }
  if (any(grepl("sit_name", names(df)))) {
    df$sit_name <- paste0(names(moist.clean.ls[i]), "_", df$sit_name)
  } else {
    df$sit_name <- names(moist.clean.ls[i])
  }
  
  lnRR.fx <- function(df) {

    # get trt cols
    trt_cols <- grep("treatment", names(df))
    trt_cols <- names(df)[trt_cols[-which(trt_cols == grep("-", names(df)))]]
    
    # calc log RR for each treatment col
    for (i in trt_cols) {
      lnRR <- paste0("lnRR_", i)
      df <- filter(df, !is.na(df[[i]]) & !is.na(df$control))
      min <- min(df[[i]], df$control)
      df[[i]] <- df[[i]] + 1 + abs(min)
      df$control <- df$control + 1 + abs(min)
      df[[lnRR]] <- log(df[[i]] / df$control)
    }
    
    return(df)
  }
  
  # calc lnRR
  df2 <- df %>%
    lnRR.fx(.) %>%
    group_by(sit_name, depth, day) %>%
    summarize(
      across(
        .cols = c(starts_with("lnRR"), starts_with("control")),
        .fns = list(mean = ~ mean(.x, na.rm = TRUE))),
      .groups = "drop") %>%
    pivot_longer(
        cols = c(contains("control"), contains("lnRR")),
        names_to = c("stat", ".value"),
        names_pattern = "^(.*)_(.*)$")
  
  # get soil moisture depths
  sm.ds <- as.numeric(unique(moist.clean.d.ls2[[i]][["depth"]]))
  st.ds <- as.numeric(unique(df2$depth))
  
  # spline temp to moisture depths, if different
  if (!all(sm.ds %in% st.ds)) {
    
    # remove soil moisture depths > soil temp depths to prevent extrapolation
    sm.ds <- sm.ds[which(sm.ds < max(st.ds))]
    
    if (length(sm.ds) != 0) {
    
      # order data frame by depth
      if (!is.numeric(df2$depth)) {
        df2$depth <- as.numeric(df2$depth)
      }
      df2 <- df2[order(df2$depth), ]
      df2 <- bind_rows(lapply(split(df2, df2$sit_name), function(s) 
        bind_rows(lapply(split(s, s$day), function(d) 
          bind_rows(lapply(split(d, d$stat), function(z) {
            z <- data.frame(z)
            # only spline if # unique depths > 2
            if (nrow(z) - length(which(is.na(z$mean))) > 1) {
              sp <- spline(z$depth, z$mean, method = "natural")
              ss <- smooth.spline(sp, lambda = .1, tol = 1e-4)
              sp.smd <- predict(ss, sm.ds)
              data.frame(depth = sp.smd$x, mean = sp.smd$y)
            }
          }), .id = "stat")), .id = "day")), .id = "sit_name") %>%
        mutate(day = as.Date(day))
    }
  }
  
  # add tDif, recode stat values
  df.sp <- df2 %>%
    mutate(
      tDif = as.numeric(str_extract(stat, "\\d+\\.*\\d*")),
      stat = ifelse(grepl("lnRR", stat), "lnRR", stat))
  
  # separate control values into their own column
  ctl <- df.sp %>% filter(stat == "control") %>% select(sit_name, day, depth, control_mean = mean)
  df.sp %>% filter(stat != "control") %>% left_join(ctl, by = c("sit_name", "day", "depth"))
}), nm = names(temp.clean.ls))

# merge st & sm
st.sm.lnRR.df <- merge(
  bind_rows(moist.clean.lnRR.ls, .id = "exp_name"),
  bind_rows(temp.clean.d.ls2, .id = "exp_name") %>%
    filter(stat == "dif"),
  by = c("exp_name", "sit_name", "day", "depth", "tDif"),
  suffixes = c(".sm", ".st"))

st.sm.lnRR.df$eco <- eco.df[match(st.sm.lnRR.df$sit_name, eco.df$sit_name), "eco"]
st.sm.lnRR.df$wrm <- wrm.df[match(st.sm.lnRR.df$sit_name, wrm.df$sit_name), "wrm"]
st.sm.lnRR.df$biome <- eco.df[match(st.sm.lnRR.df$sit_name, eco.df$sit_name), "biome"]
st.sm.lnRR.df <- cbind(st.sm.lnRR.df, mat.map.df[match(st.sm.lnRR.df$sit_name, mat.map.df$sit_name), c("MAT", "MAP")])

st.sm.lnRR.df %>% ggplot(., aes(st_mean, mean, color = depth)) + geom_hline(yintercept = 0, linetype = 2) + geom_vline(xintercept = 0, linetype = 2) + geom_point() + facet_wrap(vars(sit_name), scales = "free") + theme_bw() + theme(panel.grid = element_blank())

sm.st.lnRR.lmx2 <- st.sm.lnRR.df %>%
  filter(eco != "tundra") %>%
  mutate(across(c(st_mean, control_mean.sm, control_mean.st), ~ scale(.x, center = TRUE, scale = FALSE))) %>%
  lmer(mean ~ st_mean * control_mean.sm + st_mean * control_mean.st + depth + eco + growSeas + (st_mean | sit_name), .)

# check_model(sm.st.lnRR.lmx)

emmeans(sm.st.lnRR.lmx, list(pairwise ~ eco), adjust = "tukey")

# compare slopes w/ interaction
emtrends(sm.st.lnRR.lmx, specs = "eco", var = "st_mean", at = list(growSeas = "growing season"))

ci <- confint(sm.st.lnRR.lmx2)
exp(ci)
```

### texture

Compare mean sand content by depth w/ mean soil moisture difference (trt-ctl)

Would also be good to account for MAP

```{r texture}
ACBB.sand <- read.csv("../data/experiments/ACBB/input_data/Sand.csv")
ACBB.sand.sp <- mpspline(ACBB.sand[ , c("Date", "depth_upper", "depth_lower", "Sand")], d = c(5, 15, 30, 50, 75, 100))

```

```{r local-clim}
map <- worldclim_global(var = "prec", res = 0.5, path = "/Users/jbeemmil@umich.edu/geospatial/worldclim.prec.05")
mat 
pet

nms <- basename(geo.paths)
df <- data.frame(matrix(nrow))
for (x in geo.paths) {
  tifRaster <- rast(x)
  terra::crs(tifRaster) <- CRS
  ext <- extract(tifRaster, cbind(database$site$sit_long, database$site$sit_lat))
}

sit.df <- bind_rows(lapply(database, function(x) x$site[ , c("sit_name", "sit_lat", "sit_long")]), .id = "expName")

```